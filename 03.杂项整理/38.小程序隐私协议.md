## 小程序隐私协议

> 官网写的就是一坨，说了一堆废话，拢共关键的就几句

方案概括
* 一种是开发者主动弹起隐私协议，引导用户去确认
* 一种是在需要隐私确认的api(比如获取头像、位置等)，通过事件监听`wx.onNeedPrivacyAuthorization`来触发弹起隐私协议

### 方案一

#### 在App.vue这个页面里，在`onLaunch`中注册事件监听，然后在全局缓存resolve函数（建议用vuex或者pinia，仁者见仁智者见智），在需要的时候进行调用

```javascript
// 由于不确定用的是vuex或者pinia，这里就意思一下
uni.onNeedPrivacyAuthorization((resolve, eventInfo) => {
    toggleStore.privacyModal.resolvePrivacyAuthorization = resolve;
    toggleStore.togglePrivacyModal(true);
});
```

#### 注册一个全局组件，通过`vuex或者pinia`中的**state**全局变量来控制显影，然后在所有可能需要隐私协议弹窗的页面，引入该组件

```html
<template>
    <view>
        <!-- 
            .......
        -->
        <privacy-modal/>
    </view>
</template>
<script>
    export default {
        data() {
            retutn {

            }
        }
    }
</script>
```
#### 或者图省事，可以使用vite的自定义插件功能
[https://www.vitejs.net/guide/api-plugin.html](https://www.vitejs.net/guide/api-plugin.html)

##### 教程
```javascript
export default function myPlugin() {
    const virtualFileId = '@my-virtual-file'
    return {
        name: 'my-plugin',
        transform(code, id) { // code是文件代码， id是虚拟文件路径，虚拟！虚拟！虚拟！虚拟！

        },
        resolveId(id) {
            if (id === virtualFileId) {
                return virtualFileId
            }
        },
        load(id) {
            if (id === virtualFileId) {
                return `export const msg = "from virtual file"`
            }
        }
    }
}
```

// 注册
```javascript
import vue from '@vitejs/plugin-vue'
import { defineConfig } from 'vite'
import myPlugin from './myPlugin'

export default defineConfig({
  plugins: [vue(), myPlugin()]
})
```

// 使用

```javascript
import { msg } from '@my-virtual-file'
console.log(msg)
```

##### 模仿教程

// 正在注册我们的弹窗
```javascript
export default (component) => {
  return {
    name: 'injectTemplateToPages',
    enforce: 'pre', // 来调整它的应用顺序。enforce 的值可以是pre 或 post。（https://www.vitejs.net/guide/api-plugin.html#plugin-ordering）
    transform(code, id) { // code 代码，id 文件路径
      // vue文件，且不是App.vue，不是components目录下的文件
      const shouldInject =
        /\.vue$/.test(id) && !/App\.vue$/.test(id) && !/components/.test(id);
      if (shouldInject) {
        // 注入模板代码,将开始的
        // 正则表达式 /\B<template>/ 匹配的是不在单词边界的 <template> 字符串。具体来说，\B 是一个零宽度断言，表示不在单词边界的位置，也就是说，匹配的是 <template> 这个字符串，但是它的前面或后面不能是单词字符，例如空格、标点符号等。
        code = code.replace(/\B<template>/, (str) => `${str}${component}`);
      }
      return {
        code,
        map: null,
      };
    },
  };
};
```

// 引入
```javascript
export default defineConfig({
  // 每个页面注入隐私弹窗
  plugins: [uni(), injectTemplateToPages('<PrivacyModal />')],
});
```

### 方案二

这里是一个偷懒的方案，就是在uni.login的时候，微信那个`getuserinfo`和`wx.getUserProfile` 时候，进行隐私拦截，因为咱们很多的小程序都是需要在登录后使用，那就在登录时进行一个统一的拦截，提示引导用户去授权隐私.即把这个隐私协议做成完成登录的一部分。

```html
<template>
    <view>
        <view @click="readPrivacyAuth">{{ title }}</view>
        <customButton customId="refuseBtn" text="拒绝" @click="onRefuse" />
        <customButton customId="confirmBtn" open-type="agreePrivacyAuthorization" @agreeprivacyauthorization="onConfirm" type="primary" text="同意" />
    </view>
</template>
<script>
    export default {
        methods: {
            readPrivacyAuth() {
                wx.openPrivacyContract({
                    success: () => { }
                })
            },
            onRefuse() {
                this.$emit('disagree')
                this.onClose()
            },
            onConfirm() {
                this.$emit('agree')
                this.onClose()
            },
            toggleSetShow(show = true) {
                if (show) {
                    if (wx.getPrivacySetting) {
                        wx.getPrivacySetting({
                            success: (res) => {
                                if (res.needAuthorization) {
                                    this.title = res.privacyContractName
                                    this.show = true
                                } else {
                                    this.onClose()
                                    this.onConfirm()
                                }
                            }
                        })
                    } else {
                        this.onClose()
                        this.onConfirm()
                    }
                } else {
                    this.onClose()
                }
            },
        }
    } 
</script>
```