# uniapp 文本超过 N 行显示展开收起

> - 组件 1: 运算简单和渲染占用少，但有时候省略号会遮不住文本
> - 组件 2: 省略号位置是计算出来的，不会遮住文本，但运算和渲染占用会大一些
>   - 组件 2-1: 省略号位置于文本尾部
>   - 组件 2-2: 省略号位置于文本中间（并不是宽度的中间，而是 startStr.length === endStr.length 处），极端文本比如: **前半部分是数字，后半部分是汉字的文本**，则省略号显示的位置则看起来像是歪的
>   - 组件 2-3: 省略号位置于文本前部

## 为什么组件 2 拆成 3 个

因为省略号显示到中间和显示到两端采用的算法完全不一样，其实省略号显示到两端可以合并为一个组件，但显示到中间这个组件已经拆出来了，那么显示到两端也顺手拆开

> @/utils/components-tools.ts ---> 04.杂项整理/35.components-tools.md

// symbolStyle collapseStyle expandStyle textStyle 这几个 style 自定义时最好只设置 fontSize color lineHeight 等涉及 font 的 css 属性，不要添加 padding margin 等可能改变文本高度或者改变布局的属性，

## 组件 1

```html
<template>
  <view
    :id="textContentId"
    class="text-content"
    :style="[showText ? {} : { '-webkit-line-clamp': n }, textStyle]"
  >
    <text>{{ text }}</text>

    <text
      v-if="isEllipsis && showText"
      :style="[textStyle, collapseStyle]"
      @click="shiftText"
    >
      {{ collapseText }}
    </text>

    <text
      v-if="isEllipsis && !showText"
      class="btn-text"
      :style="textStyle"
      @click="shiftText"
    >
      <text :style="symbolStyle"> {{ symbolText }} </text>
      <text :style="expandStyle"> {{ expandText }} </text>
    </text>

    <text
      :id="textPlaceholderHeightId"
      :style="[textStyle, { color: 'transparent' }]"
      class="text-placeholder__height"
    >
      占位
    </text>
  </view>
</template>

<script setup lang="ts">
  import { getCurrentInstance, nextTick, onMounted, ref, watch } from "vue";
  import { getUuid } from "@/utils/components-tools";

  /**
   * @name TextEllipsis
   * @description 文本超出N行显示（...全文）
   * @param {string} text 文本
   * @param {number} n 文本超出n行显示省略
   */

  export interface EllipsisPropsType {
    text?: string;
    n?: number;
    collapseText?: string;
    expandText?: string;
    symbolText?: string;
    textStyle?: AnyStyleType;
    symbolStyle?: AnyStyleType;
    collapseStyle?: AnyStyleType;
    expandStyle?: AnyStyleType;
  }

  const props = withDefaults(defineProps<EllipsisPropsType>(), {
    text: "",
    n: 1,
    collapseText: "收起",
    expandText: "展开",
    symbolText: "...",
    textStyle: () => ({
      fontSize: "30rpx",
      lineHeight: 1.3,
    }),
    symbolStyle: () => ({
      color: "red",
    }),
    collapseStyle: () => ({
      color: "orange",
    }),
    expandStyle: () => ({
      color: "green",
    }),
  });

  const uuid = getUuid();

  const textContentId = `textContentId${uuid}`;
  const textPlaceholderHeightId = `textPlaceholderHeightId${uuid}`;

  const showText = ref(true);
  const isEllipsis = ref(false);
  const { proxy } = getCurrentInstance() as any;

  const shiftText = () => {
    showText.value = !showText.value;
  };

  const initGetRect = () => {
    showText.value = true;
    isEllipsis.value = false;
    const query = uni.createSelectorQuery().in(proxy);
    let textHeight = 0;
    // 计算占位字体高度

    query
      .select(`#${textPlaceholderHeightId}`)
      .fields(
        {
          computedStyle: ["letter-spacing"],
        },
        (res) => {
          console.log("initGetRect", res);
        }
      )
      .exec();

    query
      .select(`#${textPlaceholderHeightId}`)
      .boundingClientRect((data) => {
        textHeight = (data as UniApp.NodeInfo).height || 0;
      })
      .exec();

    query
      .select(`#${textContentId}`)
      .boundingClientRect((data) => {
        const height = (data as UniApp.NodeInfo).height || 0;
        if (height - 0.1 > textHeight * props.n) {
          // 计算误差小于0.1
          isEllipsis.value = true;
          showText.value = false;
        }
      })
      .exec();
  };

  watch(
    props,
    () => {
      nextTick(() => {
        initGetRect();
      });
    },
    {
      immediate: true,
    }
  );
</script>

<style lang="scss" scoped>
  .text-content {
    position: relative;
    text-overflow: ellipsis;
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;

    .text-placeholder__height {
      position: absolute;
      top: 0;
      left: 0;
    }

    .btn-text {
      position: absolute;
      right: 0;
      bottom: 0;
      z-index: 2;
      padding-right: 0.25em;
      display: inline;
      background-color: #fff;
    }
  }
</style>
```

## 组件 2

### 组件 2-1

```html
<template>
  <view
    :id="textContentId"
    ref="textContentRef"
    class="text-content"
    :style="[showText ? {} : { 'line-clamp': n, '-webkit-line-clamp': n }, textStyle]"
  >
    <text>{{ showText ? text : targetText }}</text>
    <template v-if="isEllipsis">
      <text
        v-if="showText"
        :style="[{ whiteSpace: 'nowrap' }, textStyle, collapseStyle]"
        @click="shiftText"
      >
        {{ collapseText }}
      </text>

      <text v-else :style="[{ whiteSpace: 'nowrap' }, textStyle]">
        <text :style="[{ whiteSpace: 'nowrap' }, textStyle, symbolStyle]">
          {{ symbolText }}
        </text>
        <text
          :style="[{ whiteSpace: 'nowrap' }, textStyle, expandStyle]"
          @click="shiftText"
        >
          {{ expandText }}
        </text>
      </text>
    </template>

    <view
      :id="textContentCopyId"
      ref="textContentCopyRef"
      :style="[textContentCopyStyle, textStyle]"
      class="text-hidden"
    >
      <text>{{ targetCopyText }}</text>
    </view>

    <view :style="[textContentCopyStyle, textStyle]" class="text-hidden">
      <text
        :id="textSuffixId"
        ref="textSuffixRef"
        :style="[textStyle, { color: 'transparent' }]"
        class="text-hidden"
      >
        {{ textSuffix }}
      </text>
    </view>

    <text
      :id="textPlaceholderExpandId"
      ref="textPlaceholderExpandRef"
      :style="[{ whiteSpace: 'nowrap' }, textStyle, { color: 'transparent' }]"
      class="text-hidden"
    >
      <text :style="[{ whiteSpace: 'nowrap' }, textStyle, symbolStyle]">
        {{ symbolText }}
      </text>
      <text :style="[{ whiteSpace: 'nowrap' }, textStyle, expandStyle]">
        {{ expandText }}
      </text>
    </text>

    <text
      :id="textPlaceholderHeightId"
      ref="textPlaceholderHeightRef"
      :style="[textStyle, { color: 'transparent' }]"
      class="text-hidden"
    >
      占位
    </text>
  </view>
</template>

<script setup lang="ts">
  import { getUuid, queryRect } from "@/utils/components-tools";
  import { getCurrentInstance, nextTick, onMounted, ref, watch } from "vue";

  /**
   * @name TextEllipsis
   * @description 文本超出N行显示（...全文）
   *
   * @param {string} text 文本
   * @param {number} n 文本超出n行显示省略号
   *
   * @param {string} collapseText 收起文本
   * @param {string} expandText 展开文本
   * @param {string} symbolText 省略号文本
   *
   *  (注：collapseText的长度不要超过 expandText+symbolText长度，不然会有点奇妙小bug)
   *
   * @param {AnyStyleType} textStyle 文本样式
   * @param {AnyStyleType} symbolStyle 省略号样式
   * @param {AnyStyleType} collapseStyle 收起文本样式
   * @param {AnyStyleType} expandStyle 展开文本样式
   */

  export interface EllipsisPropsType {
    text?: string;
    n?: number;
    collapseText?: string;
    expandText?: string;
    textStyle?: AnyStyleType;
    symbolText?: string;
    symbolStyle?: AnyStyleType;
    collapseStyle?: AnyStyleType;
    expandStyle?: AnyStyleType;
  }

  const props = withDefaults(defineProps<EllipsisPropsType>(), {
    text: "",
    n: 2,
    collapseText: "收起",
    expandText: "展开",
    symbolText: "...",
    textStyle: () => ({
      fontSize: "30rpx",
      lineHeight: 1.3,
    }),
    symbolStyle: () => ({
      color: "red",
    }),
    collapseStyle: () => ({
      color: "orange",
    }),
    expandStyle: () => ({
      color: "green",
    }),
  });

  const uuid = getUuid();

  const textContentCopyStyle = ref<AnyStyleType>({});

  const textContentId = `textContentId${uuid}`;
  const textContentRef = ref<HTMLElement>();

  const textContentCopyId = `textContentCopyId${uuid}`;
  const textContentCopyRef = ref<HTMLElement>();

  const textPlaceholderExpandId = `textPlaceholderExpandId${uuid}`;
  const textPlaceholderExpandRef = ref<HTMLElement>();

  const textPlaceholderHeightId = `textPlaceholderHeightId${uuid}`;
  const textPlaceholderHeightRef = ref<HTMLElement>();

  const textSuffixId = `textSuffixId${uuid}`;
  const textSuffixRef = ref<HTMLElement>();

  const textSuffix = ref("");
  const showText = ref(false); // 是否展开
  const targetText = ref(""); // 目标文本
  const targetCopyText = ref(""); // 目标文本

  const isEllipsis = ref(false); // 是否需要显示省略号和展开/收起按钮
  const instance = getCurrentInstance() as any;

  const shiftText = () => {
    showText.value = !showText.value;
  };

  const getSize = (): Promise<{
    textHeight: number;
    contentWidth: number;
    textPlaceholderExpandWidth: number;
  }> => {
    return new Promise((resolve) => {
      Promise.all([
        queryRect(
          `#${textPlaceholderHeightId}`,
          instance,
          textPlaceholderHeightRef.value
        ),
        queryRect(`#${textContentId}`, instance, textContentRef.value),
        queryRect(
          `#${textPlaceholderExpandId}`,
          instance,
          textPlaceholderExpandRef.value
        ),
      ]).then(
        ([
          textPlaceholderHeightRes,
          textContentRes,
          textPlaceholderExpandRes,
        ]) => {
          resolve({
            textHeight: textPlaceholderHeightRes.height || 0,
            contentWidth: textContentRes.width || 0,
            textPlaceholderExpandWidth: textPlaceholderExpandRes.width || 0,
          });
        }
      );
    });
  };

  const initGetRect = (
    resultText: string,
    textHeight: number,
    textPlaceholderExpandWidth: number
  ) => {
    console.log(
      "initGetRect111",
      resultText,
      textHeight,
      textPlaceholderExpandWidth
    );
    targetText.value = "";
    textSuffix.value = "";

    // 目标高度：n行文本的高度
    const targetHeight = textHeight * props.n;

    // 如果文本为空，直接返回
    if (!resultText) {
      targetText.value = "";
      isEllipsis.value = false;
      textSuffix.value = "";
      return;
    }

    const checkHeight = (mid: number, text: string) => {
      return new Promise<boolean>((resolve) => {
        targetCopyText.value = text.substring(0, mid);

        nextTick(() => {
          queryRect(
            `#${textContentCopyId}`,
            instance,
            textContentCopyRef.value
          ).then((data) => {
            const currentHeight = (data as UniApp.NodeInfo).height || 0;
            resolve(currentHeight <= targetHeight);
          });
        });
      });
    };

    const binarySearchText = (text: string): Promise<number> => {
      return new Promise((resolve) => {
        let left = 0;
        let right = text.length;
        let result = 0;
        const search = async () => {
          if (left > right) {
            resolve(result); // 找到最大的满足条件的文本长度
            return;
          }

          const mid = Math.floor((left + right) / 2);
          const isWithinHeight = await checkHeight(mid, text);

          if (isWithinHeight) {
            // 如果当前长度满足高度要求，尝试更长的文本
            result = mid;
            left = mid + 1;
          } else {
            // 如果当前长度超过高度要求，尝试更短的文本
            right = mid - 1;
          }
          search();
        };
        search();
      });
    };

    const getTargetTextSuffixWidth = (suffix: string): Promise<number> => {
      return new Promise((resolve) => {
        textSuffix.value = suffix;
        nextTick(() => {
          queryRect(`#${textSuffixId}`, instance, textSuffixRef.value).then(
            (data) => {
              const suffixWidth = data.width || 0;
              resolve(suffixWidth);
            }
          );
        });
      });
    };

    const getTargetTextSuffix = (result: string): Promise<number> => {
      return new Promise((resolve) => {
        let length = 0;
        const search = async () => {
          length = length + 1;
          const suffix = result.slice(-length, result.length);
          const suffixWidth = await getTargetTextSuffixWidth(suffix);

          if (suffixWidth <= textPlaceholderExpandWidth) {
            console.log(
              "suffixWidth",
              textSuffix.value,
              suffixWidth,
              textPlaceholderExpandWidth
            );
            return search();
          } else {
            return resolve(length);
          }
        };

        search();
      });
    };

    binarySearchText(resultText).then((result) => {
      const str = resultText.substring(0, result);
      isEllipsis.value = result < resultText.length;
      if (isEllipsis.value) {
        getTargetTextSuffix(str).then((suffixLength) => {
          targetText.value = resultText.substring(0, result - suffixLength);
        });
      } else {
        targetText.value = resultText.substring(0, result);
      }
    });
  };

  watch(
    props,
    () => {
      console.log("props.text", props.text);
      nextTick(async () => {
        const { textHeight, contentWidth, textPlaceholderExpandWidth } =
          await getSize();
        textContentCopyStyle.value.width = `${contentWidth}px`;
        initGetRect(props.text, textHeight, textPlaceholderExpandWidth);
      });
    },
    {
      immediate: true,
    }
  );
</script>

<style lang="scss" scoped>
  .text-content {
    position: relative;
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    word-break: break-all;

    .text-hidden {
      position: absolute;
      top: -99999px;
      left: -99999px;
      z-index: -1;
      opacity: 0;
    }
  }
</style>
```

### 组件 2-2

```html
<template>
  <view
    :id="textContentId"
    ref="textContentRef"
    class="text-content"
    :style="[showText ? {} : { 'line-clamp': n, '-webkit-line-clamp': n }, textStyle]"
  >
    <template v-if="showText">
      <text>{{ text }}</text>
      <text
        :style="[{ whiteSpace: 'nowrap' }, textStyle, collapseStyle]"
        @click="shiftText"
      >
        {{ collapseText }}
      </text>
    </template>
    <template v-else>
      <template v-if="isEllipsis">
        <text>{{ startText }}</text>
        <text :style="[{ whiteSpace: 'nowrap' }, textStyle]">
          <text :style="[{ whiteSpace: 'nowrap' }, textStyle, symbolStyle]">
            {{ symbolText }}
          </text>
          <text
            :style="[{ whiteSpace: 'nowrap' }, textStyle, expandStyle]"
            @click="shiftText"
          >
            {{ expandText }}
          </text>
        </text>
        <text>{{ endText }}</text>
      </template>
      <text v-else> {{ text }} </text>
    </template>

    <view
      :id="textContentCopyId"
      ref="textContentCopyRef"
      :style="[textContentCopyStyle, textStyle]"
      class="text-hidden"
    >
      <text>{{ targetCopyText }}</text>
    </view>

    <view :style="[textContentCopyStyle, textStyle]" class="text-hidden">
      <text
        :id="textSuffixId"
        ref="textSuffixRef"
        :style="[textStyle, { color: 'transparent' }]"
        class="text-hidden"
      >
        {{ textSuffix }}
      </text>
    </view>

    <text
      :id="textPlaceholderExpandId"
      ref="textPlaceholderExpandRef"
      :style="[{ whiteSpace: 'nowrap' }, textStyle, { color: 'transparent' }]"
      class="text-hidden"
    >
      <text :style="[{ whiteSpace: 'nowrap' }, textStyle, symbolStyle]">
        {{ symbolText }}
      </text>
      <text :style="[{ whiteSpace: 'nowrap' }, textStyle, expandStyle]">
        {{ expandText }}
      </text>
    </text>

    <text
      :id="textPlaceholderHeightId"
      ref="textPlaceholderHeightRef"
      :style="[textStyle, { color: 'transparent' }]"
      class="text-hidden"
    >
      占位
    </text>
  </view>
</template>

<script setup lang="ts">
  import { getUuid, queryRect } from "@/utils/components-tools";
  import { getCurrentInstance, nextTick, onMounted, ref, watch } from "vue";

  /**
   * @name TextEllipsis
   * @description 文本超出N行显示（...全文）
   *
   * @param {string} text 文本
   * @param {number} n 文本超出n行显示省略号
   *
   * @param {string} collapseText 收起文本
   * @param {string} expandText 展开文本
   * @param {string} symbolText 省略号文本
   *
   *  (注：collapseText的长度不要超过 expandText+symbolText长度，不然会有点奇妙小bug)
   *
   * @param {AnyStyleType} textStyle 文本样式
   * @param {AnyStyleType} symbolStyle 省略号样式
   * @param {AnyStyleType} collapseStyle 收起文本样式
   * @param {AnyStyleType} expandStyle 展开文本样式
   */

  export interface EllipsisPropsType {
    text?: string;
    n?: number;
    collapseText?: string;
    expandText?: string;
    textStyle?: AnyStyleType;
    symbolText?: string;
    symbolStyle?: AnyStyleType;
    collapseStyle?: AnyStyleType;
    expandStyle?: AnyStyleType;
  }

  const props = withDefaults(defineProps<EllipsisPropsType>(), {
    text: "",
    n: 2,
    collapseText: "收起",
    expandText: "展开",
    symbolText: "...",
    textStyle: () => ({
      fontSize: "30rpx",
      lineHeight: 1.3,
    }),
    symbolStyle: () => ({
      color: "red",
    }),
    collapseStyle: () => ({
      color: "orange",
    }),
    expandStyle: () => ({
      color: "green",
    }),
  });

  const uuid = getUuid();

  const textContentCopyStyle = ref<AnyStyleType>({});

  const textContentId = `textContentId${uuid}`;
  const textContentRef = ref<HTMLElement>();

  const textContentCopyId = `textContentCopyId${uuid}`;
  const textContentCopyRef = ref<HTMLElement>();

  const textPlaceholderExpandId = `textPlaceholderExpandId${uuid}`;
  const textPlaceholderExpandRef = ref<HTMLElement>();

  const textPlaceholderHeightId = `textPlaceholderHeightId${uuid}`;
  const textPlaceholderHeightRef = ref<HTMLElement>();

  const textSuffixId = `textSuffixId${uuid}`;
  const textSuffixRef = ref<HTMLElement>();

  const textSuffix = ref("");
  const showText = ref(false); // 是否展开
  const targetText = ref(""); // 目标文本
  const targetCopyText = ref(""); // 目标文本
  const startText = ref(""); // 文本前半部分
  const endText = ref(""); // 文本后半部分

  const isEllipsis = ref(false); // 是否需要显示省略号和展开/收起按钮
  const instance = getCurrentInstance() as any;

  const shiftText = () => {
    showText.value = !showText.value;
  };

  const getSize = (): Promise<{
    textHeight: number;
    contentWidth: number;
    textPlaceholderExpandWidth: number;
  }> => {
    return new Promise((resolve) => {
      Promise.all([
        queryRect(
          `#${textPlaceholderHeightId}`,
          instance,
          textPlaceholderHeightRef.value
        ),
        queryRect(`#${textContentId}`, instance, textContentRef.value),
        queryRect(
          `#${textPlaceholderExpandId}`,
          instance,
          textPlaceholderExpandRef.value
        ),
      ]).then(
        ([
          textPlaceholderHeightRes,
          textContentRes,
          textPlaceholderExpandRes,
        ]) => {
          resolve({
            textHeight: textPlaceholderHeightRes.height || 0,
            contentWidth: textContentRes.width || 0,
            textPlaceholderExpandWidth: textPlaceholderExpandRes.width || 0,
          });
        }
      );
    });
  };

  const initGetRect = (
    resultText: string,
    textHeight: number,
    textPlaceholderExpandWidth: number
  ) => {
    console.log(
      "initGetRect111",
      resultText,
      textHeight,
      textPlaceholderExpandWidth
    );
    targetText.value = "";
    textSuffix.value = "";

    // 目标高度：n行文本的高度
    const targetHeight = textHeight * props.n;

    // 如果文本为空，直接返回
    if (!resultText) {
      targetText.value = "";
      isEllipsis.value = false;
      textSuffix.value = "";
      return;
    }

    const checkHeight = (mid: number, text: string) => {
      return new Promise<boolean>((resolve) => {
        targetCopyText.value = text.substring(0, mid);

        nextTick(() => {
          queryRect(
            `#${textContentCopyId}`,
            instance,
            textContentCopyRef.value
          ).then((data) => {
            const currentHeight = (data as UniApp.NodeInfo).height || 0;
            resolve(currentHeight <= targetHeight);
          });
        });
      });
    };

    const binarySearchText = (text: string): Promise<number> => {
      return new Promise((resolve) => {
        let left = 0;
        let right = text.length;
        let result = 0;
        const search = async () => {
          if (left > right) {
            resolve(result); // 找到最大的满足条件的文本长度
            return;
          }

          const mid = Math.floor((left + right) / 2);
          const isWithinHeight = await checkHeight(mid, text);

          if (isWithinHeight) {
            // 如果当前长度满足高度要求，尝试更长的文本
            result = mid;
            left = mid + 1;
          } else {
            // 如果当前长度超过高度要求，尝试更短的文本
            right = mid - 1;
          }
          search();
        };
        search();
      });
    };

    const getTargetTextSuffixWidth = (suffix: string): Promise<number> => {
      return new Promise((resolve) => {
        textSuffix.value = suffix;
        nextTick(() => {
          queryRect(`#${textSuffixId}`, instance, textSuffixRef.value).then(
            (data) => {
              const suffixWidth = data.width || 0;
              resolve(suffixWidth);
            }
          );
        });
      });
    };

    const getTargetTextSuffix = (result: string): Promise<number> => {
      return new Promise((resolve) => {
        let length = 0;
        const search = async () => {
          length = length + 1;
          const suffix = result.slice(-length, result.length);
          const suffixWidth = await getTargetTextSuffixWidth(suffix);

          if (suffixWidth <= textPlaceholderExpandWidth) {
            console.log(
              "suffixWidth",
              textSuffix.value,
              suffixWidth,
              textPlaceholderExpandWidth
            );
            return search();
          } else {
            return resolve(length);
          }
        };

        search();
      });
    };

    binarySearchText(resultText).then((result) => {
      isEllipsis.value = result < resultText.length;
      if (isEllipsis.value) {
        // 计算中间位置，留出空间给展开按钮
        getTargetTextSuffix(resultText.substring(0, result)).then(
          (suffixLength) => {
            // 计算文本总长度，减去展开按钮占用的空间
            const totalLength = result - suffixLength;
            // 将文本分为前半部分和后半部分，中间显示省略号和展开按钮
            const midPoint = Math.floor(totalLength / 2);
            startText.value = resultText.substring(0, midPoint);
            endText.value = resultText.substring(
              midPoint + suffixLength,
              result
            );
          }
        );
      } else {
        startText.value = resultText;
        endText.value = "";
      }
    });
  };

  watch(
    props,
    () => {
      console.log("props.text", props.text);
      nextTick(async () => {
        const { textHeight, contentWidth, textPlaceholderExpandWidth } =
          await getSize();
        textContentCopyStyle.value.width = `${contentWidth}px`;
        initGetRect(props.text, textHeight, textPlaceholderExpandWidth);
      });
    },
    {
      immediate: true,
    }
  );
</script>

<style lang="scss" scoped>
  .text-content {
    position: relative;
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    word-break: break-all;

    .text-hidden {
      position: absolute;
      top: -99999px;
      left: -99999px;
      z-index: -1;
      opacity: 0;
    }
  }
</style>
```

### 组件 2-3

```html
<template>
  <view
    :id="textContentId"
    ref="textContentRef"
    class="text-content"
    :style="[showText ? {} : { 'line-clamp': n, '-webkit-line-clamp': n }, textStyle]"
  >
    <template v-if="isEllipsis">
      <template v-if="showText">
        <text
          :style="[{ whiteSpace: 'nowrap' }, textStyle, collapseStyle]"
          @click="shiftText"
        >
          {{ collapseText }}
        </text>
        <text>{{ text }}</text>
      </template>
      <template v-else>
        <text :style="[{ whiteSpace: 'nowrap' }, textStyle]">
          <text :style="[{ whiteSpace: 'nowrap' }, textStyle, symbolStyle]">
            {{ symbolText }}
          </text>
          <text
            :style="[{ whiteSpace: 'nowrap' }, textStyle, expandStyle]"
            @click="shiftText"
          >
            {{ expandText }}
          </text>
        </text>
        <text>{{ targetText }}</text>
      </template>
    </template>
    <template v-else>
      <text>{{ text }}</text>
    </template>

    <view
      :id="textContentCopyId"
      ref="textContentCopyRef"
      :style="[textContentCopyStyle, textStyle]"
      class="text-hidden"
    >
      <text>{{ targetCopyText }}</text>
    </view>

    <view :style="[textContentCopyStyle, textStyle]" class="text-hidden">
      <text
        :id="textSuffixId"
        ref="textSuffixRef"
        :style="[textStyle, { color: 'transparent' }]"
        class="text-hidden"
      >
        {{ textSuffix }}
      </text>
    </view>

    <text
      :id="textPlaceholderExpandId"
      ref="textPlaceholderExpandRef"
      :style="[{ whiteSpace: 'nowrap' }, textStyle, { color: 'transparent' }]"
      class="text-hidden"
    >
      <text :style="[{ whiteSpace: 'nowrap' }, textStyle, symbolStyle]">
        {{ symbolText }}
      </text>
      <text :style="[{ whiteSpace: 'nowrap' }, textStyle, expandStyle]">
        {{ expandText }}
      </text>
    </text>

    <text
      :id="textPlaceholderHeightId"
      ref="textPlaceholderHeightRef"
      :style="[textStyle, { color: 'transparent' }]"
      class="text-hidden"
    >
      占位
    </text>
  </view>
</template>

<script setup lang="ts">
  import { getUuid, queryRect } from "@/utils/components-tools";
  import { getCurrentInstance, nextTick, onMounted, ref, watch } from "vue";

  /**
   * @name TextEllipsis
   * @description 文本超出N行显示（...全文）
   *
   * @param {string} text 文本
   * @param {number} n 文本超出n行显示省略号
   *
   * @param {string} collapseText 收起文本
   * @param {string} expandText 展开文本
   * @param {string} symbolText 省略号文本
   *
   *  (注：collapseText的长度不要超过 expandText+symbolText长度，不然会有点奇妙小bug)
   *
   * @param {AnyStyleType} textStyle 文本样式
   * @param {AnyStyleType} symbolStyle 省略号样式
   * @param {AnyStyleType} collapseStyle 收起文本样式
   * @param {AnyStyleType} expandStyle 展开文本样式
   */

  export interface EllipsisPropsType {
    text?: string;
    n?: number;
    collapseText?: string;
    expandText?: string;
    textStyle?: AnyStyleType;
    symbolText?: string;
    symbolStyle?: AnyStyleType;
    collapseStyle?: AnyStyleType;
    expandStyle?: AnyStyleType;
  }

  const props = withDefaults(defineProps<EllipsisPropsType>(), {
    text: "",
    n: 2,
    collapseText: "收起",
    expandText: "展开",
    symbolText: "...",
    textStyle: () => ({
      fontSize: "30rpx",
      lineHeight: 1.3,
    }),
    symbolStyle: () => ({
      color: "red",
    }),
    collapseStyle: () => ({
      color: "orange",
    }),
    expandStyle: () => ({
      color: "green",
    }),
  });

  const uuid = getUuid();

  const textContentCopyStyle = ref<AnyStyleType>({});

  const textContentId = `textContentId${uuid}`;
  const textContentRef = ref<HTMLElement>();

  const textContentCopyId = `textContentCopyId${uuid}`;
  const textContentCopyRef = ref<HTMLElement>();

  const textPlaceholderExpandId = `textPlaceholderExpandId${uuid}`;
  const textPlaceholderExpandRef = ref<HTMLElement>();

  const textPlaceholderHeightId = `textPlaceholderHeightId${uuid}`;
  const textPlaceholderHeightRef = ref<HTMLElement>();

  const textSuffixId = `textSuffixId${uuid}`;
  const textSuffixRef = ref<HTMLElement>();

  const textSuffix = ref("");
  const showText = ref(false); // 是否展开
  const targetText = ref(""); // 目标文本
  const targetCopyText = ref(""); // 目标文本

  const isEllipsis = ref(false); // 是否需要显示省略号和展开/收起按钮
  const instance = getCurrentInstance() as any;

  const shiftText = () => {
    showText.value = !showText.value;
  };

  const getSize = (): Promise<{
    textHeight: number;
    contentWidth: number;
    textPlaceholderExpandWidth: number;
  }> => {
    return new Promise((resolve) => {
      Promise.all([
        queryRect(
          `#${textPlaceholderHeightId}`,
          instance,
          textPlaceholderHeightRef.value
        ),
        queryRect(`#${textContentId}`, instance, textContentRef.value),
        queryRect(
          `#${textPlaceholderExpandId}`,
          instance,
          textPlaceholderExpandRef.value
        ),
      ]).then(
        ([
          textPlaceholderHeightRes,
          textContentRes,
          textPlaceholderExpandRes,
        ]) => {
          resolve({
            textHeight: textPlaceholderHeightRes.height || 0,
            contentWidth: textContentRes.width || 0,
            textPlaceholderExpandWidth: textPlaceholderExpandRes.width || 0,
          });
        }
      );
    });
  };

  const initGetRect = (
    resultText: string,
    textHeight: number,
    textPlaceholderExpandWidth: number
  ) => {
    console.log(
      "initGetRect111",
      resultText,
      textHeight,
      textPlaceholderExpandWidth
    );
    targetText.value = "";
    textSuffix.value = "";

    // 目标高度：n行文本的高度
    const targetHeight = textHeight * props.n;

    // 如果文本为空，直接返回
    if (!resultText) {
      targetText.value = "";
      isEllipsis.value = false;
      textSuffix.value = "";
      return;
    }

    const checkHeight = (mid: number, text: string) => {
      return new Promise<boolean>((resolve) => {
        targetCopyText.value = text.substring(0, mid);

        nextTick(() => {
          queryRect(
            `#${textContentCopyId}`,
            instance,
            textContentCopyRef.value
          ).then((data) => {
            const currentHeight = (data as UniApp.NodeInfo).height || 0;
            resolve(currentHeight <= targetHeight);
          });
        });
      });
    };

    const binarySearchText = (text: string): Promise<number> => {
      return new Promise((resolve) => {
        let left = 0;
        let right = text.length;
        let result = 0;
        const search = async () => {
          if (left > right) {
            resolve(result); // 找到最大的满足条件的文本长度
            return;
          }

          const mid = Math.floor((left + right) / 2);
          const isWithinHeight = await checkHeight(mid, text);

          if (isWithinHeight) {
            // 如果当前长度满足高度要求，尝试更长的文本
            result = mid;
            left = mid + 1;
          } else {
            // 如果当前长度超过高度要求，尝试更短的文本
            right = mid - 1;
          }
          search();
        };
        search();
      });
    };

    const getTargetTextSuffixWidth = (suffix: string): Promise<number> => {
      return new Promise((resolve) => {
        textSuffix.value = suffix;
        nextTick(() => {
          queryRect(`#${textSuffixId}`, instance, textSuffixRef.value).then(
            (data) => {
              const suffixWidth = data.width || 0;
              resolve(suffixWidth);
            }
          );
        });
      });
    };

    const getTargetTextPrefix = (result: string): Promise<number> => {
      return new Promise((resolve) => {
        let length = 0;
        const search = async () => {
          length = length + 1;
          const prefix = result.slice(0, length);
          const prefixWidth = await getTargetTextSuffixWidth(prefix);

          if (prefixWidth <= textPlaceholderExpandWidth) {
            console.log(
              "prefixWidth",
              textSuffix.value,
              prefixWidth,
              textPlaceholderExpandWidth
            );
            return search();
          } else {
            return resolve(length);
          }
        };

        search();
      });
    };

    binarySearchText(resultText).then((result) => {
      const str = resultText.substring(0, result);
      isEllipsis.value = result < resultText.length;
      if (isEllipsis.value) {
        getTargetTextPrefix(str).then((prefixLength) => {
          targetText.value = resultText.substring(prefixLength, result);
        });
      } else {
        targetText.value = resultText.substring(0, result);
      }
    });
  };

  watch(
    props,
    () => {
      console.log("props.text", props.text);
      nextTick(async () => {
        const { textHeight, contentWidth, textPlaceholderExpandWidth } =
          await getSize();
        textContentCopyStyle.value.width = `${contentWidth}px`;
        initGetRect(props.text, textHeight, textPlaceholderExpandWidth);
      });
    },
    {
      immediate: true,
    }
  );
</script>

<style lang="scss" scoped>
  .text-content {
    position: relative;
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    word-break: break-all;

    .text-hidden {
      position: absolute;
      top: -99999px;
      left: -99999px;
      z-index: -1;
      opacity: 0;
    }
  }
</style>
```
