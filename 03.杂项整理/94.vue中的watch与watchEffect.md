# vue 中的 watch 与 watchEffect

> 本篇为拾遗内容，具体详情：02.杂项整理 > 13.Watch 与 WatchEffect 应用之区别.md
> watchEffect() 会立即运行传入的函数，并自动追踪其中用到的响应式依赖，一旦依赖变了，就重新运行这个函数。

## 区别对比

| 特性       | watch                                | watchEffect                          |
| ---------- | ------------------------------------ | ------------------------------------ |
| 监听方式   | 明确指定监听源                       | 自动跟踪函数内使用的响应式数据       |
| 初始执行   | 默认不执行，需配置 `immediate: true` | 默认立即执行一次                     |
| 旧值访问   | 可以访问新旧值                       | 无法访问旧值                         |
| 深度监听   | 需配置 `deep: true`                  | 自动深度监听                         |
| 停止监听   | 通过返回的函数                       | 通过返回的函数                       |
| 清理副作用 | 不直接支持                           | 支持通过 `onCleanup`                 |
| 适用场景   | 监听特定源、需要新旧值对比           | 依赖多个源、不需要新旧值、需立即执行 |

## 什么时候该用 watchEffect，什么时候该用 watch

### 使用 watch

1. 需要明确监听特定数据源
2. 需要访问 “旧值” 和 “新值”
3. 默认需要 “懒执行” 副作用
4. 需要深度监听或部分监听

### 使用 watchEffect

1. 副作用依赖多个响应式数据，且不需要明确指定源
2. 需要 “立即执行” 副作用（初始化时触发）
3. 不需要关心 “旧值”，只需要 “依赖变化就执行”

## watchEffect 可能的 bug

### 循环依赖错误

```javascript
const num = ref(0);

watchEffect(() => {
  num.value++; // 循环收集自身依赖，无限递归运行
});
```

### 不是响应式依赖

```javascript
let num = 0;

num = num + 1;

watchEffect(() => {
  console.log(num); // num 不是响应式的，watchEffect 不追踪它
});
```

### 嵌套条件分支导致依赖不完整

```javascript
const a = ref(1);
const b = ref(2);

watchEffect(() => {
  if (a.value > 0) {
    console.log(b.value); // 当 a <= 0 时，b 根本没被追踪。下次即使 b 变了，也不会重新执行 watchEffect。这很容易导致逻辑错乱或“触发不了”的问题。
  }
});
```

### 仿佛收集了依赖

```javascript
const user = ref({ name: "张三", age: 12 });

watchEffect(() => {
  console.log(user); // 打印的是 ref 对象本身，没有触发 getter，Vue 无法追踪
});
```

### 没清理副作用

> https://cn.vuejs.org/api/reactivity-core.html#watcheffect

// 错误写法

```javascript
watchEffect(() => {
  const el = document.getElementById("app");
  el?.addEventListener("click", handleClick);
});
```

// 正确写法

```javascript
watchEffect((onCleanup) => {
  const el = document.getElementById("app");
  el?.addEventListener("click", handleClick);

  onCleanup(() => {
    el?.removeEventListener("click", handleClick);
  });
});
```
