# 双 token 无感刷新机制的实现

> 核心思路：用短期有效的 `Access Token` 处理日常 API 请求，用长期有效的 `Refresh Token` 在 `Access Token` 过期时自动获取新令牌，从而避免用户频繁登录

- 特点
  - `Access Token`：有效期短（如 2 小时），用于接口鉴权，放在请求头中。
  - `Refresh Token`：有效期长（如 7 天），仅用于获取新的 `Access Token`，安全性要求更高。

封装

```javascript
import { ACCESS_TOKEN_KEY, REFRESH_TOKEN_KEY } from "@/utils/static-data";
export const TokenService = {
  // 存储键名
  ACCESS_TOKEN_KEY: ACCESS_TOKEN_KEY,
  REFRESH_TOKEN_KEY: REFRESH_TOKEN_KEY,

  // 获取 Access Token
  getAccessToken() {
    return localStorage.getItem(ACCESS_TOKEN_KEY);
  },

  // 获取 Refresh Token
  getRefreshToken() {
    return localStorage.getItem(REFRESH_TOKEN_KEY);
  },

  // 存储双 Token
  setTokens(accessToken, refreshToken) {
    // 此处可配合pinia等状态管理工具
    localStorage.setItem(ACCESS_TOKEN_KEY, accessToken);
    localStorage.setItem(REFRESH_TOKEN_KEY, refreshToken);
  },

  // 清除 Token（登出）
  clearTokens() {
    // 此处可配合pinia等状态管理工具
    localStorage.removeItem(ACCESS_TOKEN_KEY);
    localStorage.removeItem(REFRESH_TOKEN_KEY);
  },
};

import axios from "axios";

const request = axios.create({
  baseURL: "https://awen.awen.com",
  timeout: 10000,
});

// 用于存储刷新 Token 的请求队列（处理并发请求）
let refreshPromise = null;

/**
 * 请求拦截器：添加 Access Token 到请求头
 */
request.interceptors.request.use(
  (config) => {
    const token = TokenService.getAccessToken();
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

/**
 * 响应拦截器：处理 401 错误（Token 过期）
 */
request.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    // 非 401 错误或已重试过 → 直接返回错误
    if (
      !error.response ||
      error.response.status !== 401 ||
      originalRequest._retry
    ) {
      return Promise.reject(error);
    }

    // 标记当前请求已进入重试流程，避免重复刷新
    originalRequest._retry = true;

    try {
      // 若当多个请求同时因 Access Token 过期失败时，通过 refreshPromise 确保只发起一次刷新请求，其他请求等待结果后重试，避免重复刷新。
      if (!refreshPromise) {
        // 调用刷新 Token 接口
        refreshPromise = axios.post("/auth/refresh-token", {
          refreshToken: TokenService.getRefreshToken(),
        });
      }

      // 等待刷新结果
      const { data } = await refreshPromise;
      const { accessToken, refreshToken } = data;

      // 更新 Token 存储
      TokenService.setTokens(accessToken, refreshToken);

      // 重置刷新请求队列
      refreshPromise = null;

      // 用新 Token 重试原请求
      originalRequest.headers.Authorization = `Bearer ${accessToken}`;
      return request(originalRequest);
    } catch (refreshError) {
      // 刷新 Token 失败（如 Refresh Token 过期）→ 强制登出
      TokenService.clearTokens();
      refreshPromise = null;
      // 跳转到登录页（根据框架调整，如 Vue 的 $router.push）
      window.location.href = "/login";
      return Promise.reject(refreshError);
    }
  }
);

export default request;
```

使用

```javascript
import request, { TokenService } from "@/request/index";

export const login = async (username, password) => {
  const { data } = await request.post("/auth/login", {
    username,
    password,
  });

  // 登录成功后存储双 Token
  const { accessToken, refreshToken } = data;
  TokenService.setTokens(accessToken, refreshToken);

  return data;
};
```
