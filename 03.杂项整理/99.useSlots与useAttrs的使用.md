# useSlots 与 useAttrs 的使用

## useAttrs

> 用于在组合式 API 中获取父组件传递给当前组件的非 props 属性（即未在组件 props 中声明的属性），替代了选项式 API 中的 this.$attrs。这些属性包括 HTML 原生属性（如 class、style）、事件监听（如 @click）等。
> useAttrs 只会包含未在 props 中声明的属性。如果某个属性在 props 中声明了，它会被归类到 props 中，而不会出现在 attrs 里。
> class 和 style 会被特殊处理，即使通过 attrs 透传，也会与组件自身的 class/style 合并。

### 在.vue 中使用

组件封装栗子：

```html
<template>
  <!-- 封装一个 CustomButton 组件，需要透传父组件传入的非 props 属性（如 disabled、class、@click 等）到内部的原生 `<button>`： -->
  <!-- 通过v-bind="attrs"透传所有非props属性 -->
  <button class="custom-btn" v-bind="attrs">
    <slot />
  </button>
</template>

<script setup>
  import { useAttrs } from "vue";

  // 获取所有非props属性
  const attrs = useAttrs();

  // 可以在setup中访问具体属性
  console.log("按钮是否禁用：", attrs.disabled);
  console.log("点击事件：", attrs.onClick); // 对应父组件的@click

  // 注意：如果组件声明了props，props中声明的属性不会出现在attrs中
  // 例如：若声明了props: { type: String }，则父组件传入的type会在props中，而非attrs
</script>
```

组件使用栗子：

```html
<template>
  <CustomButton
    type="primary"
    disabled="false"
    class="my-btn"
    @click="handleClick"
  >
    点击我
  </CustomButton>
</template>

<script setup>
  const handleClick = () => {
    console.log("按钮被点击");
  };
</script>
```

### 在.tsx 中使用

定义组件

```tsx
<import { useAttrs, VNode } from 'vue';

// 定义组件接收的props类型
interface CustomButtonProps {
  type?: 'primary' | 'default' | 'danger';
  size?: 'small' | 'medium' | 'large';
}

// 定义attrs类型（排除props中已声明的属性）
type ButtonAttrs = Omit<
  React.ButtonHTMLAttributes<HTMLButtonElement>, // 复用HTML按钮属性类型
  keyof CustomButtonProps | 'onClick' // 排除已在props中声明的属性
> & {
  onClick?: (e: MouseEvent) => void; // 单独声明点击事件类型
};

export const CustomButton = (props: CustomButtonProps) => {
  // 获取attrs并指定类型
  const attrs = useAttrs() as ButtonAttrs;

  // 处理组件逻辑（如动态样式）
  const baseClass = 'custom-btn';
  const typeClass = `btn-${props.type || 'default'}`;
  const sizeClass = `btn-${props.size || 'medium'}`;

  return (
    // 通过展开运算符透传所有非props属性
    <button
      class={[baseClass, typeClass, sizeClass]}
      {...attrs}
      // 可以覆盖或增强attrs中的事件
      onClick={(e) => {
        // 先执行组件自身逻辑
        console.log('按钮被点击');
        // 再执行父组件传入的onClick（如果有）
        if (attrs.onClick) {
          attrs.onClick(e);
        }
      }}
    >
      {/* 渲染默认插槽 */}
      {props.children}
    </button>
  );
};
```

使用组件

```tsx
export const ParentComponent = () => {
  const handleClick = (e: MouseEvent) => {
    console.log("父组件处理点击", e);
  };

  return (
    <CustomButton
      type="primary"
      size="large"
      disabled={false} // 透传的原生属性（在attrs中）
      onClick={handleClick} // 透传的事件（在attrs中）
      class="my-custom-class" // 透传的class（会与组件内部class合并）
    >
      点击我
    </CustomButton>
  );
};
```

## useSlots

用于在组合式 API 中访问父组件传递给当前组件的插槽内容，替代了选项式 API 中的 this.$slots。它返回一个包含所有插槽的对象，每个插槽都是一个可调用的函数（返回插槽对应的 VNode）。

返回值是一个对象，键是插槽名称（默认插槽为 default），值是插槽函数（调用后返回插槽内容的 VNode） ---> `{ [slotsKeyName]: VNode }`

### 在.vue 文件中

定义组件

```html
<template>
  <div class="card">
    <!-- 渲染header插槽（如果存在） -->
    <div v-if="slots.header" class="card-header">
      <slot name="header" />
    </div>

    <!-- 渲染默认插槽 -->
    <div class="card-body">
      <slot />
    </div>

    <!-- 渲染footer插槽（如果存在） -->
    <div v-if="slots.footer" class="card-footer">
      <slot name="footer" />
    </div>
  </div>
</template>

<script setup>
  import { useSlots } from "vue";

  // 获取所有插槽
  const slots = useSlots();

  // 可以在setup中判断插槽是否存在
  console.log("是否有header插槽：", !!slots.header);
  console.log("是否有默认插槽：", !!slots.default);

  // 处理作用域插槽（示例：如果有作用域插槽"content"，可传递参数）
  // 注意：作用域插槽的函数需要接收参数
  if (slots.content) {
    // 调用插槽函数并传递参数（类似模板中的 <slot name="content" :data="xxx" />）
    const contentVNode = slots.content({ title: "卡片内容", time: new Date() });
    console.log("作用域插槽内容：", contentVNode);
  }
</script>
```

使用 Card 组件时传入插槽：

```html
<template>
  <Card>
    <!-- 命名插槽header -->
    <template #header>
      <h3>卡片标题</h3>
    </template>

    <!-- 默认插槽 -->
    <p>这是卡片的主体内容</p>

    <!-- 命名插槽footer -->
    <template #footer>
      <button>操作按钮</button>
    </template>

    <!-- 作用域插槽content（子组件中通过slots.content调用） -->
    <template #content="scope">
      <p>{{ scope.title }} - {{ scope.time }}</p>
    </template>
  </Card>
</template>
```

### 在.tsx 中使用

定义组件

```tsx
<import { useSlots, VNode } from 'vue';

// 定义插槽类型（可选，但推荐用于TypeScript类型安全）
interface CardSlots {
  // 默认插槽：无参数，返回VNode数组
  default?: () => VNode[];
  // 命名插槽header：无参数
  header?: () => VNode[];
  // 作用域插槽content：接收参数，返回VNode数组
  content?: (props: { title: string; date: Date }) => VNode[];
}

export const Card = () => {
  // 获取插槽并指定类型
  const slots = useSlots() as CardSlots;

  return (
    <div class="card">
      {/* 渲染header插槽（存在才渲染） */}
      {slots.header && (
        <div class="card-header">
          {slots.header()} {/* 调用插槽函数渲染内容 */}
        </div>
      )}

      {/* 渲染默认插槽 */}
      <div class="card-body">
        {slots.default ? slots.default() : <p>默认内容</p>}
      </div>

      {/* 渲染作用域插槽（传递参数） */}
      {slots.content && (
        <div class="card-content">
          {/* 调用插槽函数并传递参数（作用域插槽数据） */}
          {slots.content({
            title: '今日推荐',
            date: new Date()
          })}
        </div>
      )}
    </div>
  );
};

```

使用组件

```tsx
export const ParentComponent = () => {
  return (
    <Card>
      {/* 默认插槽内容 */}
      <p>这是卡片主体内容</p>

      {/* 命名插槽header（通过属性形式传递） */}
      {{
        header: () => <h3>卡片标题</h3>,
        content: (props) => (
          <div>
            <p>{props.title}</p>
            <p>{props.date.toLocaleDateString()}</p>
          </div>
        ),
      }}
    </Card>
  );
};
```

## TSX 中使用的核心差异与优势

| 特性           | 模板语法                 | TSX 语法                             |
| -------------- | ------------------------ | ------------------------------------ |
| 插槽渲染       | `<slot name="header" />` | `slots.header?.()`                   |
| 作用域插槽参数 | `<slot :data="xxx" />`   | `slots.content?.({ data: xxx })`     |
| 属性透传       | `v-bind="$attrs"`        | `{...attrs}`                         |
| 类型安全       | `较弱（需额外定义）`     | `强（通过 TypeScript 接口严格约束）` |
| 动态逻辑       | `依赖 v-if/v-for 等指令` | `直接使用 JS 逻辑（if/map 等）`      |
