# 类型保护工具函数

Immutable Types 不可变类型（const assertions）

```typescript
const ErrorMessages = {
  InvalidEmail: "Invalid email",
  InvalidPassword: "Invalid password",
  // ...
} as const;

// 将会报错
ErrorMessages.InvalidEmail = "New error message";

/*
as const 会让 TypeScript 将 ErrorMessages 对象中的属性标记为只读（readonly）
此外，as const 还会让 TypeScript 为每个属性推断出一个更精确的类型，即它们的字面量类型，而不是一般的字符串类型。
所以，ErrorMessages 的类型会被推断为：
{
  readonly InvalidEmail: "Invalid email",
  readonly InvalidPassword: "Invalid password",
}

----------------------------------------------------------------

例子1: 
let arr = [1, 2, 3, 4];
let foo = {
  name: "foo",
  contents: arr,
} as const;

foo.name = "bar"; // 报错!
foo.contents = []; // 报错!

foo.contents.push(5); // 这将可以正常运行!

----------------------------------------------------------------

例子2: 
let foo = {
  name: "foo",
  contents: [1, 2, 3, 4],
} as const;

foo.contents.push(5); // 报错 Property 'push' does not exist on type 'readonly [1, 2, 3, 4]'

*/
```

## 工具函数

```typescript
/**
 * 获取目标原始类型
 * @param target 任意类型
 * @returns {string} type 数据类型
 */
export function getType(target: unknown): string {
  // 得到原生类型
  const typeStr = Object.prototype.toString.call(target);
  // 拿到类型值
  const match = typeStr.match(/\[object (\w+)\]/);
  const type = match && match.length ? match[1].toLowerCase() : "";
  // 类型值转小写并返回
  return type;
}

export function isString(value: unknown): value is string {
  return getType(value) === "string";
}

export function isNumber(value: unknown): value is number {
  return getType(value) === "number";
}

export function isBoolean(value: unknown): value is boolean {
  return getType(value) === "boolean";
}

export function isFunction<T extends Function>(value: any): value is T {
  return getType(value) === "function" || getType(value) === "asyncfunction";
}

export function isObject(value: unknown): value is object {
  return value && getType(value) === "object";
}

export function isArray(value: unknown): value is unknown[] {
  return Array.isArray(value);
}

export function isDate(value: unknown): value is Date {
  return (
    Object.prototype.toString.call(val) === "[object Date]" &&
    !Number.isNaN((val as Date).getTime())
  );
}

export function isPromise(value: unknown): value is Promise<any> {
  // 先将 value 断言为 object 类型
  if (isObj(value) && isDef(value)) {
    // 然后进一步检查 value 是否具有 then 和 catch 方法，并且它们是函数类型
    return (
      isFunction((value as Promise<any>).then) &&
      isFunction((value as Promise<any>).catch)
    );
  }
  return false; // 如果 value 不是对象类型，则肯定不是 Promise
}

export function isSymbol(value: unknown): value is symbol {
  return typeof value === "symbol";
}

export function isUndefined(value: unknown): value is undefined {
  return typeof value === "undefined";
}

export function isNull(value: unknown): value is null {
  return value === null;
}

export function isInstanceOf<T>(
  value: unknown,
  constructor: new (...args: any[]) => T
): value is T {
  return value instanceof constructor;
}
```
