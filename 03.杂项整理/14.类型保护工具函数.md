# 类型保护工具函数

Immutable Types 不可变类型（const assertions）

```typescript
const ErrorMessages = {
  InvalidEmail: "Invalid email",
  InvalidPassword: "Invalid password",
  // ...
} as const;

// 将会报错
ErrorMessages.InvalidEmail = "New error message";

/*
as const 会让 TypeScript 将 ErrorMessages 对象中的属性标记为只读（readonly）
此外，as const 还会让 TypeScript 为每个属性推断出一个更精确的类型，即它们的字面量类型，而不是一般的字符串类型。
所以，ErrorMessages 的类型会被推断为：
{
  readonly InvalidEmail: "Invalid email",
  readonly InvalidPassword: "Invalid password",
}

----------------------------------------------------------------

例子1: 
let arr = [1, 2, 3, 4];
let foo = {
  name: "foo",
  contents: arr,
} as const;

foo.name = "bar"; // 报错!
foo.contents = []; // 报错!

foo.contents.push(5); // 这将可以正常运行!

----------------------------------------------------------------

例子2: 
let foo = {
  name: "foo",
  contents: [1, 2, 3, 4],
} as const;

foo.contents.push(5); // 报错 Property 'push' does not exist on type 'readonly [1, 2, 3, 4]'

*/
```

## 工具函数

```typescript
export const getType = (value: any) => {
  return Object.prototype.toString.call(value).slice(8, -1).toLowerCase();
};

export const isObject = (value: any): value is Record<string, any> => {
  return getType(value) === "object";
};

export const isArray = (value: any): value is Array<any> => {
  return getType(value) === "array";
};

export const isString = (value: any): value is string => {
  return getType(value) === "string";
};

export const isNumber = (value: any): value is number => {
  return getType(value) === "number";
};

export const isBoolean = (value: any): value is boolean => {
  return getType(value) === "boolean";
};

export const isNull = (value: any): value is null => {
  return getType(value) === "null";
};

export const isUndefined = (value: any): value is undefined => {
  return getType(value) === "undefined";
};

export const isFunction = (value: any): value is (...args: any[]) => any => {
  return getType(value) === "function";
};

export const isSymbol = (value: any): value is symbol => {
  return getType(value) === "symbol";
};

export const isDate = (value: any): value is Date => {
  return getType(value) === "date";
};

export const isPromise = (value: any): value is Promise<any> => {
  return getType(value) === "promise";
};
```
