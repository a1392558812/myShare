## defineAsyncComponent

> å®˜æ–¹å®šä¹‰ï¼šåˆ›å»ºä¸€ä¸ªåªæœ‰åœ¨éœ€è¦æ—¶æ‰ä¼šåŠ è½½çš„å¼‚æ­¥ç»„ä»¶ã€‚
>
> å¯¹äºåŸºæœ¬ç”¨æ³•ï¼Œ`defineAsyncComponent` å¯ä»¥æ¥å—ä¸€ä¸ªè¿”å› `Promise` çš„å·¥å‚å‡½æ•°ã€‚Promise çš„ `resolve` å›è°ƒåº”è¯¥åœ¨æœåŠ¡ç«¯è¿”å›ç»„ä»¶å®šä¹‰åè¢«è°ƒç”¨ã€‚ä½ ä¹Ÿå¯ä»¥è°ƒç”¨ `reject(reason)` æ¥è¡¨ç¤ºåŠ è½½å¤±è´¥
>
> å¯¹äºé«˜é˜¶ç”¨æ³•ï¼Œ`defineAsyncComponent` å¯ä»¥æ¥å—ä¸€ä¸ªå¯¹è±¡ï¼š

* ä¸€èˆ¬ç”¨æ³•

```ts
import { createApp, defineAsyncComponent } from 'vue'

createApp({
  // ...
  components: {
    AsyncComponent: defineAsyncComponent(() =>
      import('./components/AsyncComponent.vue')
    )
  }
})
```

* é«˜çº§ç”¨æ³•

```ts
import { defineAsyncComponent } from 'vue'

const AsyncComp = defineAsyncComponent({
  // å·¥å‚å‡½æ•°
  loader: () => import('./Foo.vue')
  // åŠ è½½å¼‚æ­¥ç»„ä»¶æ—¶è¦ä½¿ç”¨çš„ç»„ä»¶
  loadingComponent: LoadingComponent,
  // åŠ è½½å¤±è´¥æ—¶è¦ä½¿ç”¨çš„ç»„ä»¶
  errorComponent: ErrorComponent,
  // åœ¨æ˜¾ç¤º loadingComponent ä¹‹å‰çš„å»¶è¿Ÿ | é»˜è®¤å€¼ï¼š200ï¼ˆå•ä½ msï¼‰
  delay: 200,
  // å¦‚æœæä¾›äº† timeout ï¼Œå¹¶ä¸”åŠ è½½ç»„ä»¶çš„æ—¶é—´è¶…è¿‡äº†è®¾å®šå€¼ï¼Œå°†æ˜¾ç¤ºé”™è¯¯ç»„ä»¶
  // é»˜è®¤å€¼ï¼šInfinityï¼ˆå³æ°¸ä¸è¶…æ—¶ï¼Œå•ä½ msï¼‰
  timeout: 3000,
  // å®šä¹‰ç»„ä»¶æ˜¯å¦å¯æŒ‚èµ· | é»˜è®¤å€¼ï¼štrue
  suspensible: false,
  /**
   *
   * @param {*} error é”™è¯¯ä¿¡æ¯å¯¹è±¡
   * @param {*} retry ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºæŒ‡ç¤ºå½“ promise åŠ è½½å™¨ reject æ—¶ï¼ŒåŠ è½½å™¨æ˜¯å¦åº”è¯¥é‡è¯•
   * @param {*} fail  ä¸€ä¸ªå‡½æ•°ï¼ŒæŒ‡ç¤ºåŠ è½½ç¨‹åºç»“æŸé€€å‡º
   * @param {*} attempts å…è®¸çš„æœ€å¤§é‡è¯•æ¬¡æ•°
   */
  onError(error, retry, fail, attempts) {
    if (error.message.match(/fetch/) && attempts <= 3) {
      // è¯·æ±‚å‘ç”Ÿé”™è¯¯æ—¶é‡è¯•ï¼Œæœ€å¤šå¯å°è¯• 3 æ¬¡
      retry()
    } else {
      // æ³¨æ„ï¼Œretry/fail å°±åƒ promise çš„ resolve/reject ä¸€æ ·ï¼š
      // å¿…é¡»è°ƒç”¨å…¶ä¸­ä¸€ä¸ªæ‰èƒ½ç»§ç»­é”™è¯¯å¤„ç†ã€‚
      fail()
    }
  }
})
```

* æºğŸ´ï¼ˆå¥—ï¼ï¼ï¼ï¼ï¼‰

```ts
export function defineAsyncComponent<
  T extends Component = { new (): ComponentPublicInstance }
>(source: AsyncComponentLoader<T> | AsyncComponentOptions<T>): T {
  if (isFunction(source)) {
    source = { loader: source }
  }

  /*
	æˆ‘ä»¬é«˜çº§ç”¨æ³•æ—¶ä¼ å…¥çš„å‚æ•°
  */
  const {
    loader,
    loadingComponent,
    errorComponent,
    delay = 200,
    timeout, // undefined = never times out
    suspensible = true,
    onError: userOnError
  } = source 

  let pendingRequest: Promise<ConcreteComponent> | null = null
  let resolvedComp: ConcreteComponent | undefined

  let retries = 0
  const retry = () => { // é‡æ–°å°è¯•loadå¾—åˆ°ç»„ä»¶å†…å®¹
    retries++
    pendingRequest = null
    return load()
  }

  const load = (): Promise<ConcreteComponent> => {
    let thisRequest: Promise<ConcreteComponent>
    return (
      // å¦‚æœpendingRequest å­˜åœ¨å°±returnï¼Œå¦åˆ™å®è¡Œloader
      pendingRequest ||
      (thisRequest = pendingRequest = loader()
       .catch(err => { // æ•è·æˆ‘ä»¬çš„å¼‚æ­¥ç»„ä»¶æ˜¯å¦å‡ºé”™äº†
          err = err instanceof Error ? err : new Error(String(err))
          if (userOnError) {
            // å¤±è´¥æ•è·çš„é’©å­ï¼Œæˆ‘ä»¬å¯ä»¥è°ƒç”¨
            return new Promise((resolve, reject) => {
              const userRetry = () => resolve(retry()) // é‡è¯•åŠ è½½ç»„ä»¶
              const userFail = () => reject(err)
              userOnError(err, userRetry, userFail, retries + 1)
            })
          } else {
            throw err
          }
        })
       // æˆ‘ä»¬çš„å¼‚æ­¥ç»„ä»¶å¾ˆå¥¥åˆ©ç»™ï¼ŒåŠ è½½æˆåŠŸäº†
       .then((comp: any) => {
          // æˆ‘ä»¬ç»„ä»¶æ˜¯å¼‚æ­¥çš„ï¼Œåˆæ¬¡åŠ è½½æ˜¯'pendding'ä¸­ï¼Œå½“åŠ è½½æˆåŠŸè¿›å…¥åˆ°æ­¤è¡Œä»£ğŸ´çš„æ—¶å€™,
          // loaderæ˜¯æˆ‘ä»¬ä¼ å…¥çš„() => import('./Modal.vue')
          /*
          emmmmmå®åœ¨çœ‹ä¸æ‡‚è¿™ä¸ªåˆ¤æ–­
          1. ç¬¬ä¸€æ¬¡è¿›å…¥æ˜¯thisRequest === pendingRequestï¼Œä¸ºPromiseÂ {<pending>}
          2. ä¸¾ä¾‹å§ï¼Œæœ‰ç†è§£çš„ï¼Œ+Q1392558812æŒ‡æ­£ä¸€ä¸‹
          3. é¦–å…ˆç¬¬ä¸€æ¬¡æ‰§è¡ŒthisRequestä¸pendingRequestéƒ½ä¸ºPromiseÂ {<pending>}ï¼Œpromiseä¸ºpending
          4. é‚£å¦‚ä½•è¿›å…¥è¿™ä¸ªåˆ¤æ–­ï¼Ÿï¼š
          		1. pendingRequestä¸ºnull
          		2. loader()åŠ è½½æˆåŠŸ
          		3. thisRequest pendingRequestéƒ½æœ‰å€¼
          		æ¨æµ‹ï¼š é‚£åªèƒ½æ˜¯é‡æ–°æ‰§è¡Œload()æ‰å¯èƒ½æœ‰è¿™ç§æƒ…å†µï¼Œé‚£ä¹ˆï¼Œè¿™ä¸ªåˆ¤æ–­æˆ‘çŒœæ˜¯ä¸ºäº†å¤„ç†â€œretry()è¿™ä¸ªå‡½æ•°ç¬¬ä¸€æ¬¡æ²¡åŠ è½½æˆåŠŸåæ¥åŠ è½½æˆåŠŸäº†â€é€ æˆçš„					thisRequestä¸pendingRequestä¸åŒæ­¥é—®é¢˜
          		æµ‹è¯•demo: 
          				 let emmm = (str) => {
                            let pendingRequest = null
                            const loader = (str) => {
                              return new Promise((resolve,reject) => {
                                setTimeout(() => {
                                  if (new Date().getTime() % 2) {
                                    resolve(str)
                                  } else {
                                    reject(str)
                                  }
                                },1000)
                              })
                            }
                            const load = (str) => {
                              let thisRequest
                              return (
                                pendingRequest || (thisRequest = pendingRequest = loader(str)
                                .catch(res => {
                                  pendingRequest = null
                                  console.error('~~~~~~~~~~~')
                                  return load(str)
                                })
                                  .then(res => {
                                    if (thisRequest !== pendingRequest && pendingRequest) {
                                      debugger
                                      console.log('å¥—ï¼ï¼ï¼ï¼ï¼ç»ˆäºè¿›è¿™ä¸ªåˆ¤æ–­äº†',thisRequest, pendingRequest)
                                      return pendingRequest
                                    }
                                    console.log('res', res, pendingRequest)
                                    return res
                                  })
                                ))
                            }
                            console.log(load(str))
                            setTimeout(() => {
                              console.log('pendingRequest', pendingRequest,load('æ“ä½œèµ·æ¥'))
                            },3000)
                            return {
                              load
                            }
                          }
                          emmm('emmm').load('è€å…«ç§˜åˆ¶å°æ±‰å ¡')
                          setTimeout(() => {
                            emmm('å¤ªæäº†å•Šï¼ï¼ï¼').load('åŠ ä¸ªğŸ‹å–œæ»‹æ»‹')
                          }, 5000)
          */
          if (thisRequest !== pendingRequest && pendingRequest) {
            return pendingRequest
          }
          if (__DEV__ && !comp) {
            warn(
              `Async component loader resolved to undefined. ` +
                `If you are using retry(), make sure to return its return value.`
            )
          }
          // interop module default
          if (
            comp &&
            (comp.__esModule || comp[Symbol.toStringTag] === 'Module')
          ) {
            comp = comp.default
          }
          // å¼‚æ­¥åŠ è½½çš„å¹¶ä¸æ˜¯ä¸€ä¸ªç»„ä»¶æˆ–è€…çº¯å‡½æ•°
          if (__DEV__ && comp && !isObject(comp) && !isFunction(comp)) {
            throw new Error(`Invalid async component load result: ${comp}`)
          }
          resolvedComp = comp
          return comp 
          // è¿™é‡Œreturnäº†ï¼Œé‚£ä¹ˆå¤–å±‚å³â€œthisRequest = pendingRequest = loader()â€ä¸­çš„pendingRequestå¾—åˆ°å€¼äº†è·Ÿæ–°
        }))
    )
  }

  return defineComponent({
    __asyncLoader: load,
    name: 'AsyncComponentWrapper',
    setup() {
      const instance = currentInstance!
      // already resolved
      if (resolvedComp) {
        return () => createInnerComp(resolvedComp!, instance)
      }
      const onError = (err: Error) => {
        pendingRequest = null
        handleError(
          err,
          instance,
          ErrorCodes.ASYNC_COMPONENT_LOADER,
          !errorComponent /* do not throw in dev if user provided error component */
        )
      }

      // suspense-controlled or SSR.  suspenseä¸ssråœºæ™¯emmmmm
      if (
        (__FEATURE_SUSPENSE__ && suspensible && instance.suspense) ||
        (__NODE_JS__ && isInSSRComponentSetup)
      ) { // çˆ¶ç»„ä»¶æ˜¯ä¸€ä¸ª suspense é‚£ä¹ˆåªè¿”å›promiseç»“æœ å…¶ä½™çš„æ§åˆ¶äº¤ç»™ suspense å¤„ç†
        return load()
          .then(comp => {
            return () => createInnerComp(comp, instance)
          })
          .catch(err => {
            onError(err)
            return () =>
              errorComponent
                ? createVNode(errorComponent as ConcreteComponent, {
                    error: err
                  })
                : null
          })
      }

      const loaded = ref(false)
      const error = ref()
      const delayed = ref(!!delay)
      if (delay) {
        setTimeout(() => {
          delayed.value = false
        }, delay)
      }
      if (timeout != null) {
        setTimeout(() => { // å¤„ç†åŠ è½½è¶…æ—¶
          if (!loaded.value && !error.value) {
            const err = new Error(
              `Async component timed out after ${timeout}ms.`
            )
            onError(err)
            error.value = err
          }
        }, timeout)
      }

      load() // åŠ è½½æˆåŠŸæ”¹å˜åŠ è½½çŠ¶æ€
        .then(() => {
          loaded.value = true
        })
        .catch(err => {
          onError(err)
          error.value = err
        })
	  // resolvedCompä¸ºå¼‚æ­¥å¯¼å…¥çš„ç»„ä»¶ errorComponentä¸ºåŠ è½½å¤±è´¥çš„ç»„ä»¶  loadingComponentåŠ è½½ä¸­çš„ç»„ä»¶
      // loaded.valueåŠ è½½æˆåŠŸ   error.valueåŠ è½½å¤±è´¥
      // !delayed.valueä¸åœ¨å»¶è¿Ÿnç§’å‡ºç°åŠ è½½åŠ¨ç”»æ—¶é—´å†…ä¸”æœ‰åŠ è½½åŠ¨ç”»ç»„ä»¶
      return () => { 
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance)
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent as ConcreteComponent, {
            error: error.value
          })
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent as ConcreteComponent)
        }
      }
    }
  }) as any
}
```

