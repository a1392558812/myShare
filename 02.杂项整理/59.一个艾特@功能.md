## ‰∏Ä‰∏™ËâæÁâπ@ÂäüËÉΩ

> ÂÆòÁΩëÔºö[GitHub - zurb/tribute: ES6 Native @mentions](https://github.com/zurb/tribute)
> 
> ```js
> // ÂºÄÂßãÊü•ÊâæÁöÑÁ¨¶Âè∑ÊàñÂ≠óÁ¨¶‰∏≤
>         trigger: '@',
> 
>         // ÂºÇÊ≠•Âä†ËΩΩÊó∂Èó¥ÔºàËá™Â∑±Êñ∞Ê∑ªÁöÑÔºâ
>         searchDebounce:0,
> 
>         // @ÊèêÂà∞ÁöÑÁõÆÊ†áÂÖÉÁ¥†
>         iframe: null,
> 
>         // Âú®ÂºπÂá∫ËèúÂçï‰∏≠‰∏∫Ê¥ªÂä®È°πÊ∑ªÂä†ÁöÑÁ±ª
>         selectClass: 'highlight',
> 
>         // ËèúÂçïÂÆπÂô®class
>         containerClass: 'tribute-container',
> 
>         // ËèúÂçïÂàóË°®itemÁöÑÁ±ª
>         itemClass: '',
> 
>         // selectÊèíÂÖ•ÂõûË∞É
>         selectTemplate: function (item) {
>           return '@' + item.original.value;
>         },
> 
>         // menu‰∏≠itemÊ®°Êùø
>         menuItemTemplate: function (item) {
>           return item.string;
>         },
> 
>         // Êó†ÂåπÈÖçÊ®°ÊùøÊòæÁ§∫ËØ•Ê®°Êùø
>         // ÈªòËÆ§ÈöêËóè
>         noMatchTemplate: null,
> 
>         // ‰∏∫ËèúÂçïÊåáÂÆöÂè¶‰∏Ä‰∏™Áà∂ÂÆπÂô®
>         // ÂÆπÂô®ÂøÖÈ°ªÊòØËèúÂçïÊ≠£Á°ÆÊòæÁ§∫ÁöÑÂÆö‰ΩçÂÖÉÁ¥†ÔºåÂç≥‚Äúposition:relative`
>         // /ÈªòËÆ§ÂÆπÂô®ÊòØbody
>         menuContainer: document.body,
> 
>         // ÂØπË±°‰∏≠Ë¶ÅÊêúÁ¥¢ÁöÑÂàóÔºàÊé•ÂèóÂáΩÊï∞ÊàñÂ≠óÁ¨¶‰∏≤Ôºâ
>         /*
> ¬†¬†¬†¬†¬†¬†¬†¬†The lookup column can also be passed a function to construct a string to query against. This is useful if your payload has multiple attributes that you would like to query against but you can't modify the payload returned from the server to include a concatenated lookup column.
>             {
>               lookup: function (person, mentionText) {
>                  return person.name + person.email;
>               }
>             }
>         */
>         lookup: 'key',
> 
>         // ÈªòËÆ§ÊÉÖÂÜµ‰∏ãÂåÖÂê´Ë¶ÅÊèíÂÖ•ÂÜÖÂÆπÁöÑÂàó
>         fillAttr: 'value',
> 
>         // emmmmmmm,values
>         values: [],
> 
>         // ÂΩìÊÇ®ÁöÑÂÄºÂáΩÊï∞‰∏∫ÂºÇÊ≠•Êó∂ÔºåÂ∞ÜÊòæÁ§∫‰∏Ä‰∏™ÂèØÈÄâÁöÑÂä†ËΩΩÊ®°Êùø
>         loadingItemTemplate: null,
> 
>         // ÊåáÂÆöËß¶ÂèëÂô®Â≠óÁ¨¶‰∏≤‰πãÂâçÊòØÂê¶ÈúÄË¶ÅÁ©∫Ê†º
>         requireLeadingSpace: true,
> 
>         // ÊåáÂÆöÊòØÂê¶ÂÖÅËÆ∏Âú®@‰∏≠Èó¥‰ΩøÁî®Á©∫Ê†º
>         allowSpaces: false,
> 
>         // ÂèØÈÄâÂú∞‰∏∫ÊõøÊç¢ÊñáÊú¨ÊåáÂÆöËá™ÂÆö‰πâÂêéÁºÄ
>         // ÔºàÂ¶ÇÊûúÊú™ÂÆö‰πâÔºåÂàôÈªòËÆ§‰∏∫Á©∫ÁôΩÔºâ
>         replaceTextSuffix: '\n',
> 
>         // Á°ÆÂÆömenu‰ΩïÊó∂Ë¢´ÂÆö‰∏∫. ËÆæ‰∏∫flase‰∏î‰∏émenuContainerÁªìÂêà‰ΩøÁî®ÂàõÂª∫Ë°åÂÜÖmenu
>         // (defaults to true)
>         positionMenu: true,
> 
>         // Êåâ‰∏ãÁ©∫Ê†ºÈîÆÊó∂ÔºåÈÄâÊã©ÂΩìÂâçÂåπÈÖçÈ°π
>         spaceSelectsMatch: false,
> 
>         // turn tribute into an autocompleteËá™Âä®Â°´ÂÖÖ
>         autocompleteMode: false,
> 
>         // Customize the elements used to wrap matched strings within the results list
>         // Âú®ÁªìÊûúÂàóË°®‰∏≠Ëá™ÂÆö‰πâÁî®‰∫éÂåÖË£ÖÂåπÈÖçÂ≠óÁ¨¶‰∏≤ÁöÑÂÖÉÁ¥†
>         // defaults to <span></span> if undefined
>         searchOpts: {
>           pre: '<span>',
>           post: '</span>',
>           skip: false // true will skip local search, useful if doing server-side search
>         },
> 
>         // Limits the number of items in the menu
>         menuItemLimit: 25,
> 
>         // specify the minimum number of characters that must be typed before menu appears
>         menuShowMinLength: 0
> ```

index.vue

```vue
<template>
  <div class="width100 overflow-y-auto tribute-main">
    <tribute class="tribute"/>
    <asyncTribute  class="tribute"/>
  </div>
</template>

<script>
import asyncTribute from './components/async-tribute/index.vue'
import tribute from './components/tribute/index.vue'
export default {
  components: {
    asyncTribute,
    tribute
  },
  setup () {

  }
}
</script>

<style scoped lang="scss">
.tribute-main{
  height: 100vh;
  .tribute{
    padding: 20px 50px;
    border: 1px solid #ff0000;
  }
  .pre{
    max-height: 500px;
    max-width: 800px;
    border: 1px solid #ff0000;
    font-size: 16px;
  }
}

</style>
```

tribute.vue

```vue
<template>
  <div>
    <div v-html="'<ËßÜÂõæ‰∏ç‰ºö‰∏ªÂä®Êõ¥Êñ∞>'"></div>
    <div>ÊµãËØïÊï∞ÊçÆÔºöÔºà@test1ÔºâÔºà@test2ÔºâÔºà@test3ÔºâÔºà@test4ÔºâÔºà@t****Ôºâ</div>
    <div class="flex">
      <div>
        <vue-tributeVue :options="tributeOption" @initTribute="initTribute">
          <div
            ref="vueTributeVue"
            class="line-height-1 tribute-input"
            type="text"
            @tribute-replaced="(e) => customTribute('tribute-replaced',e)"
            @tribute-active-true="(e) => customTribute('tribute-active-true',e)"
            @tribute-active-false="(e) => customTribute('tribute-active-false',e)"
            @tribute-no-match="(e) => customTribute('tribute-no-match',e)"/>
        </vue-tributeVue>
        <div class="overflow-y-auto tribute-innerHtml" v-show="vueTributeVueInnerHtml">
          <p style="color:cadetblue">ÊâÄÈÄâÂèñÁöÑÂÄºËµãÂÄº‰∫éspanÊ†áÁ≠æÁöÑ data-*Â±ûÊÄß‰∏äÔºåËß£Êûêdata-*ÊãºÊé•Â≠óÁ¨¶‰∏≤Âç≥ÂèØ</p>
          <p>{{ vueTributeVueInnerHtml }}</p>
        </div>
      </div>
      <div>
        <button class="tribute-btn" @click="handleClick">‰∏ªÂä®Ëß¶Âèë@ËèúÂçï</button>
        <button class="tribute-btn" @click="handleAddClick1">2500msÂêéÊ∑ªÂä†Êñ∞Êï∞ÊçÆÊñπÂºè</button>
        <button class="tribute-btn" @click="handleAddClick2">ÊòæÁ§∫ËßÜÂõæÂÜÖÂÆπ</button>
      </div>
    </div>
    <toast ref="toastRefDom"></toast>
  </div>
</template>

<script>
import vueTributeVue from '../vue-tribute.vue'
import toast from '@/components/common/toast/index.vue'
import debounce from '@/common/util/debounce'
import { ref } from 'vue'
import { selectTemplate, noMatchTemplate, menuItemTemplate } from '../tribute-utill'
export default {
  components: {
    vueTributeVue,
    toast
  },
  setup () {
    const vueTributeVue = ref(null)
    let tribute // new TributeÂÆû‰æã
    const toastRefDom = ref(null)
    const vueTributeVueInnerHtml = ref('')
    let newIndex = 0
    const newListCreate = () => {
      newIndex++
      const addList = []
      for (let i = newIndex; i < newIndex + 3; i++) {
        addList.push({
          key: `Êñ∞Êï∞ÊçÆ${i}`,
          value: `Êñ∞Êï∞ÊçÆ${i}-id`,
          phone: 'xxx',
          avatar_url: require(`@/static/image/mention-function/0${i % 4 + 1}.png`)
        })
      }
      newIndex = newIndex + 2
      return addList
    }
    return {
      toastRefDom,
      vueTributeVue,
      vueTributeVueInnerHtml,
      handleClick: () => {
        tribute.showMenuForCollection(vueTributeVue.value)
      },
      customTribute: (type, e) => {
        toastRefDom.value.addToast({
          content: `‰∫ã‰ª∂${type},ÂõûË∞ÉÂèÇ${e}`
        })
      },
      handleAddClick1: () => {
        debounce(() => {
          console.log('???')
          tribute.append(0, newListCreate())
        }, 2500, false)
      },
      handleAddClick2: () => {
        console.log('tributeÂÆû‰æã', tribute)
        vueTributeVueInnerHtml.value = vueTributeVue.value.innerHTML
      },
      initTribute: (result) => { tribute = result },
      tributeOption: {
        values: [
          { key: 'test1', value: 'test1-id', phone: '001', avatar_url: require('@/static/image/mention-function/01.png') },
          { key: 'test2', value: 'test2-id', phone: '002', avatar_url: require('@/static/image/mention-function/02.png') },
          { key: 'test3', value: 'test3-id', phone: '003', avatar_url: require('@/static/image/mention-function/03.png') },
          { key: 'test4', value: 'test4-id', phone: '004', avatar_url: require('@/static/image/mention-function/04.png') }
        ],
        itemClass: 'tribute-list-item',
        selectTemplate,
        noMatchTemplate,
        menuItemTemplate
      }
    }
  }
}
</script>

<style lang="scss" scoped>
.tribute-input{
  width: 500px;
  font-size: 16px;
  border: 1px solid #000;
  border-radius: 5px;
  padding: 0.5em;
}
.tribute-innerHtml{
  width: 500px;
  max-height: 500px;
  word-break: break-all;
}
.tribute-btn{
  margin: 0 0 1em 1em;
  padding: 0.5em;
  display: block;
}
</style>
```

async-tribute.vue

```vue
<template>
  <div >
    <div v-html="'<ËØ∑Ê±ÇÊï∞ÊçÆ‰∏∫Ê®°ÊãüÁîüÊàêÁöÑ>'"></div>
    <div class="flex">
      <vue-tributeVue :options="tributeOption" >
        <div
          class="line-height-1 tribute-input"
          type="text"/>
      </vue-tributeVue>
      <div>
        <div class="tribute-btn">
          <span>ÂºÇÊ≠•Âä†ËΩΩ</span>
          <span v-if="searchText">,Âä†ËΩΩtextÂÜÖÂÆπ‰∏∫:{{ searchText }}</span>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import vueTributeVue from '../vue-tribute.vue'
import { selectTemplate, noMatchTemplate, menuItemTemplate } from '../tribute-utill'
import { ref } from 'vue'
export default {
  components: {
    vueTributeVue
  },
  setup () {
    let newIndex = 0
    let ifLoading = false // ÊòØÂê¶Âä†ËΩΩÊï∞ÊçÆ‰∏≠
    const searchText = ref('')
    const loadingTemplate = () => '<div class="tribute-list-item-inner">Âä†ËΩΩ‰∏≠...</div>'
    const beforeLoadingTemplate = () => null
    const featchData = (text) => {
      return new Promise((resolve) => {
        const loadingIndex = parseInt(Math.random() * 9 + 2)
        // if (loadingIndex % 2) {
        //   return [{ noData: true, key: '', value: '' }]
        // }
        const addList = []
        for (let i = 0; i < loadingIndex + 3; i++) {
          addList.push({
            key: `üêÆ${text}-${i}`,
            value: `üêÆ${text}-${i}-id`,
            phone: `üêÆx${i}`,
            avatar_url: require(`@/static/image/mention-function/0${(loadingIndex + i) % 4 + 1}.png`)
          })
        }
        newIndex = newIndex + 2
        setTimeout(() => {
          resolve(addList)
        }, 2000)
      })
    }
    return {
      searchText,
      tributeOption: {
        itemClass: 'tribute-list-item',
        searchDebounce: 500,
        noMatchTemplate: () => {
          if (ifLoading) {
            return loadingTemplate()
          }
          return noMatchTemplate()
        },
        selectTemplate: (item) => {
          if (item.original.loading) {
            return ''
          }
          if (item.original.noData) {
            return noMatchTemplate()
          }
          if (item.original.beforeLoading) {
            return ''
          }
          return selectTemplate(item)
        },
        menuItemTemplate: (item) => {
          if (item.original.loading) {
            return loadingTemplate()
          }
          if (item.original.noData) {
            return noMatchTemplate()
          }
          if (item.original.beforeLoading) {
            return beforeLoadingTemplate()
          }
          return menuItemTemplate(item)
        },
        values: (text, callback) => {
          if (!text) {
            return callback((() => [
              { beforeLoading: true, key: '', value: '' }
            ])())
          }
          if (ifLoading) return
          ifLoading = true
          searchText.value = text
          callback((() => [
            { loading: true, key: text, value: '' }
          ])())
          featchData(text).then(res => {
            ifLoading = false
            callback(res)
          })
        }
      }
    }
  }
}
</script>

<style lang="scss" scoped>

.tribute-input{
  width: 500px;
  font-size: 16px;
  border: 1px solid #000;
  border-radius: 5px;
  padding: 0.5em;
}
.tribute-btn{
  margin: 0 0 1em 1em;
  font-size: 16px;
  padding: 0.5em;
  display: block;
}
</style>
```

vue-tribute.vue(ËøôÈáåÂ§ß‰Ω¨Â∞ÅË£ÖÁöÑvueÊ®°ÊùøÔºåÊåáË∑Øhttps://github.com/syropian/vue-tribute)

```vue
<script>
import {
  defineComponent, watch, onMounted, onBeforeUnmount, nextTick, ref, unref
} from 'vue'
// import Tribute from 'tributejs/src/index'
import Tribute from '@/static/tribute/index'
export default defineComponent({
  name: 'VueTribute',
  props: {
    options: {
      type: Object,
      default: () => ({
        collection: [
          { values: [] }
        ]
      }),
      required: true
    }
  },
  setup (props, context) {
    if (typeof Tribute === 'undefined') {
      throw new Error('[vue-tribute] cannot locate tributejs.')
    }

    const root = ref(null)
    const el = ref(null)

    const attachTribute = (el, options = props.options) => {
      if (!el.value) return

      const tribute = new Tribute(unref(options))
      context.emit('initTribute', tribute)
      tribute.attach(el.value)
      el.value.tributeInstance = tribute
    }

    onMounted(() => {
      el.value = root.value ? $(root.value).children()[0] : null
      if (!el.value) {
        throw new Error('[vue-tribute] ÂåÖË£πÁªÑ‰ª∂‰∏ãÊó†ÊèíÊßΩÂÜÖÂÆπÁªÑ‰ª∂')
      }

      attachTribute(el)

      el.value.addEventListener('tribute-replaced', e => {
        e.target?.dispatchEvent(new Event('input', { bubbles: true }))
      })
    })

    const detachTribute = (el) => {
      if (!el.value?.tributeInstance) return

      el.value.tributeInstance.detach(el.value)
      el.value.tributeInstance = undefined
      delete el.value.dataset.tribute
    }

    onBeforeUnmount(() => {
      detachTribute(el)
    })

    watch(
      () => props.options,
      async newOptions => {
        if (el.value?.tributeInstance) {
          await nextTick()
          detachTribute(el)
          await nextTick()
          attachTribute(el, { ...newOptions })
        }
      },
      { deep: true }
    )

    return () => (
      <div class="v-tribute" ref={root}>
        {[context.slots.default ? context.slots.default()[0] : null].filter(Boolean)}
      </div>
    )
  }
})

</script>
```

tribute-utill.js

```js
export const selectTemplate = (item) => {
  let dataStr = ''
  Object.keys(item.original).forEach(key => {
    dataStr += `data-${key}=${item.original[key]} `
  })
  return `<span contenteditable="false" ${dataStr}>
            <a href="https://github.com/a1392558812/myShare" title="AwenÁöÑgithub" target="_blank">${item.original.value}</a>
          </span>`
}
export const noMatchTemplate = () => '<div class="tribute-list-item-inner">ÊöÇÊó†ÂåπÈÖçÊï∞ÊçÆ‚î≠‚îÆÔπè‚î≠‚îÆ</div>'
export const menuItemTemplate = (item) => `<div class='flex tribute-list-item-inner'>
<img src="${item.original.avatar_url}">
<div class="tribute-list-item-info">
  <p>ÂßìÂêçÔºö${item.string}</p>
  <p>ÊâãÊú∫Âè∑Ôºö${item.original.phone}</p>
</div>
</div>`
```

Ê∫êÁ†ÅÊîπÂä®(Â¢ûÂä†searchDebounceÂèÇÊï∞ÔºåÁî®‰∫éÈò≤ÊäñÂ§ÑÁêÜÂºÇÊ≠•Âä†ËΩΩÁªìÊûú)

tribute.js

```js
import "tributejs/src/utils";
import TributeEvents from "tributejs/src/TributeEvents";
import TributeMenuEvents from "tributejs/src/TributeMenuEvents";
import TributeRange from "tributejs/src/TributeRange";
import TributeSearch from "tributejs/src/TributeSearch";
import debounce from '@/common/util/debounce'

class Tribute {
  constructor({
    values = null,
    iframe = null,
    selectClass = "highlight",
    containerClass = "tribute-container",
    itemClass = "",
    trigger = "@",
    autocompleteMode = false,
    selectTemplate = null,
    menuItemTemplate = null,
    searchDebounce = 0,
    lookup = "key",
    fillAttr = "value",
    collection = null,
    menuContainer = null,
    noMatchTemplate = null,
    requireLeadingSpace = true,
    allowSpaces = false,
    replaceTextSuffix = null,
    positionMenu = true,
    spaceSelectsMatch = false,
    searchOpts = {},
    menuItemLimit = null,
    menuShowMinLength = 0
  }) {
    this.autocompleteMode = autocompleteMode;
    this.menuSelected = 0;
    this.searchDebounce = searchDebounce
    this.current = {};
    this.inputEvent = false;
    this.isActive = false;
    this.menuContainer = menuContainer;
    this.allowSpaces = allowSpaces;
    this.replaceTextSuffix = replaceTextSuffix;
    this.positionMenu = positionMenu;
    this.hasTrailingSpace = false;
    this.spaceSelectsMatch = spaceSelectsMatch;

    if (this.autocompleteMode) {
      trigger = "";
      allowSpaces = false;
    }

    if (values) {
      this.collection = [
        {
          // symbol that starts the lookup
          trigger: trigger,

          // is it wrapped in an iframe
          iframe: iframe,

          // class applied to selected item
          selectClass: selectClass,

          // class applied to the Container
          containerClass: containerClass,

          // class applied to each item
          itemClass: itemClass,

          // function called on select that retuns the content to insert
          selectTemplate: (
            selectTemplate || Tribute.defaultSelectTemplate
          ).bind(this),

          // function called that returns content for an item
          menuItemTemplate: (
            menuItemTemplate || Tribute.defaultMenuItemTemplate
          ).bind(this),

          // function called when menu is empty, disables hiding of menu.
          noMatchTemplate: (t => {
            if (typeof t === "string") {
              if (t.trim() === "") return null;
              return t;
            }
            if (typeof t === "function") {
              return t.bind(this);
            }

            return (
              noMatchTemplate ||
              function() {
                return "<li>No Match Found!</li>";
              }.bind(this)
            );
          })(noMatchTemplate),

          // column to search against in the object
          lookup: lookup,

          // column that contains the content to insert by default
          fillAttr: fillAttr,

          // array of objects or a function returning an array of objects
          values: values,

          requireLeadingSpace: requireLeadingSpace,

          searchOpts: searchOpts,

          menuItemLimit: menuItemLimit,

          menuShowMinLength: menuShowMinLength
        }
      ];
    } else if (collection) {
      if (this.autocompleteMode)
        console.warn(
          "Tribute in autocomplete mode does not work for collections"
        );
      this.collection = collection.map(item => {
        return {
          trigger: item.trigger || trigger,
          iframe: item.iframe || iframe,
          selectClass: item.selectClass || selectClass,
          containerClass: item.containerClass || containerClass,
          itemClass: item.itemClass || itemClass,
          selectTemplate: (
            item.selectTemplate || Tribute.defaultSelectTemplate
          ).bind(this),
          menuItemTemplate: (
            item.menuItemTemplate || Tribute.defaultMenuItemTemplate
          ).bind(this),
          // function called when menu is empty, disables hiding of menu.
          noMatchTemplate: (t => {
            if (typeof t === "string") {
              if (t.trim() === "") return null;
              return t;
            }
            if (typeof t === "function") {
              return t.bind(this);
            }

            return (
              noMatchTemplate ||
              function() {
                return "<li>No Match Found!</li>";
              }.bind(this)
            );
          })(noMatchTemplate),
          lookup: item.lookup || lookup,
          fillAttr: item.fillAttr || fillAttr,
          values: item.values,
          requireLeadingSpace: item.requireLeadingSpace,
          searchOpts: item.searchOpts || searchOpts,
          menuItemLimit: item.menuItemLimit || menuItemLimit,
          menuShowMinLength: item.menuShowMinLength || menuShowMinLength
        };
      });
    } else {
      throw new Error("[Tribute] No collection specified.");
    }

    new TributeRange(this);
    new TributeEvents(this);
    new TributeMenuEvents(this);
    new TributeSearch(this);
  }

  get isActive() {
    return this._isActive;
  }

  set isActive(val) {
    if (this._isActive != val) {
      this._isActive = val;
      if (this.current.element) {
        let noMatchEvent = new CustomEvent(`tribute-active-${val}`);
        this.current.element.dispatchEvent(noMatchEvent);
      }
    }
  }

  static defaultSelectTemplate(item) {
    if (typeof item === "undefined")
      return `${this.current.collection.trigger}${this.current.mentionText}`;
    if (this.range.isContentEditable(this.current.element)) {
      return (
        '<span class="tribute-mention">' +
        (this.current.collection.trigger +
          item.original[this.current.collection.fillAttr]) +
        "</span>"
      );
    }

    return (
      this.current.collection.trigger +
      item.original[this.current.collection.fillAttr]
    );
  }

  static defaultMenuItemTemplate(matchItem) {
    return matchItem.string;
  }

  static inputTypes() {
    return ["TEXTAREA", "INPUT"];
  }

  triggers() {
    return this.collection.map(config => {
      return config.trigger;
    });
  }

  attach(el) {
    if (!el) {
      throw new Error("[Tribute] Must pass in a DOM node or NodeList.");
    }

    // Check if it is a jQuery collection
    if (typeof jQuery !== "undefined" && el instanceof jQuery) {
      el = el.get();
    }

    // Is el an Array/Array-like object?
    if (
      el.constructor === NodeList ||
      el.constructor === HTMLCollection ||
      el.constructor === Array
    ) {
      let length = el.length;
      for (var i = 0; i < length; ++i) {
        this._attach(el[i]);
      }
    } else {
      this._attach(el);
    }
  }

  _attach(el) {
    if (el.hasAttribute("data-tribute")) {
      console.warn("Tribute was already bound to " + el.nodeName);
    }

    this.ensureEditable(el);
    this.events.bind(el);
    el.setAttribute("data-tribute", true);
  }

  ensureEditable(element) {
    if (Tribute.inputTypes().indexOf(element.nodeName) === -1) {
      if (element.contentEditable) {
        element.contentEditable = true;
      } else {
        throw new Error("[Tribute] Cannot bind to " + element.nodeName);
      }
    }
  }

  createMenu(containerClass) {
    let wrapper = this.range.getDocument().createElement("div"),
      ul = this.range.getDocument().createElement("ul");
    wrapper.className = containerClass;
    wrapper.appendChild(ul);

    if (this.menuContainer) {
      return this.menuContainer.appendChild(wrapper);
    }

    return this.range.getDocument().body.appendChild(wrapper);
  }

  showMenuFor(element, scrollTo) {
    // Only proceed if menu isn't already shown for the current element & mentionText
    if (
      this.isActive &&
      this.current.element === element &&
      this.current.mentionText === this.currentMentionTextSnapshot
    ) {
      return;
    }
    this.currentMentionTextSnapshot = this.current.mentionText;

    // create the menu if it doesn't exist.
    if (!this.menu) {
      this.menu = this.createMenu(this.current.collection.containerClass);
      element.tributeMenu = this.menu;
      this.menuEvents.bind(this.menu);
    }

    this.isActive = true;
    this.menuSelected = 0;

    if (!this.current.mentionText) {
      this.current.mentionText = "";
    }

    const processValues = values => {
      // Tribute may not be active any more by the time the value callback returns
      if (!this.isActive) {
        return;
      }

      let items = this.search.filter(this.current.mentionText, values, {
        pre: this.current.collection.searchOpts.pre || "<span>",
        post: this.current.collection.searchOpts.post || "</span>",
        skip: this.current.collection.searchOpts.skip,
        extract: el => {
          if (typeof this.current.collection.lookup === "string") {
            return el[this.current.collection.lookup];
          } else if (typeof this.current.collection.lookup === "function") {
            return this.current.collection.lookup(el, this.current.mentionText);
          } else {
            throw new Error(
              "Invalid lookup attribute, lookup must be string or function."
            );
          }
        }
      });

      if (this.current.collection.menuItemLimit) {
        items = items.slice(0, this.current.collection.menuItemLimit);
      }

      this.current.filteredItems = items;

      let ul = this.menu.querySelector("ul");

      this.range.positionMenuAtCaret(scrollTo);

      if (!items.length) {
        let noMatchEvent = new CustomEvent("tribute-no-match", {
          detail: this.menu
        });
        this.current.element.dispatchEvent(noMatchEvent);
        if (
          (typeof this.current.collection.noMatchTemplate === "function" &&
            !this.current.collection.noMatchTemplate()) ||
          !this.current.collection.noMatchTemplate
        ) {
          this.hideMenu();
        } else {
          typeof this.current.collection.noMatchTemplate === "function"
            ? (ul.innerHTML = this.current.collection.noMatchTemplate())
            : (ul.innerHTML = this.current.collection.noMatchTemplate);
        }

        return;
      }

      ul.innerHTML = "";
      let fragment = this.range.getDocument().createDocumentFragment();

      items.forEach((item, index) => {
        let li = this.range.getDocument().createElement("li");
        li.setAttribute("data-index", index);
        li.className = this.current.collection.itemClass;
        li.addEventListener("mousemove", e => {
          let [li, index] = this._findLiTarget(e.target);
          if (e.movementY !== 0) {
            this.events.setActiveLi(index);
          }
        });
        if (this.menuSelected === index) {
          li.classList.add(this.current.collection.selectClass);
        }
        li.innerHTML = this.current.collection.menuItemTemplate(item);
        fragment.appendChild(li);
      });
      ul.appendChild(fragment);
    };

    if (typeof this.current.collection.values === "function") {

      if (this.searchDebounce) {
        debounce(() =>{
          console.log('searchDebounce', this.searchDebounce)
          this.current.collection.values(this.current.mentionText, processValues);
        },this.searchDebounce)
      } else {
        this.current.collection.values(this.current.mentionText, processValues);
      }
    } else {
      processValues(this.current.collection.values);
    }
  }

  _findLiTarget(el) {
    if (!el) return [];
    const index = el.getAttribute("data-index");
    return !index ? this._findLiTarget(el.parentNode) : [el, index];
  }

  showMenuForCollection(element, collectionIndex) {
    if (element !== document.activeElement) {
      this.placeCaretAtEnd(element);
    }

    this.current.collection = this.collection[collectionIndex || 0];
    this.current.externalTrigger = true;
    this.current.element = element;

    if (element.isContentEditable)
      this.insertTextAtCursor(this.current.collection.trigger);
    else this.insertAtCaret(element, this.current.collection.trigger);

    this.showMenuFor(element);
  }

  // TODO: make sure this works for inputs/textareas
  placeCaretAtEnd(el) {
    el.focus();
    if (
      typeof window.getSelection != "undefined" &&
      typeof document.createRange != "undefined"
    ) {
      var range = document.createRange();
      range.selectNodeContents(el);
      range.collapse(false);
      var sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
    } else if (typeof document.body.createTextRange != "undefined") {
      var textRange = document.body.createTextRange();
      textRange.moveToElementText(el);
      textRange.collapse(false);
      textRange.select();
    }
  }

  // for contenteditable
  insertTextAtCursor(text) {
    var sel, range, html;
    sel = window.getSelection();
    range = sel.getRangeAt(0);
    range.deleteContents();
    var textNode = document.createTextNode(text);
    range.insertNode(textNode);
    range.selectNodeContents(textNode);
    range.collapse(false);
    sel.removeAllRanges();
    sel.addRange(range);
  }

  // for regular inputs
  insertAtCaret(textarea, text) {
    var scrollPos = textarea.scrollTop;
    var caretPos = textarea.selectionStart;

    var front = textarea.value.substring(0, caretPos);
    var back = textarea.value.substring(
      textarea.selectionEnd,
      textarea.value.length
    );
    textarea.value = front + text + back;
    caretPos = caretPos + text.length;
    textarea.selectionStart = caretPos;
    textarea.selectionEnd = caretPos;
    textarea.focus();
    textarea.scrollTop = scrollPos;
  }

  hideMenu() {
    if (this.menu) {
      this.menu.style.cssText = "display: none;";
      this.isActive = false;
      this.menuSelected = 0;
      this.current = {};
    }
  }

  selectItemAtIndex(index, originalEvent) {
    index = parseInt(index);
    if (typeof index !== "number" || isNaN(index)) return;
    let item = this.current.filteredItems[index];
    let content = this.current.collection.selectTemplate(item);
    if (content !== null) this.replaceText(content, originalEvent, item);
  }

  replaceText(content, originalEvent, item) {
    this.range.replaceTriggerText(content, true, true, originalEvent, item);
  }

  _append(collection, newValues, replace) {
    if (typeof collection.values === "function") {
      throw new Error("Unable to append to values, as it is a function.");
    } else if (!replace) {
      collection.values = collection.values.concat(newValues);
    } else {
      collection.values = newValues;
    }
  }

  append(collectionIndex, newValues, replace) {
    let index = parseInt(collectionIndex);
    if (typeof index !== "number")
      throw new Error("please provide an index for the collection to update.");

    let collection = this.collection[index];

    this._append(collection, newValues, replace);
  }

  appendCurrent(newValues, replace) {
    if (this.isActive) {
      this._append(this.current.collection, newValues, replace);
    } else {
      throw new Error(
        "No active state. Please use append instead and pass an index."
      );
    }
  }

  detach(el) {
    if (!el) {
      throw new Error("[Tribute] Must pass in a DOM node or NodeList.");
    }

    // Check if it is a jQuery collection
    if (typeof jQuery !== "undefined" && el instanceof jQuery) {
      el = el.get();
    }

    // Is el an Array/Array-like object?
    if (
      el.constructor === NodeList ||
      el.constructor === HTMLCollection ||
      el.constructor === Array
    ) {
      let length = el.length;
      for (var i = 0; i < length; ++i) {
        this._detach(el[i]);
      }
    } else {
      this._detach(el);
    }
  }

  _detach(el) {
    this.events.unbind(el);
    if (el.tributeMenu) {
      this.menuEvents.unbind(el.tributeMenu);
    }

    setTimeout(() => {
      el.removeAttribute("data-tribute");
      this.isActive = false;
      if (el.tributeMenu) {
        el.tributeMenu.remove();
      }
    });
  }
}

export default Tribute;
```

tribute/index.js

```js
/**
 * Tribute.js
 * Native ES6 JavaScript @mention Plugin
 **/
import 'tributejs/src/tribute.scss'
import './index.scss'
import Tribute from './tribute'
export default Tribute
```

index.scss

```scss
.tribute-list-item{
  .tribute-list-item-inner{
    padding: 5px;
    img{
      width: 33px;
      height: 36px;
    }
    .tribute-list-item-info{
      margin-left: 10px;
      p{
        color: #000;
        font-weight: bolder;
      }
    }
  }
}
.tribute-container li{
  padding: 0;
}
```
