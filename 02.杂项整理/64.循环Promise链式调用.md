# 64.循环 Promise 链式调用.md

正常的 promise 链式调用

```js
const asyncOp1 = () => {
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log("操作1完成");
      resolve("结果1");
    }, 1000);
  });
};

const asyncOp2 = (prevResult) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log("操作2完成（基于上一步：" + prevResult + "）");
      resolve("结果2");
    }, 1000);
  });
};

const asyncOp3 = (prevResult) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log("操作3完成（基于上一步：" + prevResult + "）");
      resolve("最终结果");
    }, 1000);
  });
};

// 链式调用：按顺序执行3个异步操作
asyncOp1()
  .then((result) => {
    return asyncOp2(result);
  })
  .then((result) => {
    return result + result;
  })
  .then((result) => {
    console.log("result Promise.resolve：", result);
    return Promise.resolve(result);
  })
  .then((result) => {
    return asyncOp3(result);
  })
  .then((result) => {
    console.log("result new Promise 之前", result);
    return new Promise((resolve) => {
      console.log("result new Promise 之后", result);
      return resolve(result);
    });
  })
  .then((finalResult) => {
    console.log("所有操作完成，最终结果：", finalResult);
  })
  .catch((error) => {
    console.error("操作出错：", error);
  });
```

> 假设有一个数组`const list = [] // 里面全是Promise`，现在需要按顺序依次在上一个执行完后`.then`执行下一个，我们不关心链式调用过程，只关心最后的链式调用何时结束

```js
/**
 * promiseSetTimeout
 * @param {Array} promiseList 任务队列
 * @param {Number} loopCount 循环次数 -1表示无限循环
 * @returns {Object} {cancel, promise}
 *
 */
const promiseSetTimeout = (promiseList = [], loopCount = 1) => {
  if (!promiseList.length) {
    throw new Error("params error");
  }
  let signal = false;

  const promiseFun = (currentIndex = 0) => {
    let index = currentIndex;
    let length = promiseList.length;
    return new Promise((resolve, reject) => {
      promiseList[index]()
        .then(() => {
          if (signal) return resolve("cancel");

          index = index + 1;
          if (loopCount === -1) {
            index = index % length;
          } else {
            length = length * loopCount;
          }

          if (index >= length) {
            return resolve("finished");
          } else {
            return resolve(promiseFun(index));
          }
        })
        .catch((error) => {
          console.log("Error:", error);
          return reject(error);
        });
    });
  };

  const cancel = () => {
    console.log("controller.abort");
    signal = true;
  };

  return {
    cancel,
    promise: promiseFun(),
  };
};

const setTimeoutPromise = (flag, ms) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log("Timeout after", ms, "ms", flag);
      resolve();
    }, ms);
  });
};

const { cancel, promise } = promiseSetTimeout(
  [
    () => setTimeoutPromise("计时器1", 100),
    () => setTimeoutPromise("计时器2", 200),
    () => setTimeoutPromise("计时器3", 300),
    () => setTimeoutPromise("计时器4", 400),
    () => setTimeoutPromise("计时器5", 500),
    () => setTimeoutPromise("计时器6", 600),
  ],
  -1
);

promise.then((result) => {
  console.log("Promise result:", result);
});
setTimeout(() => {
  cancel();
}, 1000);
```
