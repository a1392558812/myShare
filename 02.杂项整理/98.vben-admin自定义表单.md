## vben-adminè‡ªå®šä¹‰è¡¨å•


// ä¸ªäººæ¨èé˜…è¯»æºç ï¼Œè¿™é‡Œåªæ˜¯æ‘˜æŠ„éƒ¨åˆ†éš¾ç‚¹æ›´å¤š src/components/Form/src




```html
<template>
  <PageWrapper title="è‡ªå®šä¹‰ç»„ä»¶ç¤ºä¾‹">
    <CollapseContainer title="è‡ªå®šä¹‰è¡¨å•">
      <BasicForm @register="register" @submit="handleSubmit">
        <template #f3="{ model, field }">
          <div>
            <a-input v-model:value="model[field]" placeholder="è‡ªå®šä¹‰slot" />
          </div>
        </template>
      </BasicForm>
    </CollapseContainer>
  </PageWrapper>
</template>
<script lang="ts">
  import { defineComponent, h } from 'vue';
  import { BasicForm, FormSchema, useForm } from '/@/components/Form/index';
  import { CollapseContainer } from '/@/components/Container/index';
  import { useMessage } from '/@/hooks/web/useMessage';
  import { Input } from 'ant-design-vue';
  import { PageWrapper } from '/@/components/Page';

  const schemas: FormSchema[] = [
    {
      field: 'field1',
      component: 'Input',
      label: 'renderæ–¹å¼',
      colProps: {
        span: 8,
      },
      rules: [{ required: true }],
      render: ({ model, field }) => {
        return h(Input, {
          placeholder: 'è¯·è¾“å…¥',
          value: model[field],
          onChange: (e: ChangeEvent) => {
            model[field] = e.target.value;
          },
        });
      },
    },
    {
      field: 'field2',
      component: 'Input',
      label: 'renderç»„ä»¶slot',
      colProps: {
        span: 8,
      },
      rules: [{ required: true }],
      renderComponentContent: () => {
        return {
          suffix: () => 'suffix',
        };
      },
    },
    {
      field: 'field3',
      component: 'Input',
      label: 'è‡ªå®šä¹‰Slot',
      slot: 'f3',
      colProps: {
        span: 8,
      },
      rules: [{ required: true }],
    },
  ];
  export default defineComponent({
    components: { BasicForm, CollapseContainer, PageWrapper, [Input.name]: Input },
    setup() {
      const { createMessage } = useMessage();
      const [register, { setProps }] = useForm({
        labelWidth: 120,
        schemas,
        actionColOptions: {
          span: 24,
        },
      });
      return {
        register,
        schemas,
        handleSubmit: (values: any) => {
          createMessage.success('click search,values:' + JSON.stringify(values));
        },
        setProps,
      };
    },
  });
</script>

```

åœ¨useForm()ä¸­ï¼Œé…ç½®äº†é»˜è®¤å­—æ®µå’Œrenderæ–¹æ³•`schemas`
çœ‹useFormä¸­çš„é…ç½®

```typescript
import type { FormProps, FormActionType, UseFormReturnType, FormSchema } from '../types/form';
import type { NamePath } from 'ant-design-vue/lib/form/interface';
import type { DynamicProps } from '/#/utils';
import { ref, onUnmounted, unref, nextTick, watch } from 'vue';
import { isProdMode } from '/@/utils/env';
import { error } from '/@/utils/log';
import { getDynamicProps } from '/@/utils';

export declare type ValidateFields = (nameList?: NamePath[]) => Promise<Recordable>;

type Props = Partial<DynamicProps<FormProps>>;

export function useForm(props?: Props): UseFormReturnType {
  const formRef = ref<Nullable<FormActionType>>(null);
  const loadedRef = ref<Nullable<boolean>>(false);

  // è·å–å½“å‰$ref form
  async function getForm() {
    const form = unref(formRef);
    if (!form) {
      error(
        'The form instance has not been obtained, please make sure that the form has been rendered when performing the form operation!',
      );
    }
    await nextTick();
    return form as FormActionType;
  }


  function register(instance: FormActionType) {
    console.log('instance', instance);
    isProdMode() &&
      onUnmounted(() => {
        formRef.value = null;
        loadedRef.value = null;
      });
    if (unref(loadedRef) && isProdMode() && instance === unref(formRef)) return;

    formRef.value = instance;
    loadedRef.value = true;

    watch(
      () => props,
      () => {
        /**
         * 
         * // dynamic use hook props
            export function getDynamicProps<T extends Record<string, unknown>, U>(props: T): Partial<U> {
              const ret: Recordable = {};

              Object.keys(props).map((key) => {
                ret[key] = unref((props as Recordable)[key]);
              });

              return ret as Partial<U>;
            }
         */
        props && (() => {
            console.log('props', props);
            // è§£é™¤å“åº”å¼
            const result = getDynamicProps(props);
            console.log('result', result);
            // ä¸ºformå®ä¾‹æ³¨å…¥propsï¼Œ
            instance.setProps(result);
          })();;
      },
      {
        immediate: true,
        deep: true,
      },
    );
  }
  // æš´éœ²äºå¤–éƒ¨è°ƒç”¨æ“ä½œformçš„æ–¹æ³•
  const methods: FormActionType = {
    scrollToField: async (name: NamePath, options?: ScrollOptions | undefined) => {
      const form = await getForm();
      form.scrollToField(name, options);
    },
    setProps: async (formProps: Partial<FormProps>) => {
      const form = await getForm();
      form.setProps(formProps);
    },

    // åŠ¨æ€æ·»åŠ è¡¨å•ç»„ä»¶æ–¹æ³•
    updateSchema: async (data: Partial<FormSchema> | Partial<FormSchema>[]) => {
      const form = await getForm();
      form.updateSchema(data);
    },

    resetSchema: async (data: Partial<FormSchema> | Partial<FormSchema>[]) => {
      const form = await getForm();
      form.resetSchema(data);
    },

    clearValidate: async (name?: string | string[]) => {
      const form = await getForm();
      form.clearValidate(name);
    },

    resetFields: async () => {
      getForm().then(async (form) => {
        await form.resetFields();
      });
    },

    removeSchemaByField: async (field: string | string[]) => {
      unref(formRef)?.removeSchemaByField(field);
    },

    // TODO promisify
    getFieldsValue: <T>() => {
      return unref(formRef)?.getFieldsValue() as T;
    },

    setFieldsValue: async <T>(values: T) => {
      const form = await getForm();
      form.setFieldsValue<T>(values);
    },

    appendSchemaByField: async (
      schema: FormSchema | FormSchema[],
      prefixField: string | undefined,
      first: boolean,
    ) => {
      const form = await getForm();
      form.appendSchemaByField(schema, prefixField, first);
    },

    submit: async (): Promise<any> => {
      const form = await getForm();
      return form.submit();
    },

    validate: async (nameList?: NamePath[]): Promise<Recordable> => {
      const form = await getForm();
      return form.validate(nameList);
    },

    validateFields: async (nameList?: NamePath[]): Promise<Recordable> => {
      const form = await getForm();
      return form.validateFields(nameList);
    },
  };

  return [register, methods];
}

```

åœ¨useFormä¸­ï¼Œä¸ºformæ³¨å…¥propså­—æ®µï¼Œ

åœ¨baseFormä¸­å¼•ç”¨

```html
<template>
  <Form
    v-bind="getBindValue"
    :class="getFormClass"
    ref="formElRef"
    :model="formModel"
    @keypress.enter="handleEnterPress"
  >
    <Row v-bind="getRow">
      <slot name="formHeader"></slot>
      <!-- æ­¤å¤„ï¼Œforå¾ªç¯æ¸²æŸ“getSchema -->
      <template v-for="schema in getSchema" :key="schema.field">
      <!-- å…¶ä¸­ï¼Œschemaå­—æ®µéƒ¨åˆ†å°±æ˜¯æˆ‘ä»¬instance.setProps(result)è®¾ç½®çš„åˆå§‹å±æ€§ï¼Œå…·ä½“çš„è¿˜éœ€çœ‹getSchemaæ–¹æ³• -->
        <FormItem
          :isAdvanced="fieldsIsAdvancedMap[schema.field]"
          :tableAction="tableAction"
          :formActionType="formActionType"
          :schema="schema"
          :formProps="getProps"
          :allDefaultValues="defaultValueRef"
          :formModel="formModel"
          :setFormModel="setFormModel"
        >
        <!-- åœ¨æ­¤ï¼ŒFormItemç»„ä»¶ä¸­ï¼ŒåŠ¨æ€è®¾ç½®slot -->
          <template #[item]="data" v-for="item in Object.keys($slots)">
            <slot :name="item" v-bind="data || {}"></slot>
          </template>
        </FormItem>
      </template>

      <FormAction v-bind="getFormActionBindProps" @toggle-advanced="handleToggleAdvanced">
        <template
          #[item]="data"
          v-for="item in ['resetBefore', 'submitBefore', 'advanceBefore', 'advanceAfter']"
        >
          <slot :name="item" v-bind="data || {}"></slot>
        </template>
      </FormAction>
      <slot name="formFooter"></slot>
    </Row>
  </Form>
</template>
<script lang="ts">
  import type { FormActionType, FormProps, FormSchema } from './types/form';
  import type { AdvanceState } from './types/hooks';
  import type { Ref } from 'vue';

  import { defineComponent, reactive, ref, computed, unref, onMounted, watch, nextTick } from 'vue';
  import { Form, Row } from 'ant-design-vue';
  import FormItem from './components/FormItem.vue';
  import FormAction from './components/FormAction.vue';

  import { dateItemType } from './helper';
  import { dateUtil } from '/@/utils/dateUtil';

  // import { cloneDeep } from 'lodash-es';
  import { deepMerge } from '/@/utils';

  import { useFormValues } from './hooks/useFormValues';
  import useAdvanced from './hooks/useAdvanced';
  import { useFormEvents } from './hooks/useFormEvents';
  import { createFormContext } from './hooks/useFormContext';
  import { useAutoFocus } from './hooks/useAutoFocus';
  import { useModalContext } from '/@/components/Modal';
  import { useDebounceFn } from '@vueuse/core';

  import { basicProps } from './props';
  import { useDesign } from '/@/hooks/web/useDesign';
  import { cloneDeep } from 'lodash-es';

  export default defineComponent({
    name: 'BasicForm',
    components: { FormItem, Form, Row, FormAction },
    props: basicProps,
    emits: ['advanced-change', 'reset', 'submit', 'register', 'field-value-change'],
    setup(props, { emit, attrs }) {
      const formModel = reactive({});
      const modalFn = useModalContext();

      const advanceState = reactive<AdvanceState>({
        isAdvanced: true,
        hideAdvanceBtn: false,
        isLoad: false,
        actionSpan: 6,
      });

      const defaultValueRef = ref({});
      const isInitedDefaultRef = ref(false);
      const propsRef = ref<Partial<FormProps>>({});
      const schemaRef = ref<FormSchema[] | null>(null);
      const formElRef = ref<FormActionType | null>(null);

      const { prefixCls } = useDesign('basic-form');

      // Get the basic configuration of the form
      const getProps = computed((): FormProps => {
        return { ...props, ...unref(propsRef) };
      });

      const getFormClass = computed(() => {
        return [
          prefixCls,
          {
            [`${prefixCls}--compact`]: unref(getProps).compact,
          },
        ];
      });

      // Get uniform row style and Row configuration for the entire form
      const getRow = computed(() => {
        const { baseRowStyle = {}, rowProps } = unref(getProps);
        return {
          style: baseRowStyle,
          ...rowProps,
        };
      });

      const getBindValue = computed(() => ({ ...attrs, ...props, ...unref(getProps) }));

      const getSchema = computed((): FormSchema[] => {
        // å–å€¼propsä¸­çš„å€¼ï¼Œ
        const schemas: FormSchema[] = unref(schemaRef) || (unref(getProps).schemas as any);
        for (const schema of schemas) {
          const { defaultValue, component, isHandleDateDefaultValue = true } = schema;
          // handle date typeï¼ˆå¤„ç†æ—¶é—´æ ¼å¼çš„ç»„ä»¶ï¼Œï¼‰
          /**
           * 
           * const DATE_TYPE = ['DatePicker', 'MonthPicker', 'WeekPicker', 'TimePicker'];
            function genType() {
              return [...DATE_TYPE, 'RangePicker'];
            }
           */
          if (isHandleDateDefaultValue && defaultValue && dateItemType.includes(component)) {
            // å¤„ç†æ—¶é—´æ ¼å¼ç»„ä»¶éæ³•é»˜è®¤å­—æ®µ
            if (!Array.isArray(defaultValue)) {
              schema.defaultValue = dateUtil(defaultValue);
            } else {
              const def: any[] = [];
              defaultValue.forEach((item) => {
                def.push(dateUtil(item));
              });
              schema.defaultValue = def;
            }
          }
        }
        if (unref(getProps).showAdvancedButton) { // æ˜¾ç¤ºé«˜çº§æŒ‰é’®ï¼Ÿï¼Ÿç„¶åå°±æŠŠDivideråˆ†å‰²çº¿ç»„ä»¶è¿‡æ»¤ï¼Ÿï¼Ÿ
          return cloneDeep(
            schemas.filter((schema) => schema.component !== 'Divider') as FormSchema[],
          );
        } else {
          return cloneDeep(schemas as FormSchema[]);
        }
      });

      const { handleToggleAdvanced, fieldsIsAdvancedMap } = useAdvanced({
        advanceState,
        emit,
        getProps,
        getSchema,
        formModel,
        defaultValueRef,
      });

      const { handleFormValues, initDefault } = useFormValues({
        getProps,
        defaultValueRef,
        getSchema,
        formModel,
      });

      useAutoFocus({
        getSchema,
        getProps,
        isInitedDefault: isInitedDefaultRef,
        formElRef: formElRef as Ref<FormActionType>,
      });

      const {
        handleSubmit,
        setFieldsValue,
        clearValidate,
        validate,
        validateFields,
        getFieldsValue,
        updateSchema, // formçš„åŠ¨æ€æ·»åŠ è¡¨å•æ–¹æ³•
        /**
         * åœ¨useFormEventsä¸­
         *  async function updateSchema(data: Partial<FormSchema> | Partial<FormSchema>[]) {
              let updateData: Partial<FormSchema>[] = [];
              if (isObject(data)) {
                updateData.push(data as FormSchema);
              }
              if (isArray(data)) {
                updateData = [...data];
              }

              const hasField = updateData.every(
                (item) => item.component === 'Divider' || (Reflect.has(item, 'field') && item.field),
              );

              if (!hasField) {
                error(
                  'All children of the form Schema array that need to be updated must contain the `field` field',
                );
                return;
              }
              const schema: FormSchema[] = [];

              // æ¬¡æ•°æ·±åº¦éå†ï¼ŒåŒå±‚æ¯”è¾ƒï¼Œæ›´æ–°è€çš„ç»„ä»¶Schemasï¼ŒåŠ å…¥æ–°çš„Schemas
              unref(getSchema).forEach((val) => {
                let _val;
                updateData.forEach((item) => {
                  if (val.field === item.field) {
                    _val = item;
                  }
                });
                if (_val !== undefined && val.field === _val.field) {
                  const newSchema = deepMerge(val, _val);
                  schema.push(newSchema as FormSchema); // æ›´æ–°
                } else {
                  schema.push(val); // åŠ å…¥æ–°çš„
                }
              });
              _setDefaultValue(schema);

              // è¸¢å‡ºfieldå­—æ®µçš„é‡å¤ç»„ä»¶ï¼Œå»ºè®®ç”¨field1ï¼Œ field2ï¼Œ field3ï¼Œé˜²æ­¢é‡å
              schemaRef.value = uniqBy(schema, 'field');
            }
            

            // è¯¥æ–¹æ³•æ˜¯ä¾åºä¸ºåŠ¨æ€ç»„ä»¶è®¾ç½®valueå€¼ï¼Œå³æ— è®ºæ˜¯updateSchemaï¼Œ appendSchemaByField,éƒ½å¯å¤ç”¨è¯¥æ–¹æ³•
            function _setDefaultValue(data: FormSchema | FormSchema[]) {
                let schemas: FormSchema[] = [];
                if (isObject(data)) {
                  schemas.push(data as FormSchema);
                }
                if (isArray(data)) {
                  schemas = [...data];
                }

                const obj: Recordable = {};
                const currentFieldsValue = getFieldsValue();
                // éå†åŒ…è£…ç»„ä»¶ï¼Œå¹¶æ ¡éªŒç»„ä»¶å¯å¦ä½¿ç”¨
                schemas.forEach((item) => {
                  if (
                    item.component != 'Divider' &&
                    Reflect.has(item, 'field') &&
                    item.field &&
                    !isNullOrUnDef(item.defaultValue) &&
                    (!(item.field in currentFieldsValue) ||
                      isNullOrUnDef(currentFieldsValue[item.field]) ||
                      isEmpty(currentFieldsValue[item.field]))
                  ) {
                    obj[item.field] = item.defaultValue;
                  }
                });
                setFieldsValue(obj);
              }

              // ç»™åŠ¨æ€filedè®¾ç½®valueï¼ŒappendSchemaByFieldä¹ŸåŒç† ï¼Œå°±ä¸è´´äº†
              async function setFieldsValue(values: Recordable): Promise<void> {
                const fields = unref(getSchema)
                  .map((item) => item.field)
                  .filter(Boolean);

                // key æ”¯æŒ a.b.c çš„åµŒå¥—å†™æ³•
                const delimiter = '.';  // obj[key1][key2][key3] è¿™ç§å–å€¼æ–¹æ³•
                const nestKeyArray = fields.filter((item) => String(item).indexOf(delimiter) >= 0);

                const validKeys: string[] = [];
                fields.forEach((key) => {
                  const schema = unref(getSchema).find((item) => item.field === key);
                  let value = get(values, key);
                  const hasKey = !!get(values, key);

                  value = handleInputNumberValue(schema?.component, value);
                  const { componentProps } = schema || {};
                  let _props = componentProps as any;
                  if (typeof componentProps === 'function') {
                    _props = _props({ formModel: unref(formModel) }); // _propsä¸ºå‡½æ•°ï¼Œåˆ™å°†å‡½æ•°æ‰§è¡Œç»“æœè¿”å›ç»™_props
                  }

                  const constructValue = tryConstructArray(key, values) || tryConstructObject(key, values);

                  // 0| '' is allow
                  if (hasKey || !!constructValue) {
                    const fieldValue = constructValue || value;
                    // time type
                    if (itemIsDateType(key)) {
                      //  éå†modelï¼ŒåŠ¨æ€æ·»åŠ form-modelde
                      if (Array.isArray(fieldValue)) {
                        const arr: any[] = [];
                        for (const ele of fieldValue) {
                          arr.push(ele ? dateUtil(ele) : null);
                        }
                        unref(formModel)[key] = arr;
                      } else {
                        unref(formModel)[key] = fieldValue
                          ? _props?.valueFormat
                            ? fieldValue
                            : dateUtil(fieldValue)
                          : null;
                      }
                    } else {
                      unref(formModel)[key] = fieldValue;
                    }
                    if (_props?.onChange) {
                      _props?.onChange(fieldValue);
                    }
                    validKeys.push(key);
                  } else {
                    nestKeyArray.forEach((nestKey: string) => {
                      try { // ruleForm.map.inpitValueè¿™ç§æƒ…å†µ
                        const value = nestKey.split('.').reduce((out, item) => out[item], values);
                        if (isDef(value)) {
                          unref(formModel)[nestKey] = unref(value);
                          validKeys.push(nestKey);
                        }
                      } catch (e) {
                        // key not exist
                        if (isDef(defaultValueRef.value[nestKey])) {
                          unref(formModel)[nestKey] = cloneDeep(unref(defaultValueRef.value[nestKey]));
                        }
                      }
                    });
                  }
                });
                validateFields(validKeys).catch((_) => {});
              }
         * 
         */
        resetSchema,
        appendSchemaByField,
        removeSchemaByField,
        resetFields,
        scrollToField,
      } = useFormEvents({
        emit,
        getProps,
        formModel,
        getSchema,
        defaultValueRef,
        formElRef: formElRef as Ref<FormActionType>,
        schemaRef: schemaRef as Ref<FormSchema[]>,
        handleFormValues,
      });

      createFormContext({
        resetAction: resetFields,
        submitAction: handleSubmit,
      });

      watch(
        () => unref(getProps).model,
        () => {
          const { model } = unref(getProps);
          if (!model) return;
          setFieldsValue(model);
        },
        {
          immediate: true,
        },
      );

      watch(
        () => unref(getProps).schemas,
        (schemas) => {
          resetSchema(schemas ?? []);
        },
      );

      watch(
        () => getSchema.value,
        (schema) => {
          nextTick(() => {
            //  Solve the problem of modal adaptive height calculation when the form is placed in the modal
            modalFn?.redoModalHeight?.();
          });
          if (unref(isInitedDefaultRef)) {
            return;
          }
          if (schema?.length) {
            initDefault();
            isInitedDefaultRef.value = true;
          }
        },
      );

      watch(
        () => formModel,
        useDebounceFn(() => {
          unref(getProps).submitOnChange && handleSubmit();
        }, 300),
        { deep: true },
      );

      async function setProps(formProps: Partial<FormProps>): Promise<void> {
        propsRef.value = deepMerge(unref(propsRef) || {}, formProps);
      }

      function setFormModel(key: string, value: any, schema: FormSchema) {
        formModel[key] = value;
        emit('field-value-change', key, value);
        // TODO ä¼˜åŒ–éªŒè¯ï¼Œè¿™é‡Œå¦‚æœæ˜¯autoLink=falseæ‰‹åŠ¨å…³è”çš„æƒ…å†µä¸‹æ‰ä¼šå†æ¬¡è§¦å‘æ­¤å‡½æ•°
        if (schema && schema.itemProps && !schema.itemProps.autoLink) {
          validateFields([key]).catch((_) => {});
        }
      }

      function handleEnterPress(e: KeyboardEvent) {
        const { autoSubmitOnEnter } = unref(getProps);
        if (!autoSubmitOnEnter) return;
        if (e.key === 'Enter' && e.target && e.target instanceof HTMLElement) {
          const target: HTMLElement = e.target as HTMLElement;
          if (target && target.tagName && target.tagName.toUpperCase() == 'INPUT') {
            handleSubmit();
          }
        }
      }

      const formActionType: Partial<FormActionType> = {
        getFieldsValue,
        setFieldsValue,
        resetFields,
        updateSchema,
        resetSchema,
        setProps,
        removeSchemaByField,
        appendSchemaByField,
        clearValidate,
        validateFields,
        validate,
        submit: handleSubmit,
        scrollToField: scrollToField,
      };

      onMounted(() => {
        initDefault();
        emit('register', formActionType);
      });

      return {
        getBindValue,
        handleToggleAdvanced,
        handleEnterPress,
        formModel,
        defaultValueRef,
        advanceState,
        getRow,
        getProps,
        formElRef,
        getSchema,
        formActionType: formActionType as any,
        setFormModel,
        getFormClass,
        getFormActionBindProps: computed(() => ({ ...getProps.value, ...advanceState })),
        fieldsIsAdvancedMap,
        ...formActionType,
      };
    },
  });
</script>
<style lang="less">
  @prefix-cls: ~'@{namespace}-basic-form';

  .@{prefix-cls} {
    .ant-form-item {
      &-label label::after {
        margin: 0 6px 0 2px;
      }

      &-with-help {
        margin-bottom: 0;
      }

      &:not(.ant-form-item-with-help) {
        margin-bottom: 20px;
      }

      &.suffix-item {
        .ant-form-item-children {
          display: flex;
        }

        .ant-form-item-control {
          margin-top: 4px;
        }

        .suffix {
          display: inline-flex;
          align-items: center;
          margin-top: 1px;
          padding-left: 6px;
          line-height: 1;
        }
      }
    }

    .ant-form-explain {
      font-size: 14px;
    }

    &--compact {
      .ant-form-item {
        margin-bottom: 8px !important;
      }
    }
  }
</style>

```

åœ¨FormItemä¸­ï¼Œ


```tsx
<script lang="tsx">
  import { type Recordable, type Nullable } from '@vben/types';
  import type { PropType, Ref } from 'vue';
  import { computed, defineComponent, toRefs, unref } from 'vue';
  import type { FormActionType, FormProps, FormSchema } from '../types/form';
  import type { ValidationRule } from 'ant-design-vue/lib/form/Form';
  import type { TableActionType } from '/@/components/Table';
  import { Col, Divider, Form } from 'ant-design-vue';
  import { componentMap } from '../componentMap'; // æ­¤å¤„å·²ç»å°è£…äº†ant-Dçš„å¸¸ç”¨ç»„ä»¶ï¼Œå¦‚æœéœ€è¦æ‹“å±•è‡ªå·±çš„ç»„ä»¶ä¸FormItem,åˆ™å¯ä»¥æ”¹è¿™é‡Œï¼Œä¹Ÿå¯ä»¥æ–°å»ºä¸ªnew Map,æœ€ååˆå¹¶è¿™ä¸ªcomponentMap
  import { BasicHelp } from '/@/components/Basic';
  import { isBoolean, isFunction, isNull } from '/@/utils/is';
  import { getSlot } from '/@/utils/helper/tsxHelper';
  import {
    createPlaceholderMessage,
    NO_AUTO_LINK_COMPONENTS,
    setComponentRuleType,
  } from '../helper';
  import { cloneDeep, upperFirst } from 'lodash-es';
  import { useItemLabelWidth } from '../hooks/useLabelWidth';
  import { useI18n } from '/@/hooks/web/useI18n';

  export default defineComponent({
    name: 'BasicFormItem',
    inheritAttrs: false,
    props: {
      schema: {
        type: Object as PropType<FormSchema>,
        default: () => ({}),
      },
      formProps: {
        type: Object as PropType<FormProps>,
        default: () => ({}),
      },
      allDefaultValues: {
        type: Object as PropType<Recordable<any>>,
        default: () => ({}),
      },
      formModel: {
        type: Object as PropType<Recordable<any>>,
        default: () => ({}),
      },
      setFormModel: {
        type: Function as PropType<(key: string, value: any, schema: FormSchema) => void>,
        default: null,
      },
      tableAction: {
        type: Object as PropType<TableActionType>,
      },
      formActionType: {
        type: Object as PropType<FormActionType>,
      },
      isAdvanced: {
        type: Boolean,
      },
    },
    setup(props, { slots }) {
      const { t } = useI18n();

      /**æ­¤åˆ»ï¼Œå°†schema, formPropsç½®ä¸ºå“åº”å¼ */
      const { schema, formProps } = toRefs(props) as {
        schema: Ref<FormSchema>;
        formProps: Ref<FormProps>;
      };

      const itemLabelWidthProp = useItemLabelWidth(schema, formProps);

      const getValues = computed(() => {
        const { allDefaultValues, formModel, schema } = props;
        const { mergeDynamicData } = props.formProps;
        return {
          field: schema.field,
          model: formModel,
          values: {
            ...mergeDynamicData,
            ...allDefaultValues,
            ...formModel,
          } as Recordable<any>,
          schema: schema,
        };
      });

      const getComponentsProps = computed(() => {
        const { schema, tableAction, formModel, formActionType } = props;
        let { componentProps = {} } = schema;
        if (isFunction(componentProps)) {
          componentProps = componentProps({ schema, tableAction, formModel, formActionType }) ?? {};
        }
        // é¢å¤–è®¾ç½®åˆ†å‰²çº¿ç»„ä»¶typeï¼ŒğŸ‚ğŸº
        if (schema.component === 'Divider') {
          componentProps = Object.assign(
            { type: 'horizontal' },
            {
              orientation: 'left',
              plain: true,
            },
            componentProps,
          );
        }
        return componentProps as Recordable<any>;
      });

      const getDisable = computed(() => {
        const { disabled: globDisabled } = props.formProps;
        const { dynamicDisabled } = props.schema;
        const { disabled: itemDisabled = false } = unref(getComponentsProps);
        let disabled = !!globDisabled || itemDisabled;
        if (isBoolean(dynamicDisabled)) {
          disabled = dynamicDisabled;
        }
        if (isFunction(dynamicDisabled)) {
          disabled = dynamicDisabled(unref(getValues));
        }
        return disabled;
      });

      function getShow(): { isShow: boolean; isIfShow: boolean } {
        const { show, ifShow } = props.schema;
        const { showAdvancedButton } = props.formProps;
        const itemIsAdvanced = showAdvancedButton
          ? isBoolean(props.isAdvanced)
            ? props.isAdvanced
            : true
          : true;

        let isShow = true;
        let isIfShow = true;

        if (isBoolean(show)) {
          isShow = show;
        }
        if (isBoolean(ifShow)) {
          isIfShow = ifShow;
        }
        if (isFunction(show)) {
          isShow = show(unref(getValues));
        }
        if (isFunction(ifShow)) {
          isIfShow = ifShow(unref(getValues));
        }
        isShow = isShow && itemIsAdvanced;
        return { isShow, isIfShow };
      }

      function handleRules(): ValidationRule[] {
        const {
          rules: defRules = [],
          component,
          rulesMessageJoinLabel,
          label,
          dynamicRules,
          required,
        } = props.schema;

        if (isFunction(dynamicRules)) {
          return dynamicRules(unref(getValues)) as ValidationRule[];
        }

        let rules: ValidationRule[] = cloneDeep(defRules) as ValidationRule[];
        const { rulesMessageJoinLabel: globalRulesMessageJoinLabel } = props.formProps;

        const joinLabel = Reflect.has(props.schema, 'rulesMessageJoinLabel')
          ? rulesMessageJoinLabel
          : globalRulesMessageJoinLabel;
        const defaultMsg = createPlaceholderMessage(component) + `${joinLabel ? label : ''}`;

        function validator(rule: any, value: any) {
          const msg = rule.message || defaultMsg;
          if (value === undefined || isNull(value)) {
            // ç©ºå€¼
            return Promise.reject(msg);
          } else if (Array.isArray(value) && value.length === 0) {
            // æ•°ç»„ç±»å‹
            return Promise.reject(msg);
          } else if (typeof value === 'string' && value.trim() === '') {
            // ç©ºå­—ç¬¦ä¸²
            return Promise.reject(msg);
          } else if (
            typeof value === 'object' &&
            Reflect.has(value, 'checked') &&
            Reflect.has(value, 'halfChecked') &&
            Array.isArray(value.checked) &&
            Array.isArray(value.halfChecked) &&
            value.checked.length === 0 &&
            value.halfChecked.length === 0
          ) {
            // éå…³è”é€‰æ‹©çš„treeç»„ä»¶
            return Promise.reject(msg);
          }
          return Promise.resolve();
        }

        const getRequired = isFunction(required) ? required(unref(getValues)) : required;

        /*
         * 1ã€è‹¥è®¾ç½®äº†requiredå±æ€§ï¼Œåˆæ²¡æœ‰å…¶ä»–çš„rulesï¼Œå°±åˆ›å»ºä¸€ä¸ªéªŒè¯è§„åˆ™ï¼›
         * 2ã€è‹¥è®¾ç½®äº†requiredå±æ€§ï¼Œåˆå­˜åœ¨å…¶ä»–çš„rulesï¼Œåˆ™åªrulesä¸­ä¸å­˜åœ¨requiredå±æ€§æ—¶ï¼Œæ‰æ·»åŠ éªŒè¯requiredçš„è§„åˆ™
         *     ä¹Ÿå°±æ˜¯è¯´rulesä¸­çš„requiredï¼Œä¼˜å…ˆçº§å¤§äºrequired
         */
        if (getRequired) {
          if (!rules || rules.length === 0) {
            rules = [{ required: getRequired, validator }];
          } else {
            const requiredIndex: number = rules.findIndex((rule) => Reflect.has(rule, 'required'));

            if (requiredIndex === -1) {
              rules.push({ required: getRequired, validator });
            }
          }
        }

        const requiredRuleIndex: number = rules.findIndex(
          (rule) => Reflect.has(rule, 'required') && !Reflect.has(rule, 'validator'),
        );

        if (requiredRuleIndex !== -1) {
          const rule = rules[requiredRuleIndex];
          const { isShow } = getShow();
          if (!isShow) {
            rule.required = false;
          }
          if (component) {
            if (!Reflect.has(rule, 'type')) {
              rule.type = component === 'InputNumber' ? 'number' : 'string';
            }

            rule.message = rule.message || defaultMsg;

            if (component.includes('Input') || component.includes('Textarea')) {
              rule.whitespace = true;
            }
            const valueFormat = unref(getComponentsProps)?.valueFormat;
            setComponentRuleType(rule, component, valueFormat);
          }
        }

        // Maximum input length rule check
        const characterInx = rules.findIndex((val) => val.max);
        if (characterInx !== -1 && !rules[characterInx].validator) {
          rules[characterInx].message =
            rules[characterInx].message ||
            t('component.form.maxTip', [rules[characterInx].max] as Recordable<any>);
        }
        return rules;
      }

      function renderComponent() {
        const {
          renderComponentContent,
          component,
          field,
          changeEvent = 'change',
          valueField,
        } = props.schema;

        const isCheck = component && ['Switch', 'Checkbox'].includes(component);

        const eventKey = `on${upperFirst(changeEvent)}`;

        const on = {
          [eventKey]: (...args: Nullable<Recordable<any>>[]) => {
            const [e] = args;
            if (propsData[eventKey]) {
              propsData[eventKey](...args);
            }
            const target = e ? e.target : null;
            const value = target ? (isCheck ? target.checked : target.value) : e;
            props.setFormModel(field, value, props.schema);
          },
        };
        const Comp = componentMap.get(component) as ReturnType<typeof defineComponent>;

        const { autoSetPlaceHolder, size } = props.formProps;
        const propsData: Recordable<any> = {
          allowClear: true,
          getPopupContainer: (trigger: Element) => trigger.parentNode,
          size,
          ...unref(getComponentsProps),
          disabled: unref(getDisable),
        };

        const isCreatePlaceholder = !propsData.disabled && autoSetPlaceHolder;
        // RangePicker place is an array
        if (isCreatePlaceholder && component !== 'RangePicker' && component) {
          propsData.placeholder =
            unref(getComponentsProps)?.placeholder || createPlaceholderMessage(component);
        }
        propsData.codeField = field;
        propsData.formValues = unref(getValues);

        const bindValue: Recordable<any> = {
          [valueField || (isCheck ? 'checked' : 'value')]: props.formModel[field],
        };

        const compAttr: Recordable<any> = {
          ...propsData,
          ...on,
          ...bindValue,
        };

        if (!renderComponentContent) {
          return <Comp {...compAttr} />;
        }
        const compSlot = isFunction(renderComponentContent)
          ? { ...renderComponentContent(unref(getValues)) }
          : {
              default: () => renderComponentContent,
            };
        return <Comp {...compAttr}>{compSlot}</Comp>;
      }

      function renderLabelHelpMessage() {
        const { label, helpMessage, helpComponentProps, subLabel } = props.schema;
        const renderLabel = subLabel ? (
          <span>
            {label} <span class="text-secondary">{subLabel}</span>
          </span>
        ) : (
          label
        );
        const getHelpMessage = isFunction(helpMessage)
          ? helpMessage(unref(getValues))
          : helpMessage;
        if (!getHelpMessage || (Array.isArray(getHelpMessage) && getHelpMessage.length === 0)) {
          return renderLabel;
        }
        return (
          <span>
            {renderLabel}
            <BasicHelp placement="top" class="mx-1" text={getHelpMessage} {...helpComponentProps} />
          </span>
        );
      }

      function renderItem() {
        // ä¹‹å‰åœ¨ç»„ä»¶å†…åˆ¤æ–­è¿‡æ»¤æ‰å’Œform-itemçš„ç»„ä»¶å†²çªæˆ–è€…ä¸éœ€è¦form-itemåŒ…è£¹çš„å†…å®¹
        const { itemProps, slot, render, field, suffix, component } = props.schema;
        const { labelCol, wrapperCol } = unref(itemLabelWidthProp);
        const { colon } = props.formProps;
        // åˆ†å‰²çº¿ç»„ä»¶å¿˜ä¸äº†æ˜¯å§ï¼Œæˆ‘å°±é—®ä½ 
        if (component === 'Divider') {
          return (
            <Col span={24}>
              <Divider {...unref(getComponentsProps)}>{renderLabelHelpMessage()}</Divider>
            </Col>
          );
        } else {
          /**
             * åœ¨è¿™é‡Œï¼Œform-itemç»„ä»¶çš„æ’æ§½æ˜¯æˆ‘ä»¬ä¼ è¿›æ¥çš„renderæˆ–renderComponentï¼Œå¦‚æœæˆ‘ä»¬æŒ‡å®šäº†slotï¼Œ
             * {
                field: 'field3',
                component: 'Input',
                label: 'è‡ªå®šä¹‰Slot',
                slot: 'f3',
                colProps: {
                  span: 8,
                },
                rules: [{ required: true }],
              },
              æˆ‘ä»¬å¯ä»¥å®ç°å¥—å¨ƒï¼Œå³form-itemå¥—æˆ‘ä»¬çš„renderç»„ä»¶ï¼Œæˆ‘ä»¬å†ç»™æˆ‘ä»¬çš„renderç»„ä»¶å¥—æ¨¡æ¿ï¼Œåˆ°æ—¶å€™
              æˆ‘ä»¬å°±å¯ä»¥åœ¨templateé‡Œä½¿ç”¨
              <BasicForm @register="register" @submit="handleSubmit">
                <template #f3="{ model, field }">
                  <div>
                    <a-input v-model:value="model[field]" placeholder="è‡ªå®šä¹‰slot" />
                  </div>
                </template>
              </BasicForm>


              renderComponentContent,
              å³æ’å…¥ant-Dç»„ä»¶çš„æ’æ§½ï¼Œ
              æ¯”å¦‚a-inputæ¥å—æ’æ§½Suffixï¼Œåˆ™ä¼ å‚renderComponentContentï¼Œè¿”å›Suffixï¼Œæ¸²æŸ“æ’æ§½çš„æ’æ§½ï¼Œ
              å®Œç¾å¥—å¨ƒ
             */
            console.log('slot', slot);
          const getContent = () => {
            return slot
              ? getSlot(slots, slot, unref(getValues))
              : render
              ? render(unref(getValues))
              : renderComponent();
          };

          const showSuffix = !!suffix;
          const getSuffix = isFunction(suffix) ? suffix(unref(getValues)) : suffix;

          // TODO è‡ªå®šä¹‰ç»„ä»¶éªŒè¯ä¼šå‡ºç°é—®é¢˜ï¼Œå› æ­¤è¿™é‡Œæ¡†æ¶é»˜è®¤å°†è‡ªå®šä¹‰ç»„ä»¶è®¾ç½®æ‰‹åŠ¨è§¦å‘éªŒè¯ï¼Œå¦‚æœå…¶ä»–ç»„ä»¶è¿˜æœ‰æ­¤é—®é¢˜è¯·æ‰‹åŠ¨è®¾ç½®autoLink=false
          if (NO_AUTO_LINK_COMPONENTS.includes(component)) {
            props.schema &&
              (props.schema.itemProps! = {
                autoLink: false,
                ...props.schema.itemProps,
              });
          }

          return (
            <Form.Item
              name={field}
              colon={colon}
              class={{ 'suffix-item': showSuffix }}
              {...(itemProps as Recordable<any>)}
              label={renderLabelHelpMessage()}
              rules={handleRules()}
              labelCol={labelCol}
              wrapperCol={wrapperCol}
            >
              <div style="display:flex">
                {/* æ¸²æŸ“æ’æ§½ */}
                <div style="flex:1;">{getContent()}</div>
                {/* åç¼€ */}
                {showSuffix && <span class="suffix">{getSuffix}</span>}
              </div>
            </Form.Item>
          );
        }
      }

      return () => {
        const { colProps = {}, colSlot, renderColContent, component } = props.schema;
        // é¦–å…ˆæ ¡éªŒç»„ä»¶æ˜¯å¦æ³¨å†Œ
        if (!componentMap.has(component)) {
          return null;
        }

        const { baseColProps = {} } = props.formProps;
        // åˆå¹¶propsï¼Œ
        const realColProps = { ...baseColProps, ...colProps };
        const { isIfShow, isShow } = getShow();
        const values = unref(getValues);

        const getContent = () => {

          /**

            {
              field: 'field123123',
              component: 'Input',
              label: 'renderç»„ä»¶slot666',
              colProps: {
                span: 8,
              },
              rules: [{ required: true }],
              renderColContent: (value) => {
                console.log('value', value);
                return h(Input, {
                  placeholder: 'è¯·è¾“å…¥',
                  onChange: (e: ChangeEvent) => {
                    model[field] = e.target.value;
                  },
                });
              },
            },

            
            if (colSlot) { // æ¸²æŸ“ä¸€èˆ¬$slotæ’æ§½æ ¼å¼çš„å†…å®¹ï¼Œå°±æ˜¯ä¸€èˆ¬$slot.default()é»˜è®¤æ¸²æŸ“ï¼Œå³æˆ‘æŒ‡å®šname="header"ï¼Œåˆ™colSlotä¸ºheader
              return getSlot(slots, colSlot, values)
            } else if (renderColContent) { // ä¸è¦form-itemåŒ…è£¹è‡ªå·±ç©¿å•¥å°±æ˜¯å•¥ç»„ä»¶ï¼Œä¸»æ‰“ä¸€ä¸ªè‡ªç”±çµæ´»
              return renderColContent(values)
            } else { // æ­£å¸¸çš„renderå‡½æ•°
              return renderItem()
            }

            export function getSlot(slots: Slots, slot = 'default', data?: any) {
              if (!slots || !Reflect.has(slots, slot)) {
                return null;
              }
              if (!isFunction(slots[slot])) {
                console.error(`${slot} is not a function!`);
                return null;
              }
              const slotFn = slots[slot];
              if (!slotFn) return null;
              return slotFn(data);
            }

           */
          return colSlot
            ? getSlot(slots, colSlot, values)
            : renderColContent
            ? renderColContent(values)
            : renderItem();
        };
        // </Col>å°±æ˜¯å¸ƒå±€ç»„ä»¶ï¼ŒrealColPropsæ˜¯å›ä¼ ç»™å¸ƒå±€ç»„ä»¶çš„å‚æ•°ï¼Œç¡®å®šç»„ä»¶çš„ä¸€äº›æ ·å¼
        // è¿™ä¸ªç»„ä»¶æœ€å…³é”®çš„æ˜¯æ¸²æŸ“æ’æ§½å†…å®¹getContent
        return (
          isIfShow && (
            <Col {...realColProps} v-show={isShow}>
              {getContent()}
            </Col>
          )
        );
      };
    },
  });
</script>

```