## ç®€æ˜“axioså°è£…

```js
import axios from 'axios'
import { Notification, MessageBox, Message, Loading } from 'element-ui'
import store from '@/store'
import { getToken } from '@/utils/auth'
import errorCode from '@/utils/errorCode'
import { tansParams, blobValidate } from '@/utils/ruoyi'
import cache from '@/plugins/cache'
import { saveAs } from 'file-saver'

let downloadLoadingInstance
// æ˜¯å¦æ˜¾ç¤ºé‡æ–°ç™»å½•
export const isRelogin = { show: false }

axios.defaults.headers['Content-Type'] = 'application/json;charset=utf-8'
// åˆ›å»ºaxioså®ä¾‹
const service = axios.create({
  // axiosä¸­è¯·æ±‚é…ç½®æœ‰baseURLé€‰é¡¹ï¼Œè¡¨ç¤ºè¯·æ±‚URLå…¬å…±éƒ¨åˆ†
  baseURL: process.env.VUE_APP_BASE_API,
  // è¶…æ—¶
  timeout: 10000
})

// requestæ‹¦æˆªå™¨
service.interceptors.request.use(config => {
  // æ˜¯å¦éœ€è¦è®¾ç½® token
  const isToken = (config.headers || {}).isToken === false
  // æ˜¯å¦éœ€è¦é˜²æ­¢æ•°æ®é‡å¤æäº¤
  const isRepeatSubmit = (config.headers || {}).repeatSubmit === false
  if (getToken() && !isToken) {
    config.headers['Authorization'] = 'Bearer ' + getToken() // è®©æ¯ä¸ªè¯·æ±‚æºå¸¦è‡ªå®šä¹‰token è¯·æ ¹æ®å®é™…æƒ…å†µè‡ªè¡Œä¿®æ”¹
  }
  // getè¯·æ±‚æ˜ å°„paramså‚æ•°
  if (config.method === 'get' && config.params) {
    let url = config.url + '?' + tansParams(config.params)
    url = url.slice(0, -1)
    config.params = {}
    config.url = url
  }
  if (!isRepeatSubmit && (config.method === 'post' || config.method === 'put')) {
    const requestObj = {
      url: config.url,
      data: typeof config.data === 'object' ? JSON.stringify(config.data) : config.data,
      time: new Date().getTime()
    }
    const sessionObj = cache.session.getJSON('sessionObj')
    if (sessionObj === undefined || sessionObj === null || sessionObj === '') {
      cache.session.setJSON('sessionObj', requestObj)
    } else {
      const s_url = sessionObj.url // è¯·æ±‚åœ°å€
      const s_data = sessionObj.data // è¯·æ±‚æ•°æ®
      const s_time = sessionObj.time // è¯·æ±‚æ—¶é—´
      const interval = 1000 // é—´éš”æ—¶é—´(ms)ï¼Œå°äºæ­¤æ—¶é—´è§†ä¸ºé‡å¤æäº¤
      if (s_data === requestObj.data && requestObj.time - s_time < interval && s_url === requestObj.url) {
        const message = 'æ•°æ®æ­£åœ¨å¤„ç†ï¼Œè¯·å‹¿é‡å¤æäº¤'
        console.warn(`[${s_url}]: ` + message)
        return Promise.reject(new Error(message))
      } else {
        cache.session.setJSON('sessionObj', requestObj)
      }
    }
  }
  return config
}, error => {
  console.warn(error)
  Promise.reject(error)
})

// å“åº”æ‹¦æˆªå™¨
service.interceptors.response.use(res => {
  // æœªè®¾ç½®çŠ¶æ€ç åˆ™é»˜è®¤æˆåŠŸçŠ¶æ€
  const code = res.data.code || 200
  // è·å–é”™è¯¯ä¿¡æ¯
  const msg = errorCode[code] || res.data.msg || errorCode['default']
  // äºŒè¿›åˆ¶æ•°æ®åˆ™ç›´æ¥è¿”å›
  if (res.request.responseType === 'blob' || res.request.responseType === 'arraybuffer') {
    return res.data
  }
  if (code === 401) {
    if (!isRelogin.show) {
      isRelogin.show = true
      MessageBox.confirm('ç™»å½•çŠ¶æ€å·²è¿‡æœŸï¼Œæ‚¨å¯ä»¥ç»§ç»­ç•™åœ¨è¯¥é¡µé¢ï¼Œæˆ–è€…é‡æ–°ç™»å½•', 'ç³»ç»Ÿæç¤º', {
        confirmButtonText: 'é‡æ–°ç™»å½•',
        cancelButtonText: 'å–æ¶ˆ',
        type: 'warning'
      }
      ).then(() => {
        isRelogin.show = false
        store.dispatch('LogOut').then(() => {
          location.href = '/index'
        })
      }).catch(() => {
        isRelogin.show = false
      })
    }
    return Promise.reject('æ— æ•ˆçš„ä¼šè¯ï¼Œæˆ–è€…ä¼šè¯å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•ã€‚')
  } else if (code === 500) {
    Message.error(res.data.msg)
    return Promise.resolve(res.data)
  } else if (code !== 200) {
    Notification.error({ title: msg })
    return Promise.reject('error')
  } else {
    return res.data
  }
},
error => {
  let { message } = error
  if (message == 'Network Error') {
    message = 'åç«¯æ¥å£è¿æ¥å¼‚å¸¸'
  } else if (message.includes('timeout')) {
    message = 'ç³»ç»Ÿæ¥å£è¯·æ±‚è¶…æ—¶'
  } else if (message.includes('Request failed with status code')) {
    message = 'ç³»ç»Ÿæ¥å£' + message.substr(message.length - 3) + 'å¼‚å¸¸'
  }
  Message({
    message: message,
    type: 'error',
    duration: 5 * 1000
  })
  return Promise.reject(error)
}
)

// é€šç”¨ä¸‹è½½æ–¹æ³•
export const download = (url, params, filename) => {
  downloadLoadingInstance = Loading.service({ text: 'æ­£åœ¨ä¸‹è½½æ•°æ®ï¼Œè¯·ç¨å€™', spinner: 'el-icon-loading', background: 'rgba(0, 0, 0, 0.7)' })
  return service.post(url, params, {
    transformRequest: [(params) => { return tansParams(params) }],
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    responseType: 'blob'
  }).then(async(data) => {
    const isLogin = await blobValidate(data)
    if (isLogin) {
      const blob = new Blob([data])
      saveAs(blob, filename)
    } else {
      const resText = await data.text()
      const rspObj = JSON.parse(resText)
      const errMsg = errorCode[rspObj.code] || rspObj.msg || errorCode['default']
      Message.error(errMsg)
    }
    downloadLoadingInstance.close()
  }).catch((r) => {
    console.error(r)
    Message.error('ä¸‹è½½æ–‡ä»¶å‡ºç°é”™è¯¯ï¼Œè¯·è”ç³»ç®¡ç†å‘˜ï¼')
    downloadLoadingInstance.close()
  })
}

/**
 * @param url{String} è¯·æ±‚è·¯å¾„
 * @param data{Object} è¯·æ±‚å‚æ•°
 * @param method{String} è¯·æ±‚æ–¹æ³•ï¼Œé»˜è®¤get
 * @param params{String} è¯·æ±‚å‚æ•°çš„å‘é€æ–¹å¼['data', 'param', url]
 */
export default ({ url, data = {}, method = 'GET', headers = {}, params = {} }) => {
  return new Promise(function(resolve, reject) {
    service({ headers, method: method.toLowerCase(), url, data, params })
      .then((response) => {
        resolve(response)
      })
      .catch((error) => {
        console.error('ğŸ®ğŸºã®axiosæ•è·è¯·æ±‚è¿”å›çš„error-->', error)
        reject(error)
      })
  })
}

```

tansParams

```js
/**
* å‚æ•°å¤„ç†
* @param {*} params  å‚æ•°
*/
export function tansParams(params) {
  let result = ''
  for (const propName of Object.keys(params)) {
    const value = params[propName]
    var part = encodeURIComponent(propName) + '='
    if (value !== null && value !== '' && typeof (value) !== 'undefined') {
      if (typeof value === 'object') {
        for (const key of Object.keys(value)) {
          if (value[key] !== null && value[key] !== '' && typeof (value[key]) !== 'undefined') {
            const params = propName + '[' + key + ']'
            var subPart = encodeURIComponent(params) + '='
            result += subPart + encodeURIComponent(value[key]) + '&'
          }
        }
      } else {
        result += part + encodeURIComponent(value) + '&'
      }
    }
  }
  return result
}
```

blobValidate

```js
// éªŒè¯æ˜¯å¦ä¸ºblobæ ¼å¼
export async function blobValidate(data) {
  try {
    const text = await data.text()
    JSON.parse(text)
    return false
  } catch (error) {
    return true
  }
}
```

getToken

```js
import Cookies from 'js-cookie'
const TokenKey = 'Admin-Token'
// è·å–token
export function getToken() {
  return Cookies.get(TokenKey)
}
```

errorCode

```js
export default {
  '401': 'è®¤è¯å¤±è´¥ï¼Œæ— æ³•è®¿é—®ç³»ç»Ÿèµ„æº',
  '403': 'å½“å‰æ“ä½œæ²¡æœ‰æƒé™',
  '404': 'è®¿é—®èµ„æºä¸å­˜åœ¨',
  'default': 'ç³»ç»ŸæœªçŸ¥é”™è¯¯ï¼Œè¯·åé¦ˆç»™ç®¡ç†å‘˜'
}

```

catche.js

```js
const sessionCache = {
  set (key, value) {
    if (!sessionStorage) {
      return
    }
    if (key != null && value != null) {
      sessionStorage.setItem(key, value)
    }
  },
  get (key) {
    if (!sessionStorage) {
      return null
    }
    if (key == null) {
      return null
    }
    return sessionStorage.getItem(key)
  },
  setJSON (key, jsonValue) {
    if (jsonValue != null) {
      this.set(key, JSON.stringify(jsonValue))
    }
  },
  getJSON (key) {
    const value = this.get(key)
    if (value != null) {
      return JSON.parse(value)
    }
  },
  remove (key) {
    sessionStorage.removeItem(key);
  }
}
const localCache = {
  set (key, value) {
    if (!localStorage) {
      return
    }
    if (key != null && value != null) {
      localStorage.setItem(key, value)
    }
  },
  get (key) {
    if (!localStorage) {
      return null
    }
    if (key == null) {
      return null
    }
    return localStorage.getItem(key)
  },
  setJSON (key, jsonValue) {
    if (jsonValue != null) {
      this.set(key, JSON.stringify(jsonValue))
    }
  },
  getJSON (key) {
    const value = this.get(key)
    if (value != null) {
      return JSON.parse(value)
    }
  },
  remove (key) {
    localStorage.removeItem(key);
  }
}

export default {
  /**
   * ä¼šè¯çº§ç¼“å­˜
   */
  session: sessionCache,
  /**
   * æœ¬åœ°ç¼“å­˜
   */
  local: localCache
}

```

