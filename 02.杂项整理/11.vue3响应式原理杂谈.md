## vue3 æ‚è°ˆ

### ä»€ä¹ˆæ˜¯ç»„ä»¶

```html
<div id="test">
  <div @click="handleClick">ğŸ®ğŸ®666</div>
  <p v-if="ifShow">{{value1}}</p>
  <p v-else>{{value2}}</p>
</div>
```

ç¼–è¯‘å

```js
const _Vue = Vue;
const {
  createElementVNode: _createElementVNode,
  createCommentVNode: _createCommentVNode,
} = _Vue;

const _hoisted_1 = ["onClick"];
const _hoisted_2 = { key: 0 };
const _hoisted_3 = { key: 1 };

return function render(_ctx, _cache) {
  with (_ctx) {
    const {
      createElementVNode: _createElementVNode,
      toDisplayString: _toDisplayString,
      openBlock: _openBlock,
      createElementBlock: _createElementBlock,
      createCommentVNode: _createCommentVNode,
      Fragment: _Fragment,
    } = _Vue;

    return (
      _openBlock(),
      _createElementBlock(
        _Fragment,
        null,
        [
          _createElementVNode(
            "div",
            { onClick: handle },
            " ğŸ®ğŸ®666 ",
            8 /* PROPS */,
            _hoisted_1
          ),
          ifShow
            ? (_openBlock(),
              _createElementBlock(
                "p",
                _hoisted_2,
                _toDisplayString(value1),
                1 /* TEXT */
              ))
            : (_openBlock(),
              _createElementBlock(
                "p",
                _hoisted_3,
                _toDisplayString(value2),
                1 /* TEXT */
              )),
        ],
        64 /* STABLE_FRAGMENT */
      )
    );
  }
};
```

#### è™šæ‹Ÿ DOM é•¿å•¥æ ·

```html
<template>
  <div>
    <div id="box1" class="test1">ç¾é£Ÿç•Œé‡Œæˆ‘è€å…«</div>
    <div id="box2" class="test2">å¤§å®¶ç§°æˆ‘ç¾é£Ÿå®¶</div>
  </div>
</template>
```

å¯¹åº”

```js
{
    tag: "div",
    props: {},
    children: [
        {
            tag: "div",
            props: {
                id: 'box1',
                class: 'test1'
            },
            children: ['ç¾é£Ÿç•Œé‡Œæˆ‘è€å…«']
        },
        {
            tag: "div",
            props: {
                id: 'box2',
                class: 'test2'
            },
            children: ['å¤§å®¶ç§°æˆ‘ç¾é£Ÿå®¶']
        }
    ]
}
```

ç²˜ä¸€æ®µå¤§ä½¬çš„åˆ†æï¼Œè§£å†³äº†ä¹‹å‰å¯¹ vue3 æºç çš„ä¸€äº›ç–‘é—®

```js
export const enum ShapeFlags {
  ELEMENT = 1, // æ™®é€šèŠ‚ç‚¹
  FUNCTIONAL_COMPONENT = 1 << 1,//2 // å‡½æ•°ç»„ä»¶
  STATEFUL_COMPONENT = 1 << 2,//4 // æ™®é€šç»„ä»¶
  TEXT_CHILDREN = 1 << 3,//8 // æ–‡æœ¬å­èŠ‚ç‚¹
  ARRAY_CHILDREN = 1 << 4,//16 // æ•°ç»„å­èŠ‚ç‚¹
  SLOTS_CHILDREN = 1 << 5,//32
  TELEPORT = 1 << 6,//64 // ä¼ é€é—¨
  SUSPENSE = 1 << 7,//128 // å¯ä»¥åœ¨ç»„ä»¶ä¸­å¼‚æ­¥
  COMPONENT_SHOULD_KEEP_ALIVE = 1 << 8,//256
  COMPONENT_KEPT_ALIVE = 1 << 9,//512// keepALIVE
  COMPONENT = ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT // 6 è¡¨ç¤ºå‡½æ•°ç»„ä»¶å’Œæ™®é€šç»„ä»¶
}
```

### å‰ç½®çŸ¥è¯†ï¼šç†è§£å‰¯ä½œç”¨

> åœ¨ç¼–ç¨‹ä¸­ï¼Œå‰¯ä½œç”¨æŒ‡çš„æ˜¯å‡½æ•°æˆ–æ“ä½œé™¤äº†è¿”å›ä¸€ä¸ªå€¼ä¹‹å¤–ï¼Œè¿˜å¯¹å¤–éƒ¨ç¯å¢ƒäº§ç”Ÿçš„å¯è§‚å¯Ÿåˆ°çš„å½±å“ã€‚è¿™äº›å½±å“å¯èƒ½åŒ…æ‹¬ä¿®æ”¹å…¨å±€å˜é‡ã€æ”¹å˜ DOMã€å‘èµ·ç½‘ç»œè¯·æ±‚ã€è®¾ç½®å®šæ—¶å™¨ç­‰ã€‚åœ¨ Vue 3 çš„å“åº”å¼ç³»ç»Ÿé‡Œï¼Œå‰¯ä½œç”¨é€šå¸¸å’Œå“åº”å¼æ•°æ®çš„å˜åŒ–ç›¸å…³è”ï¼Œå½“å“åº”å¼æ•°æ®å‘ç”Ÿå˜åŒ–æ—¶ï¼Œä¸ä¹‹ç›¸å…³çš„å‰¯ä½œç”¨å‡½æ•°ä¼šè¢«æ‰§è¡Œã€‚

1. æ¸²æŸ“è¿‡ç¨‹å¯ä»¥çœ‹ä½œæ˜¯ä¸€ç§å‰¯ä½œç”¨ã€‚
2. å¤„ç†å¼‚æ­¥æ“ä½œã€å®šæ—¶å™¨ç­‰æ“ä½œä¹Ÿå¯ä»¥çœ‹ä½œæ˜¯å‰¯ä½œç”¨ã€‚
3. æ‰§è¡Œè¿‡ç¨‹ä¸­å¯èƒ½äº§ç”Ÿã€ä¿®æ”¹çš„ã€å¤–éƒ¨å¯¹è±¡å˜é‡ã€‘æˆ–è€…ã€é—­åŒ…ã€‘ä¹Ÿå¯ä»¥çœ‹ä½œæ˜¯å‰¯ä½œç”¨ã€‚

### å“åº”å¼

```js
const obj = {
  count: 0,
};

const proxy = reactive(obj);
```

// `reactive()` æ˜¯å‘ç”¨æˆ·æš´éœ²çš„ APIï¼Œå®ƒçœŸæ­£æ‰§è¡Œçš„æ˜¯ `createReactiveObject()` å‡½æ•°

#### ç®€å•ç†è§£

> å“åº”å¼é¡ºåºï¼šreactive > effect > track > trigger > effect

> åœ¨ç»„ä»¶æ¸²æŸ“è¿‡ç¨‹ä¸­ï¼Œä¸€ä¸ª effect ä¼šä¼šè§¦å‘ getï¼Œä»è€Œå¯¹å€¼è¿›è¡Œ trackï¼Œå½“å€¼å‘ç”Ÿæ”¹å˜ï¼Œå°±ä¼šè¿›è¡Œ triggeï¼Œæ‰§è¡Œ effect æ¥å®Œæˆä¸€ä¸ªå“åº”

#### effect

> effect å‡½æ•°çš„ä¸»è¦ä½œç”¨æ˜¯åˆ›å»ºä¸€ä¸ªå‰¯ä½œç”¨å‡½æ•°ï¼Œè®°å½•å½“å‰æ­£åœ¨æ‰§è¡Œçš„å‰¯ä½œç”¨ï¼Œæ–¹ä¾¿åç»­ä¾èµ–æ”¶é›†ã€‚

```js
// activeEffect è¡¨ç¤ºå½“å‰æ­£åœ¨èµ°çš„ effect
let activeEffect = null;
export function effect(callback) {
  activeEffect = callback;
  callback();
  activeEffect = null;
}
```

##### ä½¿ç”¨ç¤ºä¾‹

```js
const state = reactive({
  count: 0,
});

// åˆ›å»ºå‰¯ä½œç”¨å‡½æ•°(æ­¤å¤„å°±æ˜¯æˆ‘ä»¬renderå‡½æ•°ä¸­è¯»getter)
effect(() => {
  console.log("å½“å‰countçš„å€¼æ˜¯:", state.count);
});

// ä¿®æ”¹å±æ€§å€¼ï¼Œè§¦å‘ä¾èµ–æ›´æ–°
state.count++;
```

##### è°ƒç”¨æ—¶æœº

1. ç»„ä»¶æ¸²æŸ“æ—¶è°ƒç”¨

> åœ¨ç»„ä»¶çš„æ¸²æŸ“è¿‡ç¨‹ä¸­ï¼Œeffect å‡½æ•°ä¼šè¢«ç”¨äºåˆ›å»ºä¸€ä¸ªå‰¯ä½œç”¨å‡½æ•°ï¼Œè¯¥å‰¯ä½œç”¨å‡½æ•°è´Ÿè´£ç»„ä»¶çš„æ¸²æŸ“é€»è¾‘ã€‚å½“ç»„ä»¶æ‰€ä¾èµ–çš„å“åº”å¼æ•°æ®å‘ç”Ÿå˜åŒ–æ—¶ï¼Œè¿™ä¸ªå‰¯ä½œç”¨å‡½æ•°ä¼šé‡æ–°æ‰§è¡Œï¼Œä»è€Œæ›´æ–°ç»„ä»¶çš„ DOMã€‚

```js
// åˆ›å»ºä¸€ä¸ªæ¸²æŸ“å‰¯ä½œç”¨å‡½æ•°
const instance = {
  // ç»„ä»¶å®ä¾‹çš„å…¶ä»–å±æ€§
};
const update = () => {
  // ç»„ä»¶æ¸²æŸ“é€»è¾‘
  const vnode = instance.render();
  // å…¶ä»–å¤„ç†é€»è¾‘
};
// åˆ›å»ºäº†ä¸€ä¸ª ReactiveEffect å®ä¾‹ï¼ˆeffect å‡½æ•°å†…éƒ¨ä¼šåˆ›å»ºè¯¥å®ä¾‹ï¼‰,å¹¶å°†ç»„ä»¶çš„æ¸²æŸ“å‡½æ•° update ä½œä¸ºå‰¯ä½œç”¨å‡½æ•°ä¼ å…¥ã€‚ç„¶åè°ƒç”¨ effect.run æ–¹æ³•æ¥é¦–æ¬¡æ‰§è¡Œæ¸²æŸ“ï¼Œ
const effect = new ReactiveEffect(update);
instance.update = effect.run.bind(effect);
// é¦–æ¬¡æ‰§è¡Œæ¸²æŸ“
instance.update();
// å½“å“åº”å¼æ•°æ®å˜åŒ–æ—¶ï¼Œä¼šè§¦å‘ effect é‡æ–°æ‰§è¡Œæ¸²æŸ“é€»è¾‘
```

2. è®¡ç®—å±æ€§ï¼ˆcomputedï¼‰ä¸­è°ƒç”¨

> æºç è¯¦æƒ…è§ä¸‹æ–‡ï¼Œåœ¨ computed å‡½æ•°å†…éƒ¨ï¼Œè°ƒç”¨ effect å‡½æ•°åˆ›å»ºäº†ä¸€ä¸ªå‰¯ä½œç”¨å‡½æ•° runnerï¼Œå¹¶è®¾ç½®ä¸º lazy æ¨¡å¼ï¼Œå³é¦–æ¬¡ä¸ä¼šç«‹å³æ‰§è¡Œã€‚å½“è®¿é—®è®¡ç®—å±æ€§çš„ value æ—¶ï¼Œå¦‚æœ dirty æ ‡å¿—ä¸º trueï¼Œåˆ™æ‰§è¡Œ runner é‡æ–°è®¡ç®—å€¼ã€‚

3. watch å‡½æ•°ä¸­è°ƒç”¨

```js
import { effect, ReactiveEffect } from "./effect";

export function watch(
  source: WatchSource | WatchSource[] | WatchEffect | object,
  cb: WatchCallback,
  options?: WatchOptions
) {
  // ...å‚æ•°å¤„ç†é€»è¾‘

  const getter = () => {
    // è·å–ç›‘å¬æ•°æ®æºçš„å€¼
    return source;
  };

  // è°ƒåº¦å™¨ schedulerã€‚å½“ç›‘å¬çš„æ•°æ®å‘ç”Ÿå˜åŒ–æ—¶ï¼Œè°ƒåº¦å™¨ä¼šæ‰§è¡Œå›è°ƒå‡½æ•° cb
  const scheduler = () => {
    // æ•°æ®å˜åŒ–æ—¶çš„è°ƒåº¦é€»è¾‘ï¼Œæ‰§è¡Œå›è°ƒå‡½æ•°
    cb(newValue, oldValue);
  };

  // åˆ›å»ºä¸€ä¸ª ReactiveEffect å®ä¾‹ï¼Œå°†è·å–ç›‘å¬æ•°æ®æºå€¼çš„å‡½æ•° getter ä½œä¸ºå‰¯ä½œç”¨å‡½æ•°ä¼ å…¥ï¼Œ
  const effect = new ReactiveEffect(getter, scheduler);

  // é¦–æ¬¡æ‰§è¡Œè·å–åˆå§‹å€¼
  const initialValue = effect.run();
  let oldValue = initialValue;

  return () => {
    // åœæ­¢ç›‘å¬
    effect.stop();
  };
}
```

#### track

> track å‡½æ•°ç”¨äºè¿½è¸ªæ•°æ®çš„ä¾èµ–å…³ç³»ã€‚å½“è¯»å–ä¸€ä¸ªå“åº”å¼æ•°æ®æ—¶ï¼Œtrack å‡½æ•°ä¼šè¢«è°ƒç”¨ï¼Œå®ƒä¼šè®°å½•å½“å‰æ­£åœ¨è¯»å–æ•°æ®çš„å‰¯ä½œç”¨å‡½æ•°ï¼ˆé€šå¸¸æ˜¯ä¸€ä¸ªç»„ä»¶çš„æ¸²æŸ“å‡½æ•°æˆ–è®¡ç®—å±æ€§çš„å‡½æ•°ï¼‰ï¼Œä»¥ä¾¿åœ¨æ•°æ®å˜åŒ–æ—¶èƒ½å¤Ÿé€šçŸ¥è¿™äº›å‰¯ä½œç”¨å‡½æ•°è¿›è¡Œæ›´æ–°ã€‚

- é¦–å…ˆï¼Œtrack å‡½æ•°ä¼šè·å–å½“å‰çš„å‰¯ä½œç”¨å‡½æ•°æ ˆï¼ˆé€šè¿‡ä¸€ä¸ªå…¨å±€å˜é‡å­˜å‚¨ï¼‰ï¼Œå¹¶è·å–å½“å‰æ­£åœ¨è¯»å–çš„å“åº”å¼æ•°æ®çš„ä¾èµ–æ”¶é›†å™¨ï¼ˆdepsMapï¼‰ã€‚
- å¦‚æœä¾èµ–æ”¶é›†å™¨ä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»ºä¸€ä¸ªæ–°çš„ Set ä½œä¸ºä¾èµ–æ”¶é›†å™¨ï¼Œå¹¶å°†å…¶å­˜å‚¨åœ¨å“åº”å¼æ•°æ®çš„ depsMap ä¸­ã€‚
- ç„¶åï¼Œå°†å½“å‰çš„å‰¯ä½œç”¨å‡½æ•°æ·»åŠ åˆ°ä¾èµ–æ”¶é›†å™¨ä¸­ã€‚è¿™æ ·ï¼Œå°±å»ºç«‹äº†å“åº”å¼æ•°æ®å’Œå‰¯ä½œç”¨å‡½æ•°ä¹‹é—´çš„ä¾èµ–å…³ç³»ã€‚

```js
// targetMap è¡¨é‡Œæ¯ä¸ªkeyéƒ½æ˜¯ä¸€ä¸ªæ™®é€šå¯¹è±¡ å¯¹åº”ä»–ä»¬çš„ depsMap
let targetMap = new WeakMap();
/*
  targetMap = {}
*/
export function track(target, key) {
  /*
    const details = reactive({
      message: 'hello',
      name: 'Awen'
    })
    target = details

    å‡è®¾æˆ‘ä»¬æ­¤æ—¶è¯»çš„key æ˜¯ message
  */
  // å¦‚æœå½“å‰æ²¡æœ‰effectå°±ä¸æ‰§è¡Œè¿½è¸ª
  if (!activeEffect) return;
  // è·å–å½“å‰å¯¹è±¡çš„ä¾èµ–å›¾
  let depsMap = targetMap.get(target);
  /*
    æ­¤æ—¶targetMap ä¸º {}
    targetMap.get(details)ä¸ºç©ºï¼Œå³depsMapä¸ºç©º
  */
  // ä¸å­˜åœ¨å°±æ–°å»º
  if (!depsMap) {
    depsMap = new Map();
    /*
      æ­¤æ—¶depsMap = {}
    */
    targetMap.set(target, depsMap);
  }
  /*
    depsMap = {}
    targetMap = {
      details: depsMap
    }
  */

  // æ ¹æ®key ä» ä¾èµ–å›¾ é‡Œè·å–åˆ°åˆ° effect é›†åˆ
  let dep = depsMap.get(key);
  /*
    depsMapæ­¤æ—¶ä¸º{}ï¼Œæ‰§è¡Œ.get('message')ä¸ºç©º
    å³depä¸ºç©º
  */
  // ä¸å­˜åœ¨å°±æ–°å»º
  if (!dep) {
    dep = new Set();
    depsMap.set(key, dep);
    /*
    æ­¤æ—¶
    dep = [] // çš„å‚¨å­˜ä¾èµ–

    depsMap = {
      message: dep // æ¯ä¸ªkeyå¯¹åº”å„è‡ªçš„ä¾èµ– 
    }

    targetMap = {
      details: depsMap // å½“å‰ä»£ç†å¯¹è±¡çš„æ‰€æœ‰çš„  key -> effect é›†åˆ
    }

    å³

    targetMap = {
      details: {
        message: []
      } 
    }
    */
  }
  // å¦‚æœå½“å‰effectc ä¸å­˜åœ¨ï¼Œæ‰æ³¨å†Œåˆ° depé‡Œ
  if (!dep.has(activeEffect)) {
    dep.add(activeEffect);
  }
}
```

#### trigger

> trigger å‡½æ•°ç”¨äºè§¦å‘å“åº”å¼æ•°æ®çš„æ›´æ–°ã€‚å½“ä¿®æ”¹ä¸€ä¸ªå“åº”å¼æ•°æ®æ—¶ï¼Œtrigger å‡½æ•°ä¼šè¢«è°ƒç”¨ï¼Œå®ƒä¼šéå†ä¸è¯¥æ•°æ®ç›¸å…³çš„æ‰€æœ‰å‰¯ä½œç”¨å‡½æ•°ï¼Œå¹¶æ‰§è¡Œå®ƒä»¬ï¼Œä»è€Œå®ç°è§†å›¾çš„æ›´æ–°æˆ–å…¶ä»–å“åº”å¼æ“ä½œã€‚

- é¦–å…ˆï¼Œtrigger å‡½æ•°ä¼šè·å–å“åº”å¼æ•°æ®çš„ä¾èµ–æ”¶é›†å™¨ï¼ˆdepsMapï¼‰ã€‚
- ç„¶åï¼Œéå†ä¾èµ–æ”¶é›†å™¨ä¸­çš„æ‰€æœ‰å‰¯ä½œç”¨å‡½æ•°ï¼Œå¹¶æ‰§è¡Œå®ƒä»¬ã€‚
- åœ¨æ‰§è¡Œå‰¯ä½œç”¨å‡½æ•°ä¹‹å‰ï¼Œä¼šå°†å½“å‰çš„å‰¯ä½œç”¨å‡½æ•°æ ‡è®°ä¸ºæ­£åœ¨æ‰§è¡Œï¼Œä»¥é¿å…æ— é™å¾ªç¯çš„æ›´æ–°ã€‚

```js
// trigger å“åº”å¼è§¦å‘
export function trigger(target, key) {
  // æ‹¿åˆ° ä¾èµ–å›¾
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    // æ²¡æœ‰è¢«è¿½è¸ªï¼Œç›´æ¥ return
    return;
  }
  // æ‹¿åˆ°äº† è§†å›¾æ¸²æŸ“effect å°±å¯ä»¥è¿›è¡Œæ’é˜Ÿæ›´æ–° effect äº†
  const dep = depsMap.get(key);

  // éå† dep é›†åˆæ‰§è¡Œé‡Œé¢ effect å‰¯ä½œç”¨æ–¹æ³•
  if (dep) {
    dep.forEach((effect) => {
      effect();
    });
  }
}
```

### æºç åˆ†æ

#### createReactiveObject

```typescript
function createReactiveObject(
  target: Target,
  isReadonly: boolean,
  baseHandlers: ProxyHandler<any>,
  collectionHandlers: ProxyHandler<any>
) {
  if (!isObject(target)) {
    // æ˜¯å¦æ˜¯å¯¹è±¡
    if (__DEV__) {
      console.warn(`value cannot be made reactive: ${String(target)}`);
    }
    return target;
  }

  // target is already a Proxy, return it. å·²ç»æ˜¯å“åº”å¼æ‹‰ï¼Œå°±ç›´æ¥è¿”å›
  // exception: calling readonly() on a reactive object
  if (
    target[ReactiveFlags.raw] &&
    !(isReadonly && target[ReactiveFlags.isReactive])
  ) {
    return target;
  }
  // target already has corresponding Proxy å·²ç»è¢«ä»£ç†äº†
  if (
    hasOwn(target, isReadonly ? ReactiveFlags.readonly : ReactiveFlags.reactive)
  ) {
    return isReadonly
      ? target[ReactiveFlags.readonly]
      : target[ReactiveFlags.reactive];
  }
  // only a whitelist of value types can be observed. ä¸å¯è¢«è§‚å¯ŸğŸ•µ
  if (!canObserve(target)) {
    return target;
  }

  const observed = new Proxy(
    target,
    // æ˜¯æ™®é€šçš„å¯¹è±¡ Object æˆ– Arrayï¼Œå¤„ç†å™¨å¯¹è±¡å°±ä½¿ç”¨ baseHandlersï¼›å¦‚æœæ˜¯ Set, Map, WeakMap, WeakSet ä¸­çš„ä¸€ä¸ªï¼Œå°±ä½¿ç”¨collectionHandlersã€‚
    collectionTypes.has(target.constructor) ? collectionHandlers : baseHandlers
  );
  def(
    target,
    isReadonly ? ReactiveFlags.readonly : ReactiveFlags.reactive, // æ˜¯å¦åªè¯»
    observed
  );

  return observed;
}
```

#### baseHandlers

```typescript
import {
  reactive,
  readonly,
  toRaw,
  ReactiveFlags,
  Target,
  readonlyMap,
  reactiveMap,
  shallowReactiveMap,
  shallowReadonlyMap,
  isReadonly,
  isShallow,
} from "./reactive";
import { TrackOpTypes, TriggerOpTypes } from "./operations";
import {
  track,
  trigger,
  ITERATE_KEY,
  pauseTracking,
  resetTracking,
} from "./effect";
import {
  isObject,
  hasOwn,
  isSymbol,
  hasChanged,
  isArray,
  isIntegerKey,
  extend,
  makeMap,
} from "@vue/shared";
import { isRef } from "./ref";

const isNonTrackableKeys = /*#__PURE__*/ makeMap(`__proto__,__v_isRef,__isVue`);

const builtInSymbols = new Set(
  Object.getOwnPropertyNames(Symbol)
    .map((key) => (Symbol as any)[key])
    .filter(isSymbol)
);
// /*#__PURE__*/ æ ‡è¯†æ­¤ä¸ºçº¯å‡½æ•° ä¸ä¼šæœ‰å‰¯ä½œç”¨ æ–¹ä¾¿åš tree-shaking
const get = /*#__PURE__*/ createGetter();
const shallowGet = /*#__PURE__*/ createGetter(false, true);
const readonlyGet = /*#__PURE__*/ createGetter(true);
const shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);

const arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations();

function createArrayInstrumentations() {
  const instrumentations: Record<string, Function> = {};
  // instrument identity-sensitive Array methods to account for possible reactive
  /*
instrument
n.
å™¨æ¢°;ä»ªå™¨;å™¨å…·;(è½¦è¾†ã€æœºå™¨çš„)ä»ªå™¨ï¼Œä»ªè¡¨;ä¿ƒæˆæŸäº‹çš„äºº(æˆ–äº‹ç‰©);æ‰‹æ®µ;å—åˆ©ç”¨ï¼ˆæˆ–æ§åˆ¶ï¼‰çš„äºº;æ–‡æ®
v.
ç”¨ä»ªå™¨è£…å¤‡ï¼›ä¸ºç®¡å¼¦ä¹é˜Ÿç¼–(æ›²)ï¼›å‘â€¦æäº¤æ³•å¾‹æ–‡ä»¶

ä¸€äº›æ•æ„Ÿçš„æ•°ç»„æ–¹æ³•å¯èƒ½é€ æˆå“åº”å¼

'includes', 'indexOf', 'lastIndexOf' è¢«é‡å†™åŠ ä»¥ç›‘å¬
*/
  // values
  (["includes", "indexOf", "lastIndexOf"] as const).forEach((key) => {
    /*
      åœ¨æ­¤å¤„è°ƒç”¨è¯¥å‡½æ•°
        if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {
          return Reflect.get(arrayInstrumentations, key, receiver)
        }
        å¦‚æœ target å¯¹è±¡ä¸­æŒ‡å®šäº† getterï¼Œreceiver åˆ™ä¸º getter è°ƒç”¨æ—¶çš„ this å€¼ã€‚æ‰€ä»¥è¿™é‡Œçš„ this æŒ‡å‘ receiverï¼Œå³ proxy å®ä¾‹
      */
    instrumentations[key] = function (this: unknown[], ...args: unknown[]) {
      const arr = toRaw(this) as any;
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, TrackOpTypes.GET, i + ""); // æ”¶é›†ä¾èµ–
      }
      // we run the method using the original args first (which may be reactive)
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        // if that didn't work, run it again using raw values.
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  // instrument length-altering mutation methods to avoid length being tracked
  // which leads to infinite loops in some cases (#2137)
  // é‡å†™ä¸€äº›æ–¹æ³•ï¼Œå“åº”å¼è¿½è¸ª
  (["push", "pop", "shift", "unshift", "splice"] as const).forEach((key) => {
    instrumentations[key] = function (this: unknown[], ...args: unknown[]) {
      pauseTracking(); // æš‚åœå“åº”å¼è¿½è¸ª
      const res = (toRaw(this) as any)[key].apply(this, args); // åº”ç”¨æºæ•°æ®
      resetTracking(); // é‡æ–°è¿›è¡Œå“åº”å¼è¿½è¸ª
      return res;
    };
  });
  return instrumentations;
}

function createGetter(isReadonly = false, shallow = false) {
  return function get(target: Target, key: string | symbol, receiver: object) {
    if (key === ReactiveFlags.IS_REACTIVE) {
      return !isReadonly;
    } else if (key === ReactiveFlags.IS_READONLY) {
      return isReadonly;
    } else if (key === ReactiveFlags.IS_SHALLOW) {
      return shallow;
    } else if (
      key === ReactiveFlags.RAW &&
      receiver ===
        (isReadonly
          ? shallow
            ? shallowReadonlyMap
            : readonlyMap
          : shallow
          ? shallowReactiveMap
          : reactiveMap
        ).get(target)
    ) {
      return target;
    }

    // å¦‚æœ target æ˜¯æ•°ç»„å¹¶ä¸” key å±äºä¸‰ä¸ªæ–¹æ³•ä¹‹ä¸€ ['includes', 'indexOf', 'lastIndexOf']ï¼Œå³è§¦å‘äº†è¿™ä¸‰ä¸ªæ“ä½œä¹‹ä¸€
    const targetIsArray = isArray(target);
    // ä¸Šé—¨çš„åˆ¤æ–­ç»“æœå°†ä¸!isReadonly && hasOwn(arrayInstrumentations, key)ï¼ŒåŒæ—¶è§¦å‘Reflect.getï¼ˆï¼‰ï¼Œ
    if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {
      return Reflect.get(arrayInstrumentations, key, receiver);
    }
    // ä¸ç®¡Proxyæ€ä¹ˆä¿®æ”¹é»˜è®¤è¡Œä¸ºï¼Œæ€»å¯ä»¥åœ¨Reflectä¸Šè·å–é»˜è®¤è¡Œä¸ºã€‚
    // å³æ˜¯æˆ‘ä»¬ä¿®æ”¹äº†proxyä¸Šçš„æ–¹æ³•ï¼Œåœ¨è¿™é‡Œä»ç„¶å°†è§¦å‘åŸæ¥çš„è¡Œä¸º
    // æ‹“å±•ï¼š Reflect.getä½¿ç”¨å‡½æ•°å½¢å¼æ¥è¯»å–å€¼
    const res = Reflect.get(target, key, receiver);

    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }

    if (!isReadonly) {
      track(target, TrackOpTypes.GET, key);
    }

    if (shallow) {
      return res;
    }

    if (isRef(res)) {
      // ref unwrapping - does not apply for Array + integer key.
      const shouldUnwrap = !targetIsArray || !isIntegerKey(key);
      return shouldUnwrap ? res.value : res;
    }

    if (isObject(res)) {
      // Convert returned value into a proxy as well. we do the isObject check
      // here to avoid invalid value warning. Also need to lazy access readonly
      // and reactive here to avoid circular dependency.
      // é€’å½’æ·±å±‚ä»£ç†æ¯ä¸€ä¸ªå€¼ï¼ˆæˆ‘ä»¬ä½¿ç”¨const list = relative([])æ—¶ï¼Œvue3å°†ä»£ç†æ•°ç»„æ¯ä¸€å±‚çš„å€¼ï¼‰
      return isReadonly ? readonly(res) : reactive(res);
    }

    return res;
  };
}

const set = /*#__PURE__*/ createSetter();
const shallowSet = /*#__PURE__*/ createSetter(true);

function createSetter(shallow = false) {
  return function set(
    target: object,
    key: string | symbol,
    value: unknown,
    receiver: object
  ): boolean {
    let oldValue = (target as any)[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!shallow && !isReadonly(value)) {
      if (!isShallow(value)) {
        value = toRaw(value);
        oldValue = toRaw(oldValue);
      }
      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    } else {
      // in shallow mode, objects are set as-is regardless of reactive or not
    }

    const hadKey =
      isArray(target) && isIntegerKey(key)
        ? Number(key) < target.length
        : hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    // don't trigger if target is something up in the prototype chain of original
    // ä¸å¯¹è‡ªèº«åŸå‹ä¸Šçš„å±æ€§è¿›è¡Œä¾èµ–è¿½è¸ª
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        // å¦‚æœ target æ²¡æœ‰ keyï¼Œå°±ä»£è¡¨æ˜¯æ–°å¢æ“ä½œï¼Œéœ€è¦è§¦å‘ä¾èµ–
        trigger(target, TriggerOpTypes.ADD, key, value);
      } else if (hasChanged(value, oldValue)) {
        // å¦‚æœæ–°æ—§å€¼ä¸ç›¸ç­‰ï¼Œæ‰è§¦å‘ä¾èµ–
        trigger(target, TriggerOpTypes.SET, key, value, oldValue);
      }
    }
    return result;
  };
}

function deleteProperty(target: object, key: string | symbol): boolean {
  const hadKey = hasOwn(target, key);
  const oldValue = (target as any)[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue);
  }
  return result;
}

function has(target: object, key: string | symbol): boolean {
  const result = Reflect.has(target, key);
  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target, TrackOpTypes.HAS, key);
  }
  return result;
}

function ownKeys(target: object): (string | symbol)[] {
  track(target, TrackOpTypes.ITERATE, isArray(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}

export const mutableHandlers: ProxyHandler<object> = {
  get,
  set,
  deleteProperty,
  has,
  ownKeys,
};

export const readonlyHandlers: ProxyHandler<object> = {
  get: readonlyGet,
  set(target, key) {
    if (__DEV__) {
      console.warn(
        `Set operation on key "${String(key)}" failed: target is readonly.`,
        target
      );
    }
    return true;
  },
  deleteProperty(target, key) {
    if (__DEV__) {
      console.warn(
        `Delete operation on key "${String(key)}" failed: target is readonly.`,
        target
      );
    }
    return true;
  },
};

export const shallowReactiveHandlers = /*#__PURE__*/ extend(
  {},
  mutableHandlers,
  {
    get: shallowGet,
    set: shallowSet,
  }
);

// Props handlers are special in the sense that it should not unwrap top-level
// refs (in order to allow refs to be explicitly passed down), but should
// retain the reactivity of the normal readonly object.
// å¯¹äºpropsé¢å¤–å¤„ç†ï¼Œä»–ä¸æ˜¯å“åº”å¼è§£æ„ï¼Œä½†æ˜¯æ˜¯å“åº”å¼çš„è¯»å–
export const shallowReadonlyHandlers = /*#__PURE__*/ extend(
  {},
  readonlyHandlers,
  {
    get: shallowReadonlyGet,
  }
);
```

#### effect()

```typescript
import { TrackOpTypes, TriggerOpTypes } from "./operations";
import { extend, isArray, isIntegerKey, isMap } from "@vue/shared";
import { EffectScope, recordEffectScope } from "./effectScope";
import {
  createDep,
  Dep,
  finalizeDepMarkers,
  initDepMarkers,
  newTracked,
  wasTracked,
} from "./dep";
import { ComputedRefImpl } from "./computed";

// The main WeakMap that stores {target -> key -> dep} connections.
// Conceptually, it's easier to think of a dependency as a Dep class
// which maintains a Set of subscribers, but we simply store them as
// raw Sets to reduce memory overhead.
type KeyToDepMap = Map<any, Dep>;
const targetMap = new WeakMap<any, KeyToDepMap>();

// The number of effects currently being tracked recursively.
let effectTrackDepth = 0;

export let trackOpBit = 1;

/**
 * The bitwise track markers support at most 30 levels of recursion.
 * This value is chosen to enable modern JS engines to use a SMI on all platforms.
 * When recursion depth is greater, fall back to using a full cleanup.
 */
const maxMarkerBits = 30;

export type EffectScheduler = (...args: any[]) => any;

export type DebuggerEvent = {
  effect: ReactiveEffect;
} & DebuggerEventExtraInfo;

export type DebuggerEventExtraInfo = {
  target: object;
  type: TrackOpTypes | TriggerOpTypes;
  key: any;
  newValue?: any;
  oldValue?: any;
  oldTarget?: Map<any, any> | Set<any>;
};

export let activeEffect: ReactiveEffect | undefined;

export const ITERATE_KEY = Symbol(__DEV__ ? "iterate" : "");
export const MAP_KEY_ITERATE_KEY = Symbol(__DEV__ ? "Map key iterate" : "");

export class ReactiveEffect<T = any> {
  active = true;
  deps: Dep[] = [];
  parent: ReactiveEffect | undefined = undefined;

  /**
   * Can be attached after creation
   * @internal
   */
  computed?: ComputedRefImpl<T>;
  /**
   * @internal
   */
  allowRecurse?: boolean;

  onStop?: () => void;
  // dev only
  onTrack?: (event: DebuggerEvent) => void;
  // dev only
  onTrigger?: (event: DebuggerEvent) => void;

  constructor(
    public fn: () => T,
    public scheduler: EffectScheduler | null = null,
    scope?: EffectScope // å…è®¸é‡å†™ä¾èµ–è¿½è¸ªå’Œæ”¶é›†
  ) {
    recordEffectScope(this, scope); // æ”¶é›†ä¾èµ–
  }

  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent: ReactiveEffect | undefined = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    // åœ¨å½“å‰æ‰€æœ‰æ´»è·ƒçš„ä¾èµ–ä¸­æŒ‘å‡ºæ˜¯å½“å‰å®ä¾‹çš„ä¾èµ–
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;

      trackOpBit = 1 << ++effectTrackDepth;
      // ä¾èµ–æœ€æ·±æ”¶å½•åˆ°30å±‚ï¼Œ
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }

      trackOpBit = 1 << --effectTrackDepth;

      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = undefined;
    }
  }

  stop() {
    if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}

// è®© effect å…³è”ä¸‹çš„æ‰€æœ‰ dep å®ä¾‹æ¸…ç©º effectï¼Œå³æ¸…é™¤è¿™ä¸ªä¾èµ–å‡½æ•°ã€‚
function cleanupEffect(effect: ReactiveEffect) {
  const { deps } = effect;
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect);
    }
    deps.length = 0;
  }
}

export interface DebuggerOptions {
  onTrack?: (event: DebuggerEvent) => void;
  onTrigger?: (event: DebuggerEvent) => void;
}

export interface ReactiveEffectOptions extends DebuggerOptions {
  lazy?: boolean; // å»¶è¿Ÿè®¡ç®—ï¼Œä¸ºtrueæ—¶å€™ï¼Œä¼ å…¥çš„effectä¸ä¼šç«‹å³æ‰§è¡Œã€‚
  scheduler?: EffectScheduler; // è°ƒåº¦å™¨å‡½æ•°ï¼Œæ¥å—çš„å…¥å‚runå³æ˜¯ä¼ ç»™effectçš„å‡½æ•°ï¼Œå¦‚æœä¼ äº†schedulerï¼Œåˆ™å¯é€šè¿‡å…¶è°ƒç”¨ç›‘å¬å‡½æ•°ã€‚
  scope?: EffectScope;
  // æ­¤å¤„æŸ¥çœ‹https://v3.cn.vuejs.org/api/effect-scope.html#effectscopeï¼Œå°±çŸ¥é“è¿™ä¸ªé…ç½®é¡¹æ˜¯ä»€ä¹ˆäº†ï¼Œä¸ºä»€ä¹ˆè¦æŠŠè¿™ä¸€å—æå–å‡ºæ¥
  allowRecurse?: boolean;
  onStop?: () => void; // è°ƒåº¦å™¨å‡½æ•°ï¼Œæ¥å—çš„å…¥å‚runå³æ˜¯ä¼ ç»™effectçš„å‡½æ•°ï¼Œå¦‚æœä¼ äº†schedulerï¼Œåˆ™å¯é€šè¿‡å…¶è°ƒç”¨ç›‘å¬å‡½æ•°ã€‚
}

export interface ReactiveEffectRunner<T = any> {
  (): T;
  effect: ReactiveEffect;
}

export function effect<T = any>(
  fn: () => T,
  options?: ReactiveEffectOptions
): ReactiveEffectRunner {
  // å¦‚æœè¯¥å‡½æ•°å·²ç»æ˜¯ç›‘å¬å‡½æ•°äº†ï¼Œé‚£èµ‹å€¼fnä¸ºè¯¥å‡½æ•°çš„åŸå§‹å‡½æ•°
  if ((fn as ReactiveEffectRunner).effect) {
    fn = (fn as ReactiveEffectRunner).effect.fn;
  }
  // åˆ›å»º effect
  const _effect = new ReactiveEffect(fn);
  if (options) {
    extend(_effect, options);
    if (options.scope) recordEffectScope(_effect, options.scope);
  }
  if (!options || !options.lazy) {
    // å¦‚æœä¸æ˜¯å»¶è¿Ÿæ‰§è¡Œçš„è¯ï¼Œç«‹å³æ‰§è¡Œä¸€æ¬¡
    _effect.run();
  }
  const runner = _effect.run.bind(_effect) as ReactiveEffectRunner;
  runner.effect = _effect;
  return runner;
}

export function stop(runner: ReactiveEffectRunner) {
  runner.effect.stop();
}

export let shouldTrack = true;
const trackStack: boolean[] = [];

export function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}

export function enableTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = true;
}

export function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === undefined ? true : last;
}

export function track(target: object, type: TrackOpTypes, key: unknown) {
  if (shouldTrack && activeEffect) {
    // å½“å‰å®ä¾‹ä¾èµ–å­˜åœ¨ä¸”å…è®¸æ”¶é›†ä¾èµ–
    let depsMap = targetMap.get(target); // targetMap ä¾èµ–ç®¡ç†ä¸­å¿ƒï¼Œç”¨äºæ”¶é›†ä¾èµ–å’Œè§¦å‘ä¾èµ–
    if (!depsMap) {
      targetMap.set(target, (depsMap = new Map()));
    }
    // æ‘˜æŠ„ä¸€æ®µå¤§ä½¬çš„ï¼Œ
    // targetMap ä¸ºæ¯ä¸ª target å»ºç«‹ä¸€ä¸ª map
    // æ¯ä¸ª target çš„ key å¯¹åº”ç€ä¸€ä¸ª dep
    // ç„¶åç”¨ dep æ¥æ”¶é›†ä¾èµ–å‡½æ•°ï¼Œå½“ç›‘å¬çš„ key å€¼å‘ç”Ÿå˜åŒ–æ—¶ï¼Œè§¦å‘ dep ä¸­çš„ä¾èµ–å‡½æ•°
    // ç±»ä¼¼äºè¿™æ ·
    // targetMap(weakmap) = {
    //     target1(map): {
    //       key1(dep): (fn1,fn2,fn3...)
    //       key2(dep): (fn1,fn2,fn3...)
    //     },
    //     target2(map): {
    //       key1(dep): (fn1,fn2,fn3...)
    //       key2(dep): (fn1,fn2,fn3...)
    //     },
    // }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, (dep = createDep()));
    }
    // devç¯å¢ƒä¸€äº›é…ç½®
    const eventInfo = __DEV__
      ? { effect: activeEffect, target, type, key }
      : undefined;

    trackEffects(dep, eventInfo);
  }
}

export function trackEffects(
  dep: Dep,
  debuggerEventExtraInfo?: DebuggerEventExtraInfo
) {
  let shouldTrack = false;
  if (effectTrackDepth <= maxMarkerBits) {
    // åœ¨æœ€å¤§ä¾èµ–é™åº¦ä¹‹å†…
    if (!newTracked(dep)) {
      dep.n |= trackOpBit; // set newly tracked
      shouldTrack = !wasTracked(dep);
    }
  } else {
    // Full cleanup mode.
    shouldTrack = !dep.has(activeEffect!);
  }
  // ä¸Šé¢åœ¨åšä»€ä¹ˆå•Šï¼Œï¼ˆ|= ä½è¿ç®—ï¼‰æ„æ€ä¸ºï¼šæŒ‰ä½æˆ–åèµ‹å€¼ï¼Œ
  // æä¸æ¸…æ¥šï¼Œåº”è¯¥æ˜¯å¤„ç†ä¸€äº›å‡å¦‚ä¸å…è®¸æ”¶é›†ä¾èµ–çš„æƒ…å†µ

  if (shouldTrack) {
    dep.add(activeEffect!);
    activeEffect!.deps.push(dep);
    // devç¯å¢ƒæ‰§è¡ŒonTrack()
    if (__DEV__ && activeEffect!.onTrack) {
      activeEffect!.onTrack(
        Object.assign(
          {
            effect: activeEffect!,
          },
          debuggerEventExtraInfo
        )
      );
    }
  }
}

export function trigger(
  target: object,
  type: TriggerOpTypes,
  key?: unknown,
  newValue?: unknown,
  oldValue?: unknown,
  oldTarget?: Map<unknown, unknown> | Set<unknown>
) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    // never been tracked å¦‚æœæ²¡æœ‰æ”¶é›†è¿‡ä¾èµ–ï¼Œç›´æ¥è¿”å›
    return;
  }

  /*
    track çš„ç±»å‹
    export const enum TrackOpTypes {
      GET = 'get', // get æ“ä½œ
      HAS = 'has', // has æ“ä½œ
      ITERATE = 'iterate' // ownKeys æ“ä½œ
    }

    trigger çš„ç±»å‹
    export const enum TriggerOpTypes {
      SET = 'set', // è®¾ç½®æ“ä½œï¼Œå°†æ—§å€¼è®¾ç½®ä¸ºæ–°å€¼
      ADD = 'add', // æ–°å¢æ“ä½œï¼Œæ·»åŠ ä¸€ä¸ªæ–°çš„å€¼ ä¾‹å¦‚ç»™å¯¹è±¡æ–°å¢ä¸€ä¸ªå€¼ æ•°ç»„çš„ push æ“ä½œ
      DELETE = 'delete', // åˆ é™¤æ“ä½œ ä¾‹å¦‚å¯¹è±¡çš„ delete æ“ä½œï¼Œæ•°ç»„çš„ pop æ“ä½œ
      CLEAR = 'clear' // ç”¨äº Map å’Œ Set çš„ clear æ“ä½œã€‚
    }
    */
  let deps: (Dep | undefined)[] = [];
  if (type === TriggerOpTypes.CLEAR) {
    // collection being cleared
    // trigger all effects for target
    // åœ¨å€¼è¢«æ¸…ç©ºå‰ï¼Œå¾€ç›¸åº”çš„é˜Ÿåˆ—æ·»åŠ  target æ‰€æœ‰çš„ä¾èµ–,æ¸…é™¤é›†åˆå°†è§¦å‘ç›®æ ‡çš„æ‰€æœ‰æ•ˆæœ
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray(target)) {
    // å½“æ•°ç»„çš„ length å±æ€§å˜åŒ–æ—¶è§¦å‘
    depsMap.forEach((dep, key) => {
      if (key === "length" || key >= (newValue as number)) {
        deps.push(dep);
      }
    });
  } else {
    // schedule runs for SET | ADD | DELETE
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }

    // also run for iteration key on ADD | DELETE | Map.SET
    switch (type) {
      case TriggerOpTypes.ADD:
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          // new index added to array -> length changes
          deps.push(depsMap.get("length")); // lengthæ”¹å˜ä¹Ÿå°†æ·»åŠ åˆ°ä¾èµ–
        }
        break;
      case TriggerOpTypes.DELETE:
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case TriggerOpTypes.SET:
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }

  const eventInfo = __DEV__
    ? { target, type, key, newValue, oldValue, oldTarget }
    : undefined;

  if (deps.length === 1) {
    if (deps[0]) {
      if (__DEV__) {
        triggerEffects(deps[0], eventInfo);
      } else {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects: ReactiveEffect[] = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    if (__DEV__) {
      triggerEffects(createDep(effects), eventInfo);
    } else {
      triggerEffects(createDep(effects));
    }
  }
}

export function triggerEffects(
  dep: Dep | ReactiveEffect[],
  debuggerEventExtraInfo?: DebuggerEventExtraInfo
) {
  // spread into array for stabilization
  for (const effect of isArray(dep) ? dep : [...dep]) {
    if (effect !== activeEffect || effect.allowRecurse) {
      if (__DEV__ && effect.onTrigger) {
        effect.onTrigger(extend({ effect }, debuggerEventExtraInfo));
      }
      if (effect.scheduler) {
        effect.scheduler();
      } else {
        effect.run();
      }
    }
  }
}
```

#### effectScope(å¯çœ‹å¯ä¸çœ‹)

```typescript
import { ReactiveEffect } from "./effect";
import { warn } from "./warning";

let activeEffectScope: EffectScope | undefined;

export class EffectScope {
  active = true;
  effects: ReactiveEffect[] = [];
  cleanups: (() => void)[] = [];

  parent: EffectScope | undefined;
  scopes: EffectScope[] | undefined;
  /**
   * track a child scope's index in its parent's scopes array for optimized
   * removal
   */
  private index: number | undefined;

  constructor(detached = false) {
    if (!detached && activeEffectScope) {
      this.parent = activeEffectScope;
      this.index =
        (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
          this
        ) - 1;
    }
  }

  run<T>(fn: () => T): T | undefined {
    if (this.active) {
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = this.parent;
      }
    } else if (__DEV__) {
      warn(`cannot run an inactive effect scope.`);
    }
  }

  on() {
    activeEffectScope = this;
  }

  off() {
    activeEffectScope = this.parent;
  }

  stop(fromParent?: boolean) {
    if (this.active) {
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
      }
      // nested scope, dereference from parent to avoid memory leaks
      if (this.parent && !fromParent) {
        // optimized O(1) removal
        const last = this.parent.scopes!.pop();
        if (last && last !== this) {
          this.parent.scopes![this.index!] = last;
          last.index = this.index!;
        }
      }
      this.active = false;
    }
  }
}

export function effectScope(detached?: boolean) {
  return new EffectScope(detached);
}

export function recordEffectScope(
  effect: ReactiveEffect,
  scope: EffectScope | undefined = activeEffectScope
) {
  if (scope && scope.active) {
    scope.effects.push(effect);
  }
}

export function getCurrentScope() {
  return activeEffectScope;
}

export function onScopeDispose(fn: () => void) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  } else if (__DEV__) {
    warn(
      `onScopeDispose() is called when there is no active effect scope` +
        ` to be associated with.`
    );
  }
}
```

#### ref å’Œ reactive å·®ä¸å¤šï¼Œå¤§å·®ä¸å·®

```typescript
function createRef(rawValue: unknown, shallow: boolean) {
  if (isRef(rawValue)) {
    // å¦‚æœç›´æ¥æ˜¯refï¼Œå°±ç›´æ¥è¿”å›å•¥ä¹Ÿä¸å¹²
    return rawValue;
  }
  return new RefImpl(rawValue, shallow); // newä¸€ä¸ªæ–°çš„ref
}
// çœŸæ­£åˆ›å»ºref
class RefImpl<T> {
  private _value: T;
  private _rawValue: T;

  public dep?: Dep = undefined;
  public readonly __v_isRef = true; // æ ‡è¯†ä¸ºrefå¯¹è±¡

  constructor(value: T, public readonly __v_isShallow: boolean) {
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }

  // get set åˆ†åˆ«è¿›è¡Œä¾èµ–æ”¶é›†ä¸è¿½è¸ª
  get value() {
    trackRefValue(this); // è¿½è¸ª
    return this._value; // è¿”å›å€¼ï¼ˆç±»ä¼¼äºrelativeï¼‰
  }

  set value(newVal) {
    // ........
    newVal = this.__v_isShallow ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = this.__v_isShallow ? newVal : toReactive(newVal);
      triggerRefValue(this, newVal); // æ”¶é›†
    }
  }
  /*
  getå…ˆè¿½å†è¿”å›
  setå…ˆè®¾ç½®å†æ”¶é›†ï¼Œï¼ˆè®¾ç½®å®Œæ‰èƒ½æ”¶é›†å•Šemmmmmmï¼‰
  */
}
```

#### computed

```typescript
/*
import { DebuggerOptions, ReactiveEffect } from './effect'
import { Ref, trackRefValue, triggerRefValue } from './ref'
import { isFunction, NOOP } from '@vue/shared'
import { ReactiveFlags, toRaw } from './reactive'
import { Dep } from './dep'

declare const ComputedRefSymbol: unique symbol

export interface ComputedRef<T = any> extends WritableComputedRef<T> {
  readonly value: T
  [ComputedRefSymbol]: true
}

export interface WritableComputedRef<T> extends Ref<T> {
  readonly effect: ReactiveEffect<T>
}

export type ComputedGetter<T> = (...args: any[]) => T
export type ComputedSetter<T> = (v: T) => void

export interface WritableComputedOptions<T> {
  get: ComputedGetter<T>
  set: ComputedSetter<T>
}
*/

// ComputedRefImplçœŸæ­£ç”Ÿæˆcomputed
export class ComputedRefImpl<T> {
  public dep?: Dep = undefined;

  private _value!: T;
  public readonly effect: ReactiveEffect<T>;

  public readonly __v_isRef = true;
  public readonly [ReactiveFlags.IS_READONLY]: boolean;

  public _dirty = true;

  /**
   *
   * dirty ç”¨äºåˆ¤æ–­è®¡ç®—å±æ€§ä¾èµ–çš„å“åº”å¼å±æ€§æœ‰æ²¡æœ‰è¢«æ”¹å˜ï¼Œ
   * æ›´é€šä¿—ä¸€ç‚¹ï¼š computedä¹Ÿæ˜¯é€šè¿‡effectå®ç°ä¾èµ–çš„æ”¶é›†å’Œè§¦å‘ã€‚
   * ä¸åŒçš„æ˜¯ ComputedRefImpl åŠ å…¥äº†_dirty å’Œ _valueã€‚
   * _dirty ç”¨æ¥ç¡®è®¤å½“å‰è®¡ç®—æ˜¯å¦ç»“æŸï¼Œæ˜¯å¦éœ€è¦æ›´æ–°è®¡ç®—ç»“æœã€‚_value ç”¨æ¥ç¼“å­˜è®¡ç®—ç»“æœã€‚
   *
   */

  public _cacheable: boolean;

  constructor(
    getter: ComputedGetter<T>,
    private readonly _setter: ComputedSetter<T>,
    isReadonly: boolean
    // isSSR: boolean
  ) {
    this.effect = new ReactiveEffect(getter, () => {
      // åœ¨effectå‡½æ•°ä¸­ï¼Œè‡ªå®šä¹‰scheduler
      // åˆ›å»º effect, æˆ‘ä»¬åœ¨çœ‹ effect æºç æ—¶çŸ¥é“äº†ä¼ å…¥ lazy ä»£è¡¨ä¸ä¼šç«‹å³æ‰§è¡Œ,
      // computed è¡¨æ˜ computed ä¸Šæ¸¸ä¾èµ–æ”¹å˜çš„æ—¶å€™ï¼Œä¼šä¼˜å…ˆ trigger runner effect,
      // scheduler è¡¨ç¤º effect trigger çš„æ—¶å€™ä¼šè°ƒç”¨ scheduler è€Œä¸æ˜¯ç›´æ¥è°ƒç”¨ effec
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this); // åˆå§‹åŒ–è§¦å‘ä¾èµ–
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this[ReactiveFlags.IS_READONLY] = isReadonly;
  }

  get value() {
    // the computed ref may get wrapped by other proxies e.g. readonly() #3376
    const self = toRaw(this);
    trackRefValue(self); // è¯»å–æ—¶è¿½è¸ªä¾èµ–
    if (self._dirty || !self._cacheable) {
      /**
       * _dirtyè„å€¼å˜åŒ–ï¼Ÿï¼Ÿ
       * æ˜¯çš„å…ˆç”Ÿï¼Œä¸Šæ–‡è¯´åˆ°ï¼Œå› ä¸ºlazy === trueä¸ä¼šç«‹å³æ‰§è¡Œ, ä¸”æ¯æ¬¡ä¾èµ–æ”¹å˜éœ€è¦é‡æ–°æ‰§è¡Œå‰¯ä½œç”¨
       */
      // å¦‚æœæ˜¯è„å€¼ï¼ŒæŠŠä»–æ ‡è®°ä¸ºä¸æ˜¯è„å€¼ï¼Œå¹¶è§¦å‘æ”¶é›†çš„å‰¯ä½œç”¨æ‰§è¡Œ
      self._dirty = false;
      self._value = self.effect.run()!;
    }
    return self._value;
  }

  set value(newValue: T) {
    // ç›´æ¥è§¦å‘
    this._setter(newValue);
  }
}

/*
export function computed<T>(
  getter: ComputedGetter<T>,
  debugOptions?: DebuggerOptions
): ComputedRef<T>
export function computed<T>(
  options: WritableComputedOptions<T>,
  debugOptions?: DebuggerOptions
): WritableComputedRef<T>
*/

// computed
export function computed<T>(
  getterOrOptions: ComputedGetter<T> | WritableComputedOptions<T>,
  debugOptions?: DebuggerOptions,
  isSSR = false
) {
  let getter: ComputedGetter<T>;
  let setter: ComputedSetter<T>;

  const onlyGetter = isFunction(getterOrOptions);
  if (onlyGetter) {
    // å¦‚æœ getterOrOptions æ˜¯ä¸ªå‡½æ•°ï¼Œåˆ™æ˜¯ä¸å¯è¢«é…ç½®çš„ï¼Œsetter è®¾ä¸ºç©ºå‡½æ•°
    getter = getterOrOptions;
    setter = __DEV__ // ç”Ÿäº§ç¯å¢ƒçš„ç›¸å…³é…ç½®
      ? () => {
          console.warn("Write operation failed: computed value is readonly");
        }
      : NOOP;
  } else {
    // è¯»å†™é…ç½®
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }

  const cRef = new ComputedRefImpl(
    getter,
    setter,
    onlyGetter || !setter,
    isSSR
  );

  if (__DEV__ && debugOptions && !isSSR) {
    cRef.effect.onTrack = debugOptions.onTrack;
    cRef.effect.onTrigger = debugOptions.onTrigger;
  }

  // ComputedRefImplçœŸæ­£ç”Ÿæˆcomputed
  return cRef as any;
}
```

emmmm æˆ‘è‡ªå·±çš„ç†è§£

```js
const value = reactive({});
const cValue = computed(() => value.foo);
console.log(cValue.value === undefined);
value.foo = 1;
console.log(cValue.value === 1);
```

> - computed ç”Ÿæˆ proxy ä»£ç†ï¼Œå½“åˆå§‹åŒ–æ—¶ï¼Œcomputed é€šè¿‡ new ComputedRefImpl ç”Ÿæˆ cRefï¼ˆ`() => value.foo`ä¸­çš„ value.fooï¼‰ï¼Œå¹¶å¯¹ value.foo çš„ dirty è¿›è¡Œæ ‡è®°
> - æ ¹æ® dirty åˆ¤æ–­æ˜¯å¦éœ€è¦è¿è¡Œ effect å‡½æ•°è¿›è¡Œå–å€¼ï¼Œï¼ˆè§£é‡Šäº† computed å¯¹å€¼çš„ç¼“å­˜ï¼‰
>
> - effect å‡½æ•°é‡Œå°† effect è®¾ä¸º activeEffectï¼Œå¹¶å¯¹`value`çš„ get å’Œ set è¿›è¡Œä¾èµ–çš„è¿½è¸ªå’Œæ”¶é›†
>
> - å½“æˆ‘ä»¬è¿›è¡Œ
>
> â€‹ `value.foo = 1`
>
> è°ƒç”¨ trigger è¿›è¡Œä¾èµ–è¿½è¸ªï¼Œè°ƒç”¨ `scheduler()` å°† dirty è®¾ä¸º trueï¼Œè¿™æ · computed ä¸‹æ¬¡æ±‚å€¼æ—¶ä¼šé‡æ–°æ‰§è¡Œ effect å‡½æ•°è¿›è¡Œå–å€¼ã€‚
