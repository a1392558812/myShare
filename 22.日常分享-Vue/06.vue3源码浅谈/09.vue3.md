## nextTick

> å°†å›è°ƒæ¨è¿Ÿåˆ°ä¸‹ä¸€ä¸ª DOM æ›´æ–°å‘¨æœŸä¹‹åæ‰§è¡Œã€‚åœ¨æ›´æ”¹äº†ä¸€äº›æ•°æ®ä»¥ç­‰å¾… DOM æ›´æ–°åç«‹å³ä½¿ç”¨å®ƒã€‚

```ts
export function nextTick(
  this: ComponentPublicInstance | void,
  fn?: () => void
): Promise<void> {
  const p = currentFlushPromise || resolvedPromise
  return fn ? p.then(this ? fn.bind(this) : fn) : p
}
```

> æºç ä¸­
>
> 	1.  isFlushing  æ˜¯å¦åœ¨é˜Ÿåˆ—ä¸­
> 	2.   isFlushPending  æ˜¯å¦é˜Ÿåˆ—ä¸­çš„å¾®ä»»åŠ¡åœ¨pendingä¸­
> 	3.  currentFlushPromise  å½“å‰é˜Ÿåˆ—æ­£åœ¨æ‰§è¡Œçš„å¾®ä»»åŠ¡

## mergeProps

> å°†åŒ…å« VNode prop çš„å¤šä¸ªå¯¹è±¡åˆå¹¶ä¸ºä¸€ä¸ªå•ç‹¬çš„å¯¹è±¡ã€‚å…¶è¿”å›çš„æ˜¯ä¸€ä¸ªæ–°åˆ›å»ºçš„å¯¹è±¡ï¼Œè€Œä½œä¸ºå‚æ•°ä¼ é€’çš„å¯¹è±¡åˆ™ä¸ä¼šè¢«ä¿®æ”¹ã€‚
>
> å¯ä»¥ä¼ é€’ä¸é™æ•°é‡çš„å¯¹è±¡ï¼Œåé¢å‚æ•°çš„ property ä¼˜å…ˆã€‚äº‹ä»¶ç›‘å¬å™¨è¢«ç‰¹æ®Šå¤„ç†ï¼Œ`class` å’Œ `style` ä¹Ÿæ˜¯å¦‚æ­¤ï¼Œè¿™äº› property çš„å€¼æ˜¯è¢«åˆå¹¶çš„è€Œä¸æ˜¯è¦†ç›–çš„ã€‚
>
> emmmmmmæ„Ÿè§‰æ²¡å¤ªå¤§ç”¨ï¼Œ

* $attrs æ˜¯ç”šä¹ˆ

  * åŒ…å«äº†çˆ¶ä½œç”¨åŸŸä¸­ä¸ä½œä¸ºç»„ä»¶ [props](https://v3.cn.vuejs.org/api/options-data.html#props) æˆ–[è‡ªå®šä¹‰äº‹ä»¶](https://v3.cn.vuejs.org/api/options-data.html#emits)çš„ attribute ç»‘å®šå’Œäº‹ä»¶ã€‚å½“ä¸€ä¸ªç»„ä»¶æ²¡æœ‰å£°æ˜ä»»ä½• prop æ—¶ï¼Œè¿™é‡Œä¼šåŒ…å«æ‰€æœ‰çˆ¶ä½œç”¨åŸŸçš„ç»‘å®šï¼Œå¹¶ä¸”å¯ä»¥é€šè¿‡ `v-bind="$attrs"` ä¼ å…¥å†…éƒ¨ç»„ä»¶â€”â€”è¿™åœ¨åˆ›å»ºé«˜é˜¶çš„ç»„ä»¶æ—¶ä¼šéå¸¸æœ‰ç”¨ã€‚

  > è¯´äººè¯ï¼Œå°±æ˜¯æˆ‘ä»¬æœ‰ä¸‰ä¸ªç»„ä»¶å¦‚ä¸‹

  *  ```html
    <template>
      <componentA>
        <componentB>
          <componentC></componentC>
        </componentB>
      </componentA>
    </template>
    ```

  * å¦‚æœæˆ‘ä»¬ä»Aç»„ä»¶å‘Cç»„ä»¶ä¼ é€’ä¸€è£¤ğŸ‘–å…œå­æ•°æ®ï¼Œä½†æ˜¯Bç»„ä»¶å¹¶ä¸ç”¨ï¼Œåªæ˜¯åšä¸ªä¸­è½¬ï¼Œé‚£$attrs å°±æ˜¯Aä¼ åˆ°Bçš„æ‰€æœ‰props,ä¸ç”¨å†ä¸€ä¸ªä¸€ä¸ªçš„åˆ—å‡ºæ¥


* è¨€å½’æ­£ä¼ 
```js
import { h, mergeProps } from 'vue'
export default {
  inheritAttrs: false,
  render() {
    const props = mergeProps({
      // è¯¥ class å°†ä¸ $attrs ä¸­çš„å…¶ä»– class åˆå¹¶ã€‚
      class: 'active'
    }, this.$attrs)
    return h('div', props)
  }
}
```

> æºç 

```ts
import {
  isArray,
  isFunction,
  isString,
  isObject,
  EMPTY_ARR,
  extend, // Object.assign(objA,objB)
  normalizeClass,
  normalizeStyle,
  PatchFlags,
  ShapeFlags,
  SlotFlags,
  isOn
} from '@vue/shared'
export function mergeProps(...args: (Data & VNodeProps)[]) { // ...argsæ¥å—æ‰€æœ‰å‰©ä½™å‚æ•°
  // ç¬¬ä¸€ä¸ªpropåŒ…è£¹æˆå¯¹è±¡åä¸ºretâ“ â“ â“ ä¸ºä»€ä¹ˆè¿™ä¹ˆåšå•Š
  const ret = extend({}, args[0])
  for (let i = 1; i < args.length; i++) {
    const toMerge = args[i]
    // éå†æ¯ä¸ªprop
    for (const key in toMerge) {
      // åˆå¹¶class ä¸ style  
      if (key === 'class') {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class])
        }
      } else if (key === 'style') {
        ret.style = normalizeStyle([ret.style, toMerge.style])
      } else if (isOn(key)) { // åˆ¤æ–­propæ˜¯ä¸æ˜¯onå¼€å¤´çš„
        const existing = ret[key]
        const incoming = toMerge[key]
        if (existing !== incoming) {
            // é˜²æ­¢onç»‘å®šäº‹ä»¶å†²çªï¼Œæ²¡æœ‰å†²çªåˆ™åœ¨mergePropsé‡Œå¡«ä¸Šï¼Œæœ‰åˆ™ä¼˜å…ˆä½¿ç”¨$attrsé‡Œçš„
          ret[key] = existing
            ? [].concat(existing as any, incoming as any)
            : incoming
        }
      } else if (key !== '') {
        ret[key] = toMerge[key]
      }
    }
  }
  return ret // è¿™ä¸ªå°±æ˜¯æˆ‘ä»¬è¦çš„æ´—å‘æ¶²mergeProps
}
```

