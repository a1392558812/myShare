# uniapp瀑布流加虚拟滚动

- 部分工具函数已经抽取，本人人懒，推荐先看工具函数有无重复代码
  - @/utils/components-tools.ts ---> 04.杂项整理/35.components-tools.md

> 因为微信小程序对动态slot的支持很拉，即使是高版本的编译也会有奇奇怪怪的问题，所以这块只能将一些参数暴漏出来，在引用时写一些本该是动态slot的重复代码
> 本人也不想写useParent/useChildren去耦合一些组件，有bug更难排查，能一个组件搞定就不要添加心智负担了

在使用`customWaterfall`组件时，需粘贴以下这段代码, `<slot #default>`中各个参数的含义，在下文 `定义瀑布流组件：index.vue` 中有说明

```html
<template
  #default="{ 
    columns, 
    waterfallRect,
    wrapStyle, 
    columnWrapStyle, 
    list,
    getItemId, 
    prefixHeight, 
    suffixHeight 
  }"
>
  <!-- 
    wrapStyle：定义瀑布流的样式，默认是flex布局
    waterfallRect：瀑布流的矩形信息，包含宽度、高度属性(单位px)，
    getItemId：获取并设置当前item的id，该值用于查询当前item的rect信息
    prefixHeight：每一列item的前缀占位的高度(单位px),用于'将计算的可见区域顶到视口'
    suffixHeight：每一列item的后缀占位的高度(单位px),用于'将计算的可见区域顶到视口
    v-for="(column, columnIndex) in columns": 根据当前有多少列来循环展示每一列
    v-for="(item, index) in list(column, columnIndex)"：根据每一列的可见区的数据循环展示每一个item
  -->
  <view :style="wrapStyle">
    <view
      v-for="(column, columnIndex) in columns"
      :key="columnIndex"
      :style="columnWrapStyle(columnIndex)"
    >
      <view
        v-for="(item, index) in list(column, columnIndex)"
        :id="getItemId(columnIndex, index)"
        :key="item.originalIndex"
      >
        // 自己的item写在此处
      </view>
    </view>
  </view>
</template>
```

## 使用

```html
<template>
  <view class="h-[100vh] flex flex-col overflow-hidden">
    <uv-sticky :offset-top="0" :custom-nav-height="0">
      <uv-navbar
        :auto-back="true"
        :placeholder="false"
        :fixed="false"
        title="virtual-scroll-demo"
        bg-color="rgba(255,255,255,0)"
      />
    </uv-sticky>

    <view class="info shrink-0">
      <text>当前fixedData.length:（{{ fixedData.length }}） </text>
    </view>

    <view class="info shrink-0">
      <text>添加数据： </text>
      <uv-input v-model.number="dataNum" class="control-btn" type="number">
        <template #suffix />
      </uv-input>
      <uv-button @click="addData"> 确定 </uv-button>
    </view>

    <view class="flex-1 shrink-0 overflow-hidden">
      <customWaterfall
        ref="virtualScrollFixedRef"
        :data="fixedData"
        :estimated-item-height="estimatedItemHeight"
        :buffer-size="5"
        :column-count="columnCount"
        @scroll="onScroll"
        @scrolltolower="onScrollToLower"
      >
        <template
          #default="{ columns, waterfallRect, wrapStyle, columnWrapStyle, list, getItemId, prefixHeight, suffixHeight }"
        >
          <view :style="wrapStyle">
            <view
              v-for="(column, columnIndex) in columns"
              :key="columnIndex"
              :style="columnWrapStyle(columnIndex)"
            >
              <view
                v-for="(item, index) in list(column, columnIndex)"
                :id="getItemId(columnIndex, index)"
                :key="item.originalIndex"
              >
                <view
                  class="virtual-item"
                  :style="{
                    width: `calc(${waterfallRect.width / columnCount}px - 10rpx * 2)`,
                    padding: '10rpx',
                  }"
                >
                  <view
                    :style="{
                      width: `calc(${waterfallRect.width / columnCount}px - 10rpx * 2)`,
                      backgroundColor: item.data.color,
                    }"
                  >
                    <view
                      :style="{
                        width: `calc(${waterfallRect.width / columnCount}px - 10rpx * 2)`,
                        height: `calc((${waterfallRect.width / columnCount}px - 10rpx * 2) / ${item.data.width} * ${item.data.height})`,
                        overflow: 'hidden',
                      }"
                      title="图片定尺寸,推荐使用,尺寸只需获取一次,无须在图片加载完成后重新计算位置,造成抖动"
                    >
                      <image
                        :id="`image-${item.originalIndex}`"
                        :src="item.data.image"
                        class="w-full"
                        mode="widthFix"
                      />
                    </view>

                    <!-- <image
                      :id="`image-${item.originalIndex}`"
                      title="图片不定尺寸,不推荐使用,在图片加载完成后重新计算位置,会有一定的抖动" :src="item.data.image" class="w-full" mode="widthFix"
                      :style="item.data.ifLoad ? {
                        width: `${item.data.realWidth}px`,
                        height: `${item.data.realHeight}px`,
                      } : {}" @load="(e) => onLoadImage(e, item)"
                    /> -->

                    <view>第{{ columnIndex }}列:{{ item.originalIndex }}</view>
                    <view>data-index:{{ item.originalIndex }}</view>
                    <view
                      >当前列可见个数:{{ list(column, columnIndex).length
                      }}</view
                    >
                    <view
                      >前缀占高:{{ prefixHeight(columnIndex).toFixed(2) }}</view
                    >
                    <view
                      >后缀占高:{{ suffixHeight(columnIndex).toFixed(2) }}</view
                    >
                  </view>
                </view>
              </view>
            </view>
          </view>
        </template>
        <template #footer>
          <view>footer-1122334</view>
        </template>
      </customWaterfall>
    </view>

    <uv-safe-bottom />
  </view>
</template>

<script setup lang="ts">
  import type { ColumnType } from "@/components/waterfall2/index.vue";
  import customWaterfall from "@/components/waterfall2/index.vue";
  import { queryRect, sleep } from "@/utils/components-tools";
  import { nextTick, ref } from "vue";

  const virtualScrollFixedRef = ref<InstanceType<typeof customWaterfall>>();
  const columnCount = ref(2);

  let timer = -114514;

  // 200-400随机数
  const getRandomNum = () => {
    return Math.floor(Math.random() * 201 + 200);
  };

  const dataNum = ref(20);

  // 随机颜色
  const getRandomColor = () => {
    return `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;
  };

  const getFixedDataFun = (lastIndex = 0, dataNum = 20) => {
    return Array.from({ length: dataNum }, (_, i) => {
      const height = getRandomNum();
      const width = getRandomNum();

      return {
        id: lastIndex + i,
        text: `这是第 ${lastIndex + i + 1} 条数据`,
        height,
        width,
        realHeight: 0,
        realWidth: 0,
        color: getRandomColor(),
        ifLoad: false,
        image: `https://picsum.photos/id/0/${width}/${height}`,
      };
    });
  };

  const estimatedItemHeight = ref(200);
  const fixedData = ref(getFixedDataFun());

  const onLoadImage = async (
    e: { detail: AnyObject },
    row: { data: any; originalIndex: number },
  ) => {
    // 图片加载完成后，手动更新item的高度
    const originalIndex = row.originalIndex;
    if (virtualScrollFixedRef.value && !fixedData.value[originalIndex].ifLoad) {
      const rect = await queryRect(`#image-${originalIndex}`, null, null);
      console.log(
        "图片加载完成:",
        row,
        fixedData.value[originalIndex].ifLoad,
        e,
        rect,
      );
      fixedData.value[originalIndex].ifLoad = true;
      fixedData.value[originalIndex].realWidth = rect.width || 0;
      // w:h = realW:realH     h:w = realH:realW  realH = h / w * realW
      fixedData.value[originalIndex].realHeight =
        (fixedData.value[originalIndex].height /
          fixedData.value[originalIndex].width) *
        fixedData.value[originalIndex].realWidth;
      await nextTick();
      await sleep(100);
      virtualScrollFixedRef.value?.updateItemHeight(originalIndex);
    }
  };
  const onScroll = (e: any) => {
    console.log("滚动事件:", e.detail.scrollTop);
  };

  const addData = () => {
    let num = Number(dataNum.value);
    num = num < 0 ? 0 : num > 100 ? 100 : num;
    dataNum.value = num;
    fixedData.value = fixedData.value.concat(
      getFixedDataFun(fixedData.value.length, num),
    );
  };

  const onScrollToLower = () => {
    console.log("滚动到底部");
    uni.showLoading({
      title: "加载中...",
      mask: true,
    });
    if (timer !== -114514) {
      return;
    }
    timer = setTimeout(() => {
      addData();
      uni.hideLoading();
      timer = -114514;
    }, 2000);
  };
</script>

<style lang="scss" scoped>
  .virtual-scroll-demo {
    box-sizing: border-box;
  }

  .demo-section {
    margin-bottom: 30rpx;

    .demo-title {
      font-size: 28rpx;
      font-weight: bold;
      color: #333;
    }

    .virtual-item {
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      .item-image {
        width: 100%;
        height: auto;
        margin-top: 10rpx;
        border-radius: 4rpx;
      }
    }
  }

  .info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20rpx;
    background: #f5f5f5;
    border-radius: 8rpx;
    margin-top: 20rpx;
    font-size: 26rpx;
    color: #666;
  }
</style>

<route type="page" lang="json">
  { "style": { "navigationBarTitleText": "虚拟滚动示例", "navigationStyle":
  "custom" } }
</route>
```

## 定义瀑布流组件：index.vue

```html
<template>
  <scroll-view
    :id="waterfallId"
    ref="waterfallRef"
    class="waterfall-container"
    :upper-threshold="upperThreshold"
    :scroll-into-view="scrollIntoView"
    :lower-threshold="lowerThreshold"
    :scroll-with-animation="false"
    :show-scrollbar="showScrollbar"
    :refresher-enabled="refresherEnabled"
    :refresher-threshold="refresherThreshold"
    :refresher-default-style="refresherDefaultStyle"
    :refresher-background="refresherBackground"
    :refresher-triggered="refresherTriggered"
    :style="containerStyle"
    :scroll-y="true"
    @scroll="onScroll"
    @scrolltoupper="onScrollToUpper"
    @scrolltolower="onScrollToLower"
    @refresherpulling="onRefresherPulling"
    @refresherrefresh="onRefresherRefresh"
    @refresherrestore="onRefresherRestore"
    @refresherabort="onRefresherAbort"
  >
    <view :style="{ height: `${totalHeight}px` }">
      <slot
        :columns="columns"
        :wrap-style="wrapStyle"
        :column-wrap-style="columnWrapStyle"
        :prefix-height="prefixHeight"
        :suffix-height="suffixHeight"
        :list="getSlotList"
        :get-item-id="getSlotItemId"
        :waterfall-rect="waterfallRect"
      />
      <!--
        <view
          v-for="(column, columnIndex) in columns"
          :key="columnIndex"
          :style="{ width: `calc(100% / ${columnCount})`, flex: 1 }"
        >
          渲染可见范围之前的占位符
          <view
            v-if="columnPlaceholderHeights[columnIndex].beforeHeight > 0"
            :style="{ height: `${columnPlaceholderHeights[columnIndex].beforeHeight}px` }"
            class="waterfall-placeholder"
          />

          <slot
            :list="column.items.slice(columnVisibleRanges[columnIndex].start, columnVisibleRanges[columnIndex].end)"
            :get-item-id="getItemId" :column-index="columnIndex" :column-visible-ranges="columnVisibleRanges"
          />

          渲染可见范围之后的占位符
          <view
            v-if="columnPlaceholderHeights[columnIndex].afterHeight > 0"
            :style="{ height: `${columnPlaceholderHeights[columnIndex].afterHeight}px` }"
            class="waterfall-placeholder"
          />
        </view>
      -->
      <view :id="footerId" ref="footerRef" :footer-height="footerHeight">
        <slot name="footer" />
      </view>
    </view>
  </scroll-view>
</template>

<script setup lang="ts">
  import { getUuid, queryRect, sleep } from "@/utils/components-tools";
  import {
    computed,
    getCurrentInstance,
    nextTick,
    onMounted,
    onUnmounted,
    ref,
    watch,
  } from "vue";

  export interface WaterfallProps {
    upperThreshold?: number;
    lowerThreshold?: number;
    showScrollbar?: boolean;
    refresherEnabled?: boolean;
    refresherThreshold?: number;
    refresherDefaultStyle?: "black" | "white" | "none";
    refresherBackground?: string;
    refresherTriggered?: boolean;

    data: any[];
    columnCount?: number;
    estimatedItemHeight?: number; // 预估高度
    bufferSize?: number; // 缓冲区大小

    customStyle?: AnyStyleType;
    customFooterStyle?: AnyStyleType;
  }

  export interface ColumnType {
    index: number;
    items: { data: any; originalIndex: number }[];
  }

  defineOptions({
    addGlobalClass: true,
    virtualHost: true,
    styleIsolation: "shared",
  });

  const props = withDefaults(defineProps<WaterfallProps>(), {
    upperThreshold: 50,
    lowerThreshold: 50,
    showScrollbar: true,
    refresherEnabled: false,
    refresherThreshold: 50,
    refresherDefaultStyle: "black",
    refresherBackground: "#fff",
    refresherTriggered: false,

    data: () => [],
    columnCount: 2,
    estimatedItemHeight: 200,
    bufferSize: 3,

    customStyle: () => ({}),
    customFooterStyle: () => ({}),
  });

  const emit = defineEmits<{
    (e: "scroll", data: any): void;
    (e: "scrolltoupper", data: any): void;
    (e: "scrolltolower", data: any): void;
    (e: "refresherpulling", data: any): void;
    (e: "refresherrefresh", data: any): void;
    (e: "refresherrestore", data: any): void;
    (e: "refresherabort", data: any): void;
  }>();

  const instance = getCurrentInstance();
  const uuid = ref(getUuid());

  const waterfallId = `waterfall-${uuid.value}`;
  const waterfallRef = ref<HTMLElement>();
  const waterfallRect = ref({ width: 0, height: 0 }); // 瀑布流容器矩形

  const footerId = `waterfall-footer-${uuid.value}`;
  const footerRef = ref<HTMLElement>();
  const footerHeight = ref(0);

  const itemRefs = ref<HTMLElement[]>([]);

  const scrollTop = ref(0);
  const scrollIntoView = ref("");
  const itemHeights = ref<Map<string, number>>(new Map()); // 缓存每个item的实际高度
  const isMeasuring = ref(false);
  const measuredItems = ref<Set<string>>(new Set()); // 已测量的item

  const containerStyle = computed<AnyStyleType>(() => {
    return {
      height: "100%",
      width: "100%",
      overflow: "auto",
      position: "relative",
      ...props.customStyle,
    };
  });

  // 计算列数据
  const columns = computed<ColumnType[]>(() => {
    const cols: ColumnType[] = Array.from(
      { length: props.columnCount },
      (_, i) => ({
        index: i,
        items: [],
      }),
    );

    // 瀑布流分配：将item分配到当前高度最小的列
    const columnHeights = Array.from({ length: props.columnCount }).fill(
      0,
    ) as number[];

    props.data.forEach((item, index) => {
      // 找到高度最小的列
      let minHeight = Number.MAX_SAFE_INTEGER;
      let minColumnIndex = 0;

      for (let i = 0; i < columnHeights.length; i++) {
        if (columnHeights[i] < minHeight) {
          minHeight = columnHeights[i];
          minColumnIndex = i;
        }
      }

      // 分配到最小高度的列
      cols[minColumnIndex].items.push({ data: item, originalIndex: index });

      // 更新列高度
      const key = `item-${index}`; // 使用originalIndex作为缓存键
      const height = itemHeights.value.get(key) || props.estimatedItemHeight;
      columnHeights[minColumnIndex] += height;
    });

    return cols;
  });

  // 计算总高度
  const totalHeight = computed(() => {
    let maxHeight = 0;

    columns.value.forEach((column) => {
      let columnHeight = 0;

      column.items.forEach((item) => {
        const key = `item-${item.originalIndex}`;
        const height = itemHeights.value.get(key) || props.estimatedItemHeight;
        columnHeight += height;
      });
      maxHeight = Math.max(maxHeight, columnHeight);
    });

    maxHeight = maxHeight + footerHeight.value || 0;
    return maxHeight;
  });

  // 计算每列的累积高度
  const columnAccumulatedHeights = computed(() => {
    return columns.value.map((column) => {
      const heights: number[] = [];
      let accumulated = 0;

      column.items.forEach((item) => {
        const key = `item-${item.originalIndex}`; // 使用originalIndex作为缓存键
        const height = itemHeights.value.get(key) || props.estimatedItemHeight;
        accumulated += height;
        heights.push(accumulated);
      });

      return heights;
    });
  });

  // 计算每列的可见范围
  const columnVisibleRanges = computed(() => {
    const scrollPosition = scrollTop.value;
    const visibleBottom = scrollTop.value + waterfallRect.value.height;

    return columns.value.map((column, columnIndex) => {
      const heights = columnAccumulatedHeights.value[columnIndex];
      let start = 0;
      let end = heights.length;

      // 找到可见范围的起始索引
      for (let i = 0; i < heights.length; i++) {
        if (heights[i] > scrollPosition - props.estimatedItemHeight) {
          start = i;
          break;
        }
      }

      // 找到可见范围的结束索引
      for (let i = start; i < heights.length; i++) {
        if (heights[i] > visibleBottom + props.estimatedItemHeight) {
          end = i;
          break;
        }
      }

      // 添加缓冲区
      start = Math.max(0, start - props.bufferSize);
      end = Math.min(heights.length, end + props.bufferSize);

      return { start, end };
    });
  });

  // 计算占位符高度
  const getPlaceholderHeight = (columnIndex: number, endIndex: number) => {
    const heights = columnAccumulatedHeights.value[columnIndex];
    if (endIndex > 0 && heights[endIndex - 1]) {
      return heights[endIndex - 1];
    }
    return 0;
  };

  // 计算每列的占位符高度（使用计算属性缓存）
  const columnPlaceholderHeights = computed(() => {
    return columns.value.map((column, columnIndex) => {
      const range = columnVisibleRanges.value[columnIndex];
      const beforeHeight = getPlaceholderHeight(columnIndex, range.start);
      const afterHeight =
        getPlaceholderHeight(columnIndex, column.items.length) -
        getPlaceholderHeight(columnIndex, range.end);
      return { beforeHeight, afterHeight };
    });
  });

  const getItemId = (columnIndex: number, itemIndex: number) => {
    return `waterfall-item-${waterfallId}-${columnIndex}-${itemIndex}`;
  };

  /**  slot插槽参数展示开始 */
  // 列容器样式
  const wrapStyle: AnyStyleType = {
    display: "flex",
    flexDirection: "row",
    alignItems: "flex-start",
    width: "100%",
  };
  // 列容器前缀高度（占位符高度）
  const prefixHeight = (columnIndex: number) =>
    columnPlaceholderHeights.value[columnIndex].beforeHeight > 0
      ? columnPlaceholderHeights.value[columnIndex].beforeHeight
      : 0;
  // 列容器后缀高度（占位符高度）
  const suffixHeight = (columnIndex: number) =>
    columnPlaceholderHeights.value[columnIndex].afterHeight > 0
      ? columnPlaceholderHeights.value[columnIndex].afterHeight
      : 0;
  // 列容器样式（包含占位符高度）
  const columnWrapStyle = (columnIndex: number) => ({
    width: `calc(100% / ${props.columnCount})`,
    flex: 1,
    paddingTop: `${prefixHeight(columnIndex)}px`,
    paddingBottom: `${suffixHeight(columnIndex)}px`,
  });
  // 列容器item列表（包含缓冲区）
  const getSlotList = (column: ColumnType, columnIndex: number) =>
    column.items.slice(
      columnVisibleRanges.value[columnIndex].start,
      columnVisibleRanges.value[columnIndex].end,
    );
  // 列容器item列表id（包含缓冲区）
  const getSlotItemId = (columnIndex: number, listIndex: number) =>
    getItemId(
      columnIndex,
      columnVisibleRanges.value[columnIndex].start + listIndex,
    );
  /**  slot插槽参数展示结束 */

  // 测量单个item的高度
  const measureItemHeight = async (columnIndex: number, itemIndex: number) => {
    const column = columns.value[columnIndex];
    if (!column || !column.items[itemIndex]) {
      return;
    }

    const item = column.items[itemIndex];
    const key = `item-${item.originalIndex}`; // 使用originalIndex作为缓存键

    try {
      const id = getItemId(columnIndex, itemIndex);
      const rect = await queryRect(
        `#${id}`,
        null,
        itemRefs.value[columnIndex * itemIndex],
      );
      if (rect && rect.height) {
        const oldHeight = itemHeights.value.get(key) || 0;
        const newHeight = rect.height;

        // 只有高度变化才更新
        if (Math.abs(oldHeight - newHeight) > 1) {
          itemHeights.value.set(key, newHeight);
          // 高度变化时，标记为未测量，以便下次重新测量
          measuredItems.value.delete(key);
        } else {
          // 高度稳定后，标记为已测量
          measuredItems.value.add(key);
        }
      }
    } catch (error) {
      console.warn(`Failed to measure item height for ${key}:`, error);
    }
  };

  // 测量可见区域内的所有item
  const measureVisibleItems = async () => {
    if (isMeasuring.value) {
      return;
    }

    isMeasuring.value = true;

    try {
      await nextTick();

      // 收集需要测量的item
      const itemsToMeasure: { columnIndex: number; itemIndex: number }[] = [];

      columns.value.forEach((column, columnIndex) => {
        const range = columnVisibleRanges.value[columnIndex];
        for (
          let i = range.start;
          i < range.end && i < column.items.length;
          i++
        ) {
          const item = column.items[i];
          const key = `item-${item.originalIndex}`;
          // 只测量未测量或高度可能变化的item
          if (!measuredItems.value.has(key)) {
            itemsToMeasure.push({ columnIndex, itemIndex: i });
          }
        }
      });

      // 并行测量，但限制并发数，避免过多并发请求影响性能
      if (itemsToMeasure.length > 0) {
        const batchSize = 5; // 每次最多测量5个item
        for (let i = 0; i < itemsToMeasure.length; i += batchSize) {
          const batch = itemsToMeasure.slice(i, i + batchSize);
          await Promise.all(
            batch.map(({ columnIndex, itemIndex }) =>
              measureItemHeight(columnIndex, itemIndex),
            ),
          );
          await nextTick();
        }
      }
    } catch (error) {
      console.warn("Error measuring items:", error);
    } finally {
      isMeasuring.value = false;
    }
  };

  const onScroll = (e: any) => {
    scrollTop.value = e.detail.scrollTop;
    emit("scroll", e);
  };

  const onScrollToUpper = (e: any) => {
    emit("scrolltoupper", e);
  };

  const onScrollToLower = (e: any) => {
    emit("scrolltolower", e);
  };

  const onRefresherPulling = (e: any) => {
    emit("refresherpulling", e);
  };

  const onRefresherRefresh = (e: any) => {
    emit("refresherrefresh", e);
  };

  const onRefresherRestore = (e: any) => {
    emit("refresherrestore", e);
  };

  const onRefresherAbort = (e: any) => {
    emit("refresherabort", e);
  };

  // 监听
  watch(
    () => props.data.length,
    (newLength, oldLength) => {
      if (newLength > oldLength) {
        // 添加数据时，保留所有已存在item的高度缓存
        // 只清空已测量标记，让新添加的item和可能位置变化的item重新测量
        measuredItems.value.clear();
      } else if (newLength < oldLength) {
        // 数据减少时，清除高度缓存和已测量标记
        const newItemHeights = new Map();
        const newMeasuredItems: Set<string> = new Set();

        // 只保留前newLength个item的缓存
        itemHeights.value.forEach((height, key) => {
          const itemIndex = Number.parseInt(key.replace("item-", ""));
          if (itemIndex < newLength) {
            newItemHeights.set(key, height);
            if (measuredItems.value.has(key)) {
              newMeasuredItems.add(key);
            }
          }
        });

        itemHeights.value = newItemHeights;
        measuredItems.value = newMeasuredItems;
      }
    },
  );

  watch(
    () => props.columnCount,
    () => {
      // 列数变化时清空高度缓存
      itemHeights.value.clear();
      measuredItems.value.clear();
    },
  );

  watch([columnVisibleRanges, scrollTop], () => {
    measureVisibleItems();
  });

  // 手动更新指定item的高度
  const updateItemHeight = (index: number) => {
    if (index < 0 || index >= props.data.length) {
      return;
    }

    // 找到指定索引的item所在的列和位置
    let targetColumnIndex = -1;
    let targetItemIndex = -1;

    for (let colIndex = 0; colIndex < columns.value.length; colIndex++) {
      for (
        let itemIndex = 0;
        itemIndex < columns.value[colIndex].items.length;
        itemIndex++
      ) {
        if (columns.value[colIndex].items[itemIndex].originalIndex === index) {
          targetColumnIndex = colIndex;
          targetItemIndex = itemIndex;
          break;
        }
      }
      if (targetColumnIndex !== -1 || targetItemIndex !== -1) {
        break;
      }
    }

    if (targetColumnIndex === -1 || targetItemIndex === -1) {
      return;
    }

    console.log("更新item高度:", index, targetColumnIndex, targetItemIndex);

    // 测量该item的高度
    measureItemHeight(targetColumnIndex, targetItemIndex);
  };

  // 手动更新所有可见item的高度
  const updateVisibleItemHeights = () => {
    measureVisibleItems();
  };

  const measureFooterHeight = () => {
    if (footerRef.value) {
      queryRect(`#${footerId}`, instance, footerRef.value).then((rect) => {
        footerHeight.value = rect.height || 0;
      });
    }
  };

  const init = () => {
    queryRect(`#${waterfallId}`, instance, waterfallRef.value).then((rect) => {
      waterfallRect.value = {
        width: rect.width || 0,
        height: rect.height || 0,
      };
      nextTick(() => {
        sleep(100).then(() => {
          measureFooterHeight();
          measureVisibleItems();
        });
      });
    });
  };

  onMounted(() => {
    init();
  });

  defineExpose({
    scrollTop,
    totalHeight,
    columnVisibleRanges,
    updateItemHeight,
    updateVisibleItemHeights,
    init,
  });
</script>

<style lang="scss" scoped>
  .waterfall-container {
    box-sizing: border-box;
    width: 100%;
    height: 100%;
  }
</style>
```
