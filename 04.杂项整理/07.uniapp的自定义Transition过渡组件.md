# uniapp 的自定义 Transition 过渡组件

> 水水水水水水水，此处抽取的是[【wot-ui】](https://wot-ui.cn/component/transition.html)的 transition 签名组件。做了一些简化和把一些工具方法都提到一个文件里

```html
<template>
  <view
    v-if="isShow && disableTouchMove"
    :class="rootClass"
    :style="style"
    @transitionend="onTransitionEnd"
    @click="handleClick"
    @touchmove.stop.prevent="noop"
  >
    <slot />
  </view>
  <view
    v-else-if="isShow && !disableTouchMove"
    :class="rootClass"
    :style="style"
    @transitionend="onTransitionEnd"
    @click="handleClick"
  >
    <slot />
  </view>
</template>

<script lang="ts" setup>
  import { computed, onBeforeMount, ref, watch } from "vue";

  export interface TransitionPropsType {
    customStyle?: { [key in string]: string | number };
    customClass?: string;
    /**
     * 是否展示组件
     * 类型：boolean
     * 默认值：false
     */
    show?: boolean;

    /**
     * 动画执行时间
     * 类型：number | boolean | { [key in string]: string | number }
     * 默认值：300 (毫秒)
     */
    duration?: { [key in string]: string | number } | number | boolean;
    /**
     * 弹层内容懒渲染，触发展示时才渲染内容
     * 类型：boolean
     * 默认值：false
     */
    lazyRender?: boolean;

    /**
     * 是否在动画结束时销毁子节点（display: none)
     * 类型：boolean
     * 默认值：false
     */
    destroy?: boolean;
    /**
     * 进入过渡的开始状态
     * 类型：string
     */
    enterClass?: string;

    /**
     * 进入过渡的激活状态
     * 类型：string
     */
    enterActiveClass?: string;

    /**
     * 进入过渡的结束状态
     * 类型：string
     */
    enterToClass?: string;

    /**
     * 离开过渡的开始状态
     * 类型：string
     */
    leaveClass?: string;

    /**
     * 离开过渡的激活状态
     * 类型：string
     */
    leaveActiveClass?: string;

    /**
     * 离开过渡的结束状态
     * 类型：string
     */
    leaveToClass?: string;
    /**
     * 是否阻止触摸滚动
     * 类型：boolean
     * 默认值：false
     */
    disableTouchMove?: boolean;
  }

  defineOptions({
    name: "Transition",
    options: {
      addGlobalClass: true,
      virtualHost: true,
      styleIsolation: "shared",
    },
  });

  const props = withDefaults(defineProps<TransitionPropsType>(), {
    customStyle: () => ({}),
    customClass: "",
    show: true,
    duration: 300,
    lazyRender: false,
    destroy: false,
    enterClass: "",
    enterActiveClass: "",
    enterToClass: "",
    leaveClass: "",
    leaveActiveClass: "",
    leaveToClass: "",
    disableTouchMove: false,
  });

  const emit = defineEmits([
    "click",
    "before-enter",
    "enter",
    "before-leave",
    "leave",
    "after-leave",
    "after-enter",
  ]);

  class AbortablePromise<T> {
    promise: Promise<T>;
    private _reject: ((res?: any) => void) | null = null;

    constructor(
      executor: (
        resolve: (value: T | PromiseLike<T>) => void,
        reject: (reason?: any) => void
      ) => void
    ) {
      this.promise = new Promise<T>((resolve, reject) => {
        executor(resolve, reject);
        this._reject = reject; // 保存reject方法的引用，以便在abort时调用
      });
    }

    // 提供abort方法来中止Promise
    abort(error?: any) {
      if (this._reject) {
        this._reject(error); // 调用reject方法来中止Promise
      }
    }

    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): Promise<TResult1 | TResult2> {
      return this.promise.then(onfulfilled, onrejected);
    }

    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): Promise<T | TResult> {
      return this.promise.catch(onrejected);
    }
  }

  /**
   * 暂停指定时间函数
   * @param ms 延迟时间
   * @returns
   */
  const pause = (ms: number = 1000 / 30) => {
    return new AbortablePromise((resolve) => {
      const timer = setTimeout(() => {
        clearTimeout(timer);
        resolve(true);
      }, ms);
    });
  };

  function isObj(value: any): value is object {
    return (
      Object.prototype.toString.call(value) === "[object Object]" ||
      typeof value === "object"
    );
  }

  function isPromise(value: unknown): value is Promise<any> {
    return value && (value as any).then;
  }

  const getClassNames = () => {
    const enter: string = `custom-fade-enter custom-fade-enter-active ${props.enterClass} ${props.enterActiveClass}`;
    const enterTo: string = `custom-fade-enter-to custom-fade-enter-active ${props.enterToClass} ${props.enterActiveClass}`;
    const leave: string = `custom-fade-leave custom-fade-leave-active ${props.leaveClass} ${props.leaveActiveClass}`;
    const leaveTo: string = `custom-fade-leave-to custom-fade-leave-active ${props.leaveToClass} ${props.leaveActiveClass}`;

    return {
      enter: enter,
      "enter-to": enterTo,
      leave: leave,
      "leave-to": leaveTo,
    };
  };

  // 初始化是否完成
  const inited = ref<boolean>(false);
  // 是否显示
  const display = ref<boolean>(false);
  // 当前动画状态
  const status = ref<string>("");
  // 动画是否结束
  const transitionEnded = ref<boolean>(false);
  // 动画持续时间
  const currentDuration = ref<number>(300);
  // 类名
  const classes = ref<string>("");
  // 用于控制enter和leave的顺序执行
  const enterPromise = ref<AbortablePromise<void> | null>(null);

  // 动画进入的生命周期
  const enterLifeCyclePromises = ref<AbortablePromise<unknown> | null>(null);

  // 动画离开的生命周期
  const leaveLifeCyclePromises = ref<AbortablePromise<unknown> | null>(null);

  const style = computed(() => {
    return `-webkit-transition-duration: ${
      currentDuration.value
    }ms;transition-duration: ${currentDuration.value}ms;${
      display.value || !props.destroy ? "" : "display: none;"
    }${props.customStyle}`;
  });

  const rootClass = computed(() => {
    return `custom-fade ${props.customClass} ${classes.value}`;
  });

  const isShow = computed(() => {
    return !props.lazyRender || inited.value;
  });

  onBeforeMount(() => {
    if (props.show) {
      enter();
    }
  });

  watch(
    () => props.show,
    (newVal) => {
      handleShow(newVal);
    },
    { deep: true }
  );

  function handleClick() {
    emit("click");
  }

  function handleShow(value: boolean) {
    if (value) {
      handleAbortPromise();
      enter();
    } else {
      leave();
    }
  }
  /**
   * 取消所有的promise
   */
  function handleAbortPromise() {
    isPromise(enterPromise.value) && enterPromise.value.abort();
    isPromise(enterLifeCyclePromises.value) &&
      enterLifeCyclePromises.value.abort();
    isPromise(leaveLifeCyclePromises.value) &&
      leaveLifeCyclePromises.value.abort();
    enterPromise.value = null;
    enterLifeCyclePromises.value = null;
    leaveLifeCyclePromises.value = null;
  }

  function enter() {
    enterPromise.value = new AbortablePromise(async (resolve) => {
      try {
        const classNames = getClassNames();
        const duration = isObj(props.duration)
          ? (props.duration as any).enter
          : props.duration;
        status.value = "enter";
        emit("before-enter");
        enterLifeCyclePromises.value = pause();
        await enterLifeCyclePromises.value;
        emit("enter");
        classes.value = classNames.enter;
        currentDuration.value = duration;
        enterLifeCyclePromises.value = pause();
        await enterLifeCyclePromises.value;
        inited.value = true;
        display.value = true;
        enterLifeCyclePromises.value = pause();
        await enterLifeCyclePromises.value;
        enterLifeCyclePromises.value = null;
        transitionEnded.value = false;
        classes.value = classNames["enter-to"];
        resolve();
      } catch (error) {
        console.error(error);
        /**
         *
         */
      }
    });
  }
  async function leave() {
    if (!enterPromise.value) {
      transitionEnded.value = false;
      return onTransitionEnd();
    }
    try {
      await enterPromise.value;
      if (!display.value) return;
      const classNames = getClassNames();
      const duration = isObj(props.duration)
        ? (props.duration as any).leave
        : props.duration;
      status.value = "leave";
      emit("before-leave");
      currentDuration.value = duration;
      leaveLifeCyclePromises.value = pause();
      await leaveLifeCyclePromises.value;
      emit("leave");
      classes.value = classNames.leave;
      leaveLifeCyclePromises.value = pause();
      await leaveLifeCyclePromises.value;
      transitionEnded.value = false;
      classes.value = classNames["leave-to"];
      leaveLifeCyclePromises.value = pause(currentDuration.value);
      await leaveLifeCyclePromises.value;
      leaveLifeCyclePromises.value = null;
      onTransitionEnd();
      enterPromise.value = null;
    } catch (error) {
      console.error(error);
      /**
       *
       */
    }
  }

  function onTransitionEnd() {
    if (transitionEnded.value) return;

    transitionEnded.value = true;
    if (status.value === "leave") {
      // 离开后触发
      emit("after-leave");
    } else if (status.value === "enter") {
      // 进入后触发
      emit("after-enter");
    }

    if (!props.show && display.value) {
      display.value = false;
    }
  }

  function noop() {}
</script>

<style scoped lang="scss">
  .custom-fade {
    transition-timing-function: ease;
    opacity: 1;
  }

  .custom-fade-enter,
  .custom-fade-leave-to {
    opacity: 0;
  }

  .custom-fade-enter-active,
  .custom-fade-leave-active {
    transition-property: opacity;
  }
</style>
```
