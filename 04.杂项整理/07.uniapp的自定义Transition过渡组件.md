# uniapp 的自定义 Transition 过渡组件

> 水水水水水水水，此处抽取的是[【uv-ui】](https://www.uvui.cn/components/transition.html)的 transition 签名组件。

## 自定义动画使用

```html
<template>
  <view>
    <button type="primary" @click="run">执行动画</button>

    <customTransition
      ref="customTransitionRef"
      :custom-style="{ width: '100px', height: '100px', backgroundColor: 'green' }"
      :show="show"
    />
  </view>
</template>

<script setup lang="ts">
  import customTransition from "@/components/transition/index.vue";
  import { onReady } from "@dcloudio/uni-app";
  import { ref } from "vue";

  const customTransitionRef = ref<InstanceType<typeof customTransition>>();
  const show = ref(true);

  const run = () => {
    // 同时右平移到 100px,旋转 360 读
    customTransitionRef.value?.step({
      translateX: "100px",
      rotate: "360",
    });
    // 上面的动画执行完成后，等待200毫秒平移到 0px,旋转到 0 读
    customTransitionRef.value?.step(
      {
        translateX: "0px",
        rotate: "0",
      },
      {
        timingFunction: "ease-in",
        duration: 200,
      }
    );
    // 开始执行动画
    customTransitionRef.value?.run(() => {
      console.log("动画支持完毕");
    });
  };

  onReady(() => {
    customTransitionRef.value?.init({
      duration: 1000,
      timingFunction: "linear",
      transformOrigin: "50% 50%",
      delay: 500,
    });
  });
</script>
```

## custom-transition

```html
<template>
  <!-- #ifndef APP-NVUE -->
  <view
    v-if="isShow"
    ref="ani"
    :animation="animationData"
    :class="customClass"
    :style="transformStyles"
    @click="onClick"
  >
    <slot />
  </view>
  <!-- #endif -->
  <!-- #ifdef APP-NVUE -->
  <view
    v-if="isShow"
    ref="ani"
    :animation="animationData"
    :class="customClass"
    :style="transformStyles"
    @click="onClick"
  >
    <slot />
  </view>
  <!-- #endif -->
</template>

<script setup lang="ts">
  import { computed, onMounted, ref, watch } from "vue";
  import { createAnimation } from "./createAnimation";

  // Props 定义
  const props = withDefaults(
    defineProps<{
      show?: boolean;
      mode?: string | string[] | null;
      duration?: string | number;
      timingFunction?: string;
      customClass?: string;
      cellChild?: boolean;
      customStyle?: any;
    }>(),
    {
      show: false,
      mode: "fade",
      duration: 300,
      timingFunction: "ease-out",
      customClass: "",
      cellChild: false,
      customStyle: () => ({}),
    }
  );

  // Emits 定义
  const emit = defineEmits<{
    (e: "click", payload: { detail: boolean }): void;
    (e: "change", payload: { detail: boolean }): void;
  }>();

  // 数据定义
  const isShow = ref(false);
  const transform = ref("");
  const opacity = ref(1);
  const animationData = ref<any>({});
  const durationTime = ref(300);
  const config = ref({});
  const animation = ref<any>(null);
  const timer = ref<any>(null);
  const ani = ref<any>(null);

  // 计算属性
  const transformStyles = computed(() => {
    const style = {
      transform: transform.value,
      opacity: opacity.value,
      ...(props.customStyle ? props.customStyle : {}),
      "transition-duration": `${
        (typeof props.duration === "string"
          ? Number.parseInt(props.duration)
          : props.duration) / 1000
      }s`,
    };
    // 这里保持原有逻辑，假设 $uv.addStyle 方法存在
    return style;
  });

  // 方法定义
  /**
   *  ref 触发 初始化动画
   */
  const init = (obj: any = {}) => {
    if (obj.duration) {
      durationTime.value = obj.duration;
    }
    animation.value = createAnimation(Object.assign(config.value, obj), {
      isShow,
      transform,
      opacity,
      animationData,
      durationTime,
      config,
      props,
      $refs: {
        ani: {
          ref: ani.value,
        },
      },
    });
  };

  /**
   * 点击组件触发回调
   */
  const onClick = () => {
    emit("click", {
      detail: isShow.value,
    });
  };

  /**
   *  ref 触发 执行动画
   */
  const run = (fn: any) => {
    if (!animation.value) return;
    animation.value.run(fn);
  };

  /**
   * ref 触发 动画分组
   * @param {object} obj
   */
  const step = (obj: any, config: any = {}) => {
    if (!animation.value) return;
    for (const i in obj) {
      try {
        if (typeof obj[i] === "object") {
          animation.value[i](...obj[i]);
        } else {
          animation.value[i](obj[i]);
        }
      } catch (e) {
        console.error(`方法 ${i} 不存在`, e);
      }
    }
    animation.value.step(config);
    return {
      step,
      run,
    };
  };

  // 处理动画开始前的默认样式
  const styleInit = (type: boolean) => {
    const styles: any = {
      transform: "",
    };
    const buildStyle = (type: boolean, mode: string) => {
      if (mode === "fade") {
        styles.opacity = animationType(type)[mode];
      } else {
        styles.transform += `${animationType(type)[mode]} `;
      }
    };
    if (typeof props.mode === "string") {
      buildStyle(type, props.mode);
    } else if (Array.isArray(props.mode)) {
      props.mode.forEach((mode) => {
        buildStyle(type, mode);
      });
    }
    return styles;
  };

  // 处理内置组合动画
  const tranfromInit = (type: boolean) => {
    const buildTranfrom = (type: boolean, mode: string) => {
      let aniNum: any = null;
      if (mode === "fade") {
        aniNum = type ? 0 : 1;
      } else {
        aniNum = type ? "-100%" : "0";
        if (mode === "zoom-in") {
          aniNum = type ? 0.8 : 1;
        }
        if (mode === "zoom-out") {
          aniNum = type ? 1.2 : 1;
        }
        if (mode === "slide-right") {
          aniNum = type ? "100%" : "0";
        }
        if (mode === "slide-bottom") {
          aniNum = type ? "100%" : "0";
        }
      }
      animation.value[animationMode()[mode]](aniNum);
    };
    if (typeof props.mode === "string") {
      buildTranfrom(type, props.mode);
    } else if (Array.isArray(props.mode)) {
      props.mode.forEach((mode) => {
        buildTranfrom(type, mode);
      });
    }
    return animation.value;
  };

  const animationType = (type: boolean) => {
    return {
      fade: type ? 1 : 0,
      "slide-top": `translateY(${type ? "0" : "-100%"})`,
      "slide-right": `translateX(${type ? "0" : "100%"})`,
      "slide-bottom": `translateY(${type ? "0" : "100%"})`,
      "slide-left": `translateX(${type ? "0" : "-100%"})`,
      "zoom-in": `scaleX(${type ? 1 : 0.8}) scaleY(${type ? 1 : 0.8})`,
      "zoom-out": `scaleX(${type ? 1 : 1.2}) scaleY(${type ? 1 : 1.2})`,
    };
  };

  // 内置动画类型与实际动画对应字典
  const animationMode = () => {
    return {
      fade: "opacity",
      "slide-top": "translateY",
      "slide-right": "translateX",
      "slide-bottom": "translateY",
      "slide-left": "translateX",
      "zoom-in": "scale",
      "zoom-out": "scale",
    };
  };

  // 开始过度动画
  const open = () => {
    clearTimeout(timer.value);
    transform.value = "";
    isShow.value = true;
    const { opacity: opa, transform: trans } = styleInit(false);
    if (typeof opa !== "undefined") {
      opacity.value = opa;
    }
    transform.value = trans;
    // 确保动态样式已经生效后，执行动画，如果不加 nextTick ，会导致 wx 动画执行异常
    setTimeout(() => {
      // TODO 定时器保证动画完全执行，目前有些问题，后面会取消定时器
      timer.value = setTimeout(() => {
        animation.value = createAnimation(config.value, {
          isShow,
          transform,
          opacity,
          animationData,
          durationTime,
          config,
          props,
          $refs: {
            ani: {
              ref: ani.value,
            },
          },
        });
        tranfromInit(false).step();
        // #ifdef APP-NVUE
        if (props.cellChild) {
          opacity.value = 1;
        } else {
          animation.value.run();
        }
        // #endif
        // #ifndef APP-NVUE
        animation.value.run();
        // #endif
        // #ifdef VUE3
        // #ifdef H5
        opacity.value = 1;
        // #endif
        // #endif
        emit("change", {
          detail: isShow.value,
        });
        // #ifdef H5
        // #ifdef VUE3
        transform.value = "";
        // #endif
        // #endif
      }, 20);
    }, 0);
  };

  // 关闭过渡动画
  const close = () => {
    if (!animation.value) return;
    tranfromInit(true)
      .step()
      .run(() => {
        isShow.value = false;
        animationData.value = null;
        animation.value = null;
        const { opacity: opa, transform: trans } = styleInit(false);
        opacity.value = opa || 1;
        transform.value = trans;
        emit("change", {
          detail: isShow.value,
        });
      });
  };

  // 驼峰转中横线
  const toLine = (name: string) => {
    return name.replace(/([A-Z])/g, "-$1").toLowerCase();
  };

  // 监听
  watch(
    () => props.show,
    (newVal) => {
      if (newVal) {
        open();
      } else {
        // 避免上来就执行 close,导致动画错乱
        if (isShow.value) {
          close();
        }
      }
    },
    { immediate: true }
  );

  // 生命周期
  onMounted(() => {
    // 动画默认配置
    config.value = {
      duration: props.duration,
      timingFunction: props.timingFunction,
      transformOrigin: "50% 50%",
      delay: 0,
    };
    durationTime.value =
      typeof props.duration === "string"
        ? Number.parseInt(props.duration)
        : props.duration;
  });

  // 暴露给模板的变量
  defineExpose({
    init,
    step,
    run,
    open,
    close,
    toLine,
  });
</script>
```

```typeScript
// const defaultOption = {
//  duration: 300,
//  timingFunction: 'linear',
//  delay: 0,
//  transformOrigin: '50% 50% 0'
// }
// #ifdef APP-NVUE
const nvueAnimation = uni.requireNativePlugin('animation')
// #endif

// 定义动画配置接口
export interface AnimationOption {
  duration?: number
  timingFunction?: 'linear' | 'ease' | 'ease-in' | 'ease-in-out' | 'ease-out' | 'step-start' | 'step-end' | undefined
  delay?: number
  transformOrigin?: string
}

// 定义动画步骤配置接口
interface StepConfig extends AnimationOption {
  [key: string]: any
}

// 定义样式接口
interface AnimationStyles {
  transform?: string
  transformOrigin?: string
  [key: string]: string | undefined
}

// 定义动画步骤接口
interface AnimationStep {
  styles: AnimationStyles
  config: StepConfig
}

// 定义Vue组件实例接口
interface VueComponentInstance {
  $refs: {
    ani?: {
      ref: any
    }
  }
  animationData?: any
  timer?: number
  durationTime?: number
  [key: string]: any
}

// 定义动画类型
const animateTypes1: string[] = ['matrix', 'matrix3d', 'rotate', 'rotate3d', 'rotateX', 'rotateY', 'rotateZ', 'scale', 'scale3d', 'scaleX', 'scaleY', 'scaleZ', 'skew', 'skewX', 'skewY', 'translate', 'translate3d', 'translateX', 'translateY', 'translateZ']
const animateTypes2: string[] = ['opacity', 'backgroundColor']
const animateTypes3: string[] = ['width', 'height', 'left', 'right', 'top', 'bottom']
const allAnimateTypes: string[] = [...animateTypes1, ...animateTypes2, ...animateTypes3]

// 定义动画方法类型
interface AnimationMethods {
  matrix: (...args: any[]) => MPAnimation
  matrix3d: (...args: any[]) => MPAnimation
  rotate: (...args: any[]) => MPAnimation
  rotate3d: (...args: any[]) => MPAnimation
  rotateX: (...args: any[]) => MPAnimation
  rotateY: (...args: any[]) => MPAnimation
  rotateZ: (...args: any[]) => MPAnimation
  scale: (...args: any[]) => MPAnimation
  scale3d: (...args: any[]) => MPAnimation
  scaleX: (...args: any[]) => MPAnimation
  scaleY: (...args: any[]) => MPAnimation
  scaleZ: (...args: any[]) => MPAnimation
  skew: (...args: any[]) => MPAnimation
  skewX: (...args: any[]) => MPAnimation
  skewY: (...args: any[]) => MPAnimation
  translate: (...args: any[]) => MPAnimation
  translate3d: (...args: any[]) => MPAnimation
  translateX: (...args: any[]) => MPAnimation
  translateY: (...args: any[]) => MPAnimation
  translateZ: (...args: any[]) => MPAnimation
  opacity: (...args: any[]) => MPAnimation
  backgroundColor: (...args: any[]) => MPAnimation
  width: (...args: any[]) => MPAnimation
  height: (...args: any[]) => MPAnimation
  left: (...args: any[]) => MPAnimation
  right: (...args: any[]) => MPAnimation
  top: (...args: any[]) => MPAnimation
  bottom: (...args: any[]) => MPAnimation
}

// 合并MPAnimation类和动画方法类型
type MPAnimationWithMethods = MPAnimation & AnimationMethods

class MPAnimation {
  options: AnimationOption
  animation: any
  currentStepAnimates: Record<number, AnimationStep>
  next: number
  $: VueComponentInstance
  isEnd: boolean

  constructor(options: AnimationOption, _this: VueComponentInstance) {
    this.options = options || {}
    // 在iOS10+QQ小程序平台下，传给原生的对象一定是个普通对象而不是Proxy对象，否则会报parameter should be Object instead of ProxyObject的错误
    this.animation = uni.createAnimation({
      ...options,
    })
    this.currentStepAnimates = {}
    this.next = 0
    this.$ = _this
    this.isEnd = false
  }

  _nvuePushAnimates(type: string, args: any[]): void {
    const aniObj = this.currentStepAnimates[this.next]
    let styles: AnimationStep = {
      styles: {},
      config: {},
    }
    if (aniObj) {
      styles = aniObj
    }
    if (animateTypes1.includes(type)) {
      if (!styles.styles.transform) {
        styles.styles.transform = ''
      }
      let unit = ''
      if (type === 'rotate') {
        unit = 'deg'
      }
      styles.styles.transform += `${type}(${args + unit}) `
    }
    else {
      styles.styles[type] = `${args}`
    }
    this.currentStepAnimates[this.next] = styles
  }

  _animateRun(styles: AnimationStyles = {}, config: StepConfig = {}): Promise<void> {
    const ref = this.$.$refs.ani?.ref
    if (!ref) {
      return Promise.resolve()
    }
    return new Promise((resolve) => {
      nvueAnimation.transition(ref, {
        styles,
        ...config,
      }, () => {
        resolve()
      })
    })
  }

  _nvueNextAnimate(animates: Record<number, AnimationStep>, step: number = 0, fn?: () => void): void {
    const obj = animates[step]
    if (obj) {
      const { styles, config } = obj
      this._animateRun(styles, config).then(() => {
        step += 1
        this._nvueNextAnimate(animates, step, fn)
      })
    }
    else {
      this.currentStepAnimates = {}
      if (typeof fn === 'function') {
        fn()
      }
      this.isEnd = true
    }
  }

  step(config: StepConfig = {}): MPAnimationWithMethods {
    // #ifndef APP-NVUE
    this.animation.step(config)
    // #endif
    // #ifdef APP-NVUE
    if (this.currentStepAnimates[this.next]) {
      this.currentStepAnimates[this.next].config = Object.assign({}, this.options, config)
      this.currentStepAnimates[this.next].styles.transformOrigin = this.currentStepAnimates[this.next].config.transformOrigin
      this.next++
    }
    // #endif
    return this as unknown as MPAnimationWithMethods
  }

  run(fn?: () => void): void {
    // #ifndef APP-NVUE
    this.$.animationData = this.animation.export()
    this.$.timer = setTimeout(() => {
      if (typeof fn === 'function') {
        fn()
      }
    }, this.$.durationTime || 0)
    // #endif
    // #ifdef APP-NVUE
    this.isEnd = false
    const ref = this.$.$refs.ani?.ref
    if (!ref)
      return
    this._nvueNextAnimate(this.currentStepAnimates, 0, fn)
    this.next = 0
    // #endif
  }
}

// 动态添加动画方法
allAnimateTypes.forEach((type: string) => {
  (MPAnimation.prototype as any)[type] = function (...args: any[]): MPAnimationWithMethods {
    // #ifndef APP-NVUE
    this.animation[type](...args)
    // #endif
    // #ifdef APP-NVUE
    this._nvuePushAnimates(type, args)
    // #endif
    return this as MPAnimationWithMethods
  }
})

export function createAnimation(option: AnimationOption = {}, _this: VueComponentInstance): MPAnimationWithMethods | undefined {
  if (!_this)
    return undefined

  // 清除之前的定时器
  if (_this.timer) {
    clearTimeout(_this.timer)
  }

  return new MPAnimation(option, _this) as MPAnimationWithMethods
}

```
