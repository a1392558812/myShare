# åˆ‡æ°´æœ

[æ•ˆæœæ¼”ç¤º](https://awen-blog.netlify.app/#/demo/fruit-game)

// ğŸ‘‡ğŸ‘‡ğŸ‘‡ æºç å¯å¤åˆ¶åˆ°[æ¼”ç»ƒåœºè°ƒè¯•](https://awen-blog.netlify.app/#/demo/playground)ï¼Œç°å·²æ”¯æŒ unocss (ä½¿ç”¨ tailwind é¢„è®¾)

```html
<template>
  <div
    class="w-screen h-screen overflow-hidden bg-[linear-gradient(135deg,_#7f7fd5_0%,_#86a8e7_50%,_#91eae4_100%)] select-none [font-family:Arial,sans-serif] relative"
  >
    <div
      v-if="gameState === 'start'"
      class="w-full h-full flex flex-col items-center justify-center text-[white] text-center p-8 box-border"
    >
      <h1 class="text-[3rem] mb-4 [text-shadow:0_2px_10px_rgba(0,_0,_0,_0.3)]">
        æ°´æœå¿è€…
      </h1>
      <p class="text-[1.2rem] mb-8 max-w-[500px]">æ»‘åŠ¨å±å¹•åˆ‡æ°´æœï¼Œé¿å¼€ç‚¸å¼¹ï¼</p>
      <button
        @click="startGame"
        class="start-button px-8 py-[0.8rem] text-[1.2rem] bg-[#ff6b6b] text-[white] border-none rounded-[30px] cursor-pointer [transition:all_0.3s_ease] [box-shadow:0_4px_15px_rgba(0,_0,_0,_0.2)]"
      >
        å¼€å§‹æ¸¸æˆ
      </button>
      <div class="flex justify-center gap-[2rem] mt-12">
        <div class="flex flex-col items-center gap-[0.5rem] text-[white]">
          <span class="text-[1.8rem] [text-shadow:0_2px_5px_rgba(0,_0,_0,_0.2)]"
            >âœ‹</span
          >
          <span>æ»‘åŠ¨åˆ‡æ°´æœ</span>
        </div>
        <div class="flex flex-col items-center gap-[0.5rem] text-[white]">
          <span class="text-[1.8rem] [text-shadow:0_2px_5px_rgba(0,_0,_0,_0.2)]"
            >ğŸ’£</span
          >
          <span>é¿å¼€ç‚¸å¼¹ğŸ’£</span>
        </div>
        <div class="flex flex-col items-center gap-[0.5rem] text-[white]">
          <span class="text-[1.8rem] [text-shadow:0_2px_5px_rgba(0,_0,_0,_0.2)]"
            >â¤ï¸</span
          >
          <span>â¤ï¸æ²¡äº†æ¸¸æˆç»“æŸ</span>
        </div>
      </div>
    </div>

    <div v-else-if="gameState === 'playing'" class="w-full h-full relative">
      <div
        class="absolute top-[0] left-[0] right-[0] p-4 flex justify-between items-center text-[white] z-10 bg-[rgba(0,_0,_0,_0.1)]"
      >
        <div
          class="flex items-center gap-[0.5rem] text-[1.1rem] [text-shadow:0_1px_3px_rgba(0,_0,_0,_0.3)]"
        >
          <span>â­</span>
          <span>åˆ†æ•°: {{ score }}</span>
        </div>
        <div
          class="flex items-center gap-[0.2rem] text-[1.1rem] [text-shadow:0_1px_3px_rgba(0,_0,_0,_0.3)]"
        >
          <span v-for="i in 6" :key="i" :class="{ 'heart-lost': i > lives }"
            >â¤ï¸</span
          >
        </div>
        <div
          class="flex items-center gap-[0.5rem] text-[1.1rem] [text-shadow:0_1px_3px_rgba(0,_0,_0,_0.3)]"
        >
          <span>âš¡</span>
          <span>ç­‰çº§: {{ level }}</span>
        </div>
      </div>

      <!-- åŠ åˆ†æç¤º -->
      <div
        v-if="bonusText"
        class="absolute text-[white] [font-weight:bold] [text-shadow:0_2px_4px_rgba(0,_0,_0,_0.3)] pointer-events-none [transition:opacity_0.3s_ease] animate-[float-up_1s_ease_forwards]"
        :style="{
          left: `${bonusPosition.x}%`,
          top: `${bonusPosition.y}%`,
          opacity: bonusOpacity
        }"
      >
        {{ bonusText }}
      </div>

      <!-- æ¸¸æˆåŒºåŸŸ -->
      <div
        class="game-area w-full h-full relative overflow-hidden"
        @mousedown="startSwipe"
        @mousemove="handleSwipe"
        @mouseup="endSwipe"
        @touchstart="startSwipe"
        @touchmove="handleSwipe"
        @touchend="endSwipe"
      >
        <!-- æ°´æœå’Œç‚¸å¼¹ -->
        <div
          v-for="(item, index) in items"
          :key="item.id"
          :class="['game-item', item.type]"
          :style="{
          left: `${item.x}%`,
          top: `${item.y}%`,
          transform: `translate(-50%, -50%) rotate(${item.rotation}deg)`,
          opacity: item.opacity,
          fontSize: `${item.size}px`
        }"
          ref="gameItems"
        >
          <span v-if="!item.sliced">{{ item.emoji }}</span>

          <!-- åˆ‡å¼€æ•ˆæœ -->
          <div
            v-if="item.sliced"
            class="absolute w-full h-full flex items-center justify-center select-none"
          >
            <span
              class="absolute -translate-x-[20%] translate-y-[0] -rotate-[15deg] opacity-80"
              >{{ item.emoji }}</span
            >
            <span
              class="absolute translate-x-[20%] translate-y-[0] rotate-[15deg] opacity-80"
              >{{ item.emoji }}</span
            >
          </div>
        </div>

        <!-- æ»‘åŠ¨è½¨è¿¹ -->
        <div
          class="absolute top-[0] left-[0] w-full h-full bg-[rgba(255,_255,_255,_0.5)] pointer-events-none [transition:opacity_0.1s_ease]"
          :style="{
            'clip-path': trailPath,
            opacity: trailOpacity
          }"
        ></div>
      </div>
    </div>

    <div
      v-else-if="gameState === 'end'"
      class="end-screen w-full h-full flex flex-col items-center justify-center text-[white] bg-[rgba(0,_0,_0,_0.5)] text-center p-8 box-border"
    >
      <h2 class="text-[2.5rem] mb-6">æ¸¸æˆç»“æŸ</h2>
      <div class="mb-8">
        <span class="text-[1.2rem] opacity-80">æœ€ç»ˆå¾—åˆ†</span>
        <p class="text-[3rem] mx-[0] my-2 [font-weight:bold]">{{ score }}</p>
      </div>
      <div class="flex gap-[3rem] mb-8">
        <div class="text-center">
          <span class="text-[1rem] opacity-80 block">æ°´æœåˆ‡æ•°</span>
          <p class="text-[1.5rem] ml-[0] mr-[0] my-2">{{ fruitsSliced }}</p>
        </div>
        <div class="text-center">
          <span class="text-[1rem] opacity-80 block">æœ€é«˜ç­‰çº§</span>
          <p class="text-[1.5rem] ml-[0] mr-[0] my-2">{{ level }}</p>
        </div>
      </div>
      <button
        @click="restartGame"
        class="restart-button px-8 py-[0.8rem] text-[1.2rem] bg-[#4ecdc4] text-[white] border-none rounded-[30px] cursor-pointer [transition:all_0.3s_ease] [box-shadow:0_4px_15px_rgba(0,_0,_0,_0.2)]"
      >
        å†ç©ä¸€æ¬¡
      </button>
    </div>
  </div>
</template>

<script setup>
  import { ref, onUnmounted } from "vue";

  // æ¸¸æˆçŠ¶æ€s
  const gameState = ref("start"); // start, playing, end
  const score = ref(0);
  const lives = ref(6);
  const level = ref(1);
  const fruitsSliced = ref(0);
  const lastLifeAwardScore = ref(0); // lastå¥–åŠ±ç”Ÿå‘½å€¼æ—¶çš„åˆ†

  // åŠ åˆ†æç¤º
  const bonusText = ref("");
  const bonusPosition = ref({ x: 0, y: 0 });
  const bonusOpacity = ref(0);

  // ï¼ˆæ°´æœå’Œç‚¸å¼¹ï¼‰
  const items = ref([]);
  const gameItems = ref([]);

  // æ»‘åŠ¨è½¨è¿¹
  const trailPoints = ref([]);
  const trailPath = ref("");
  const trailOpacity = ref(0);
  const isSwiping = ref(false); // æ˜¯å¦æ­£åœ¨æ»‘åŠ¨

  // æ¸¸æˆå‚æ•°
  const spawnInterval = ref(1500); // ç‰©å“ç”Ÿæˆé—´éš”/ms
  const itemSpeed = ref(1); // ç‰©å“ç§»åŠ¨é€Ÿåº¦
  const maxItems = ref(50); // æœ€å¤§åŒæ—¶å­˜åœ¨çš„ç‰©å“æ•°é‡

  const fruitTypes = [
    { type: "fruit", emoji: "ğŸ", points: 10 },
    { type: "fruit", emoji: "ğŸ‹", points: 10 },
    { type: "fruit", emoji: "ğŸ“", points: 15 },
    { type: "fruit", emoji: "ğŸ‡", points: 10 },
    { type: "fruit", emoji: "ğŸ‰", points: 20 },
    { type: "bomb", emoji: "ğŸ’£", points: -30 },
  ];

  // æ¸¸æˆå¾ªç¯çš„setInterval
  let gameLoop = null;
  let spawnTimer = null;

  // å¼€å§‹æ¸¸æˆ
  const startGame = () => {
    gameState.value = "playing";
    score.value = 0;
    lives.value = 6;
    level.value = 1;
    fruitsSliced.value = 0;
    lastLifeAwardScore.value = 0;
    items.value = [];
    bonusText.value = "";

    // é‡ç½®æ¸¸æˆå‚æ•°
    spawnInterval.value = 1500;
    itemSpeed.value = 1;
    maxItems.value = 50;

    startSpawning();

    gameLoop = setInterval(updateGame, 16);
  };

  // å¼€å¯å®šæ—¶å™¨åˆ·ç”»é¢
  const startSpawning = () => {
    spawnTimer = setInterval(() => {
      if (gameState.value === "playing") {
        spawnItem();
      }
    }, spawnInterval.value);
  };

  const createSpawnItem = () => {
    // éšæœºé€‰æ‹©ç‰©å“ç±»å‹ï¼ˆ80%æ°´æœï¼Œ20%ç‚¸å¼¹ï¼‰
    const isBomb = Math.random() < 0.2;
    const itemType = isBomb
      ? fruitTypes.find((t) => t.type === "bomb")
      : fruitTypes[Math.floor(Math.random() * (fruitTypes.length - 1))];

    // éšæœºä½ç½®å’Œåˆå§‹è§’åº¦
    const startX = Math.random() * 80 + 10; // 10% - 90%
    const startY = 100; // ä»åº•éƒ¨å¼€å§‹

    const angle = (Math.random() * 60 - 30) * (Math.PI / 180); // -30Â° åˆ° 30Â°
    const speed = itemSpeed.value * (0.8 + Math.random() * 0.4); // éšæœºé€Ÿåº¦å˜åŒ–ï¼Œçœ‹èµ·æ¥ä¸æ‹‰å§†é€Ÿåº¦æƒŸä¸€
    const vx = Math.sin(angle) * speed;
    const vy = -Math.cos(angle) * speed; // è´Ÿå·è¡¨ç¤ºå†²ä¸Š

    const gravity = 0.015;

    return {
      id: Date.now() + Math.random(), // ä½¿ç”¨å”¯ä¸€IDé¿å…æ¸²æŸ“é—®é¢˜
      ...itemType,
      x: startX,
      y: startY,
      vx,
      vy,
      gravity,
      rotation: Math.random() * 360,
      rotationSpeed: (Math.random() - 0.5) * 2,
      sliced: false,
      opacity: 1,
      size: isBomb ? 40 : 36 + Math.random() * 8, // å¤§æ¦‚èŒƒå›´é‡Œéšæœºå¤§å°
    };
  };

  // ç”ŸæˆspawnItemç‰©å“
  const spawnItem = () => {
    const newArr = [];
    for (let i = 0; i < level.value; i++) {
      if (items.value.length + i < maxItems.value) {
        // é¿å…è¶…å‡ºæœ€å¤§ç‰©å“æ•°
        newArr.push(createSpawnItem());
      } else {
        break;
      }
    }
    items.value = items.value.concat(newArr);
  };

  // æ›´æ–°æ¸¸æˆçŠ¶æ€
  const updateGame = () => {
    // æ›´æ–°æ‰€æœ‰ç‰©å“
    for (let i = items.value.length - 1; i >= 0; i--) {
      const item = items.value[i];

      // å¦‚æœå·²åˆ‡å¼€ï¼Œåº”ç”¨æ·¡å‡ºæ•ˆæœ
      if (item.sliced) {
        item.opacity -= 0.1;
        if (item.opacity <= 0) {
          items.value.splice(i, 1);
        }
        continue;
      }

      // å¹³æ»‘æ›´æ–°ä½ç½®
      item.x += item.vx;
      item.y += item.vy;
      item.vy += item.gravity; // åº”ç”¨é‡åŠ›
      item.rotation += item.rotationSpeed;

      // é™åˆ¶æœ€å¤§é€Ÿåº¦ï¼Œé˜²æ­¢æŠ–åŠ¨
      item.vy = Math.min(item.vy, 3);

      // æ£€æŸ¥æ˜¯å¦è¶…å‡ºå±å¹•èŒƒå›´
      if (item.y > 110) {
        items.value.splice(i, 1);
      } else if (item.x < -10 || item.x > 110) {
        items.value.splice(i, 1);
      }
    }

    // æ£€æŸ¥ç­‰çº§æå‡
    checkLevelUp();

    // æ£€æŸ¥æ˜¯å¦å¥–åŠ±ç”Ÿå‘½å€¼
    checkLifeAward();
  };

  // æ£€æŸ¥ç­‰çº§æå‡
  const checkLevelUp = () => {
    const newLevel = Math.floor(score.value / 100) + 1;
    if (newLevel > level.value) {
      level.value = newLevel;

      // éšç€ç­‰çº§ä¸Šå¼ºåº¦
      spawnInterval.value = Math.max(500, 1500 - (level.value - 1) * 80);
      itemSpeed.value = 1 + (level.value - 1) * 0.1; // ç¼“æ…¢å¢åŠ é€Ÿåº¦
      maxItems.value = Math.min(10, 5 + Math.floor((level.value - 1) / 2));
    }
  };

  // æ£€æŸ¥æ˜¯å¦å¥–åŠ±ç”Ÿå‘½å€¼
  const checkLifeAward = () => {
    // æ¯è·å¾—100åˆ†ä¸”ç”Ÿå‘½å€¼æœªæ»¡666æ—¶å¥–åŠ±1ç‚¹ç”Ÿå‘½å€¼
    if (lives.value < 6 && score.value - lastLifeAwardScore.value >= 100) {
      lives.value++;
      lastLifeAwardScore.value = score.value;

      // æ˜¾ç¤ºåŠ åˆ†æç¤º
      showBonusText("+1 ç”Ÿå‘½!", 50, 50);
    }
  };

  // æ˜¾ç¤ºåŠ åˆ†æç¤º
  const showBonusText = (text, x, y) => {
    bonusText.value = text;
    bonusPosition.value = { x, y };
    bonusOpacity.value = 1;

    // æ·¡å‡ºåŠ¨ç”»
    setTimeout(() => {
      const fadeInterval = setInterval(() => {
        bonusOpacity.value -= 0.05;
        if (bonusOpacity.value <= 0) {
          clearInterval(fadeInterval);
          bonusText.value = "";
        }
      }, 30);
    }, 1000);
  };

  // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
  const checkGameOver = () => {
    if (lives.value <= 0) {
      endGame();
    }
  };

  // ç»“æŸæ¸¸æˆ
  const endGame = () => {
    gameState.value = "end";
    clearInterval(gameLoop);
    clearInterval(spawnTimer);
  };

  // é‡æ–°å¼€å§‹æ¸¸æˆ
  const restartGame = () => {
    clearInterval(gameLoop);
    clearInterval(spawnTimer);
    startGame();
  };

  // å¤„ç†æ»‘åŠ¨å¼€å§‹
  const startSwipe = (e) => {
    isSwiping.value = true;
    trailPoints.value = [];
    addTrailPoint(e);
    updateTrailPath();
    trailOpacity.value = 1;
  };

  // å¤„ç†æ»‘åŠ¨ä¸­
  const handleSwipe = (e) => {
    if (!isSwiping.value) return;
    addTrailPoint(e);
    updateTrailPath();
    checkSlicedItems();
  };

  // å¤„ç†æ»‘åŠ¨ç»“æŸ
  const endSwipe = () => {
    isSwiping.value = false;

    // æ·¡å‡ºè½¨è¿¹
    const fadeTrail = setInterval(() => {
      trailOpacity.value -= 0.1;
      if (trailOpacity.value <= 0) {
        clearInterval(fadeTrail);
        trailPoints.value = [];
        updateTrailPath();
      }
    }, 50);
  };

  // æ·»åŠ è½¨è¿¹ç‚¹
  const addTrailPoint = (e) => {
    // å¤„ç†è§¦æ‘¸å’Œé¼ æ ‡äº‹ä»¶
    const clientX = e.type.includes("touch") ? e.touches[0].clientX : e.clientX;
    const clientY = e.type.includes("touch") ? e.touches[0].clientY : e.clientY;

    // è·å–æ¸¸æˆåŒºåŸŸä½ç½®å’Œå°ºå¯¸
    const gameArea = document.querySelector(".game-area");
    if (!gameArea) return;

    const rect = gameArea.getBoundingClientRect();

    // è½¬æ¢ä¸ºç›¸å¯¹æ¸¸æˆåŒºåŸŸçš„ç™¾åˆ†æ¯”
    const x = ((clientX - rect.left) / rect.width) * 100;
    const y = ((clientY - rect.top) / rect.height) * 100;

    trailPoints.value.push({ x, y });

    // é™åˆ¶è½¨è¿¹ç‚¹æ•°é‡ï¼Œä¿æŒæ€§èƒ½
    if (trailPoints.value.length > 30) {
      trailPoints.value.shift();
    }
  };

  // æ›´æ–°è½¨è¿¹è·¯å¾„
  const updateTrailPath = () => {
    if (trailPoints.value.length < 2) {
      trailPath.value = "";
      return;
    }

    let path = `polygon(`;

    // åˆ›å»ºä¸»è·¯å¾„
    trailPoints.value.forEach((point, index) => {
      path += `${point.x}% ${point.y}%, `;
    });

    // åˆ›å»ºåå‘è·¯å¾„ï¼Œå½¢æˆä¸€ä¸ªé—­åˆåŒºåŸŸ
    for (let i = trailPoints.value.length - 1; i >= 0; i--) {
      const point = trailPoints.value[i];
      // æ·»åŠ åç§»ï¼Œä½¿è½¨è¿¹å¯è§
      path += `${point.x + 2}% ${point.y + 2}%, `;
    }

    // é—­åˆè·¯å¾„
    path = path.slice(0, -2) + ")";
    trailPath.value = path;
  };

  // æ£€æŸ¥æ˜¯å¦åˆ‡åˆ°ç‰©å“
  const checkSlicedItems = () => {
    if (!gameItems.value.length || trailPoints.value.length < 2) return;

    // ç®€åŒ–è½¨è¿¹ä¸ºçº¿æ®µï¼Œç”¨äºç¢°æ’æ£€æµ‹
    const lastPoint = trailPoints.value[trailPoints.value.length - 1];
    const prevPoint = trailPoints.value[trailPoints.value.length - 2];

    gameItems.value.forEach((el, index) => {
      const item = items.value[index];
      if (!item || item.sliced) return;

      // è·å–å…ƒç´ ä½ç½®
      const rect = el.getBoundingClientRect();
      const gameArea = document.querySelector(".game-area");
      if (!gameArea) return;

      const gameRect = gameArea.getBoundingClientRect();

      // è®¡ç®—ç‰©å“åœ¨æ¸¸æˆåŒºåŸŸä¸­çš„ç›¸å¯¹ä½ç½®
      const itemX =
        ((rect.left + rect.width / 2 - gameRect.left) / gameRect.width) * 100;
      const itemY =
        ((rect.top + rect.height / 2 - gameRect.top) / gameRect.height) * 100;
      const itemSize =
        (Math.max(rect.width, rect.height) / gameRect.width) * 50; // ä¼°ç®—å°ºå¯¸

      // æ£€æŸ¥ç‰©å“æ˜¯å¦åœ¨çº¿æ®µé™„è¿‘ï¼ˆç®€å•ç¢°æ’æ£€æµ‹ï¼‰
      const distance = linePointDistance(
        prevPoint.x,
        prevPoint.y,
        lastPoint.x,
        lastPoint.y,
        itemX,
        itemY
      );

      if (distance < itemSize) {
        sliceItem(index, itemX, itemY);
      }
    });
  };

  // è®¡ç®—ç‚¹åˆ°çº¿æ®µçš„è·ç¦»
  const linePointDistance = (x1, y1, x2, y2, px, py) => {
    // çº¿æ®µé•¿åº¦çš„å¹³æ–¹
    const l2 = Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2);
    if (l2 === 0) return Math.hypot(px - x1, py - y1);

    // è®¡ç®—æŠ•å½±æ¯”ä¾‹
    let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2;
    t = Math.max(0, Math.min(1, t));

    // æŠ•å½±ç‚¹
    const projX = x1 + t * (x2 - x1);
    const projY = y1 + t * (y2 - y1);

    // è·ç¦»
    return Math.hypot(px - projX, py - projY);
  };

  // åˆ‡å¼€ç‰©å“
  const sliceItem = (index, x, y) => {
    const item = items.value[index];
    if (!item || item.sliced) return;

    item.sliced = true;

    // å¤„ç†åˆ†æ•°
    if (item.type === "fruit") {
      score.value += item.points;
      fruitsSliced.value++;

      // æ˜¾ç¤ºåŠ åˆ†æç¤º
      showBonusText(`+${item.points}`, x, y);
    } else if (item.type === "bomb") {
      score.value = Math.max(0, score.value + item.points); // ç‚¸å¼¹æ‰£åˆ†ï¼Œæœ€ä½ä¸º0
      lives.value = Math.max(0, lives.value - 1);
      checkGameOver();

      // æ˜¾ç¤ºæ‰£åˆ†æç¤º
      showBonusText(`${item.points}`, x, y);
    }
  };

  // æ¸…ç†è®¡æ—¶å™¨
  onUnmounted(() => {
    clearInterval(gameLoop);
    clearInterval(spawnTimer);
  });
</script>

<style scoped>
  .start-button:hover {
    background-color: #ff5252;
    transform: translateY(-3px);
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
  }

  .heart-lost {
    color: #ff6b6b;
    opacity: 0.5;
  }

  .game-item {
    position: absolute;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.1s ease;
    z-index: 5;
    text-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    will-change: transform, opacity;
    user-select: none;
  }

  .restart-button:hover {
    background-color: #3dbbaf;
    transform: translateY(-3px);
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
  }

  @keyframes float-up {
    from {
      transform: translateY(0);
    }

    to {
      transform: translateY(-30px);
    }
  }
</style>
```
