# useScrollLock

锁定滚动容器的滚动，防止滚动穿透。

```typescript
import { ref, onUnmounted } from "vue";

export type ScrollContainer =
  | string
  | HTMLElement
  | null
  | undefined
  | { value: HTMLElement | null; [key: string]: any };

export const useScrollLock = (container: ScrollContainer = "body") => {
  const originalStyles = ref<{
    overflow: string;
    paddingRight: string;
    scrollTop: number;
    scrollLeft: number;
  } | null>(null);

  // 锁定计数器（处理嵌套锁定,如多层弹窗、嵌套组件同时需要锁定滚动时）
  /**
   * 当同一个滚动容器【如<body>或某个自定义容器】被多次锁定时,（例如：打开一个模态框后，在该模态框内再打开另一个子模态框）,
   * lockCount 用于记录锁定次数，确保只有当所有锁定都被解除时，才真正恢复容器的原始滚动状态。
   *
   *
   * 假设第一层模态框调用 lock() 锁定滚动，此时容器样式被修改（overflow: hidden 等）,
   * 第二层模态框再次调用 lock() 时，会重复修改样式（如重复增加 paddingRight），导致样式错乱
   * 关闭第二层模态框时调用 unlock()，会直接恢复原始样式，导致第一层模态框还未关闭，滚动就提前解锁（出现滚动穿透）
   *
   */
  const lockCount = ref(0);

  const getContainer = (): HTMLElement => {
    if (!container) return document.body;

    if (typeof container === "string") {
      const el = document.querySelector<HTMLElement>(container);
      if (el) {
        return el;
      }
      console.warn(
        `滚动容器选择器 "${container}" 不存在, 降级到 document.body`
      );
      return document.body;
    }

    if (container instanceof HTMLElement) {
      return container;
    }

    if (container.value && container.value instanceof HTMLElement) {
      return container.value;
    }

    return document.body;
  };

  const getScrollbarWidth = (el: HTMLElement): number => {
    if (
      el.scrollHeight <= el.clientHeight &&
      el.scrollWidth <= el.clientWidth
    ) {
      return 0;
    }
    // 滚动条宽度 = 总宽度 - 内容宽度（不含滚动条）
    return el.offsetWidth - el.clientWidth;
  };

  const lock = () => {
    if (lockCount.value === 0) {
      const containerEl = getContainer();
      originalStyles.value = {
        overflow: containerEl.style.overflow || "",
        paddingRight: containerEl.style.paddingRight || "",
        scrollTop:
          containerEl === document.body
            ? window.scrollY
            : containerEl.scrollTop,
        scrollLeft:
          containerEl === document.body
            ? window.scrollX
            : containerEl.scrollLeft,
      };

      // 计算滚动条宽度，补偿padding避免容器内容抖动
      const scrollbarWidth = getScrollbarWidth(containerEl);
      if (scrollbarWidth > 0) {
        const currentPadding = parseFloat(
          window.getComputedStyle(containerEl).paddingRight
        );
        containerEl.style.paddingRight = `${currentPadding + scrollbarWidth}px`;
      }

      containerEl.style.overflow = "hidden";
    }
    lockCount.value++;
  };

  const unlock = () => {
    if (lockCount.value <= 0) return;
    lockCount.value--;

    if (lockCount.value === 0 && originalStyles.value) {
      const containerEl = getContainer();
      const { overflow, paddingRight, scrollTop, scrollLeft } =
        originalStyles.value;

      containerEl.style.overflow = overflow;
      containerEl.style.paddingRight = paddingRight;

      if (containerEl === document.body) {
        window.scrollTo(scrollLeft, scrollTop);
      } else {
        containerEl.scrollTop = scrollTop;
        containerEl.scrollLeft = scrollLeft;
      }

      originalStyles.value = null;
    }
  };

  onUnmounted(() => {
    while (lockCount.value > 0) {
      unlock();
    }
  });

  return { lock, unlock, getContainer };
};
```

## body 滚动使用

```html
<template>
  <button class="scroll-lock-btn" @click="toggleLock">切换滚动锁定</button>
</template>

<script setup lang="ts">
  import { useScrollLock } from "./useScrollLock";

  const { lock, unlock } = useScrollLock();
  let isLocked = false;

  const toggleLock = () => {
    isLocked ? unlock() : lock();
    isLocked = !isLocked;
  };
</script>
<style>
  body {
    height: 200vh;
    width: 200vw;
  }
  .scroll-lock-btn {
    position: fixed;
    top: 20px;
    left: 20px;
    z-index: 9999;
  }
</style>
```

## 元素滚动使用

```html
<template>
  <div class="custom-container">
    <div v-for="i in 50" :key="i" class="item">{{ i }}</div>
  </div>
  <button @click="toggleLock">锁定/解锁容器滚动</button>
</template>

<script setup lang="ts">
  import { useScrollLock } from "./composables/useScrollLock";
  const { lock, unlock } = useScrollLock(".custom-container");
  let isLocked = false;
  const toggleLock = () => {
    isLocked ? unlock() : lock();
    isLocked = !isLocked;
  };
</script>

<style>
  .custom-container {
    width: 300px;
    height: 400px;
    overflow: auto;
    border: 1px solid #ccc;
    box-sizing: border-box;
  }
  .item {
    height: 50px;
    width: 600px;
    line-height: 50px;
    border-bottom: 1px solid #eee;
  }
</style>
```

## 滚动嵌套使用

> 滚动锁定协同（基于 lockCount）
> 父子组件均使用 useScrollLock() 锁定默认容器（body）。
> 打开父模态框：lockCount 从 0 → 1（执行锁定）。
> 打开子模态框：lockCount 从 1 → 2（仅计数，不重复锁定）。
> 关闭子模态框：lockCount 从 2 → 1（不解锁，保持锁定）。
> 关闭父模态框：lockCount 从 1 → 0（执行解锁，恢复滚动）。

### app.vue

```html
<template>
  <div class="app">
    <h1>模态框嵌套</h1>
    <button class="open-btn" @click="isParentOpen = true">打开父模态框</button>
    <ParentModal v-model="isParentOpen" @close="isParentOpen = false" />
  </div>
</template>

<script setup>
  import { ref } from "vue";
  import ParentModal from "./ParentModal.vue";
  const isParentOpen = ref(false);
</script>

<style scoped>
  .app {
    padding: 20px;
    height: 200vh;
  }

  .open-btn {
    padding: 10px 20px;
    background: #3498db;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 1rem;
  }

  .open-btn:hover {
    background: #2980b9;
  }
</style>
```

### model.css

```css
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.modal-container {
  background: #fff;
  padding: 24px;
  border-radius: 8px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
  width: 90%;
  max-width: 500px;
}

.modal-title {
  margin: 0 0 16px;
  color: #333;
  font-size: 1.25rem;
}

.modal-btn {
  padding: 8px 16px;
  margin-right: 12px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.9rem;
}

.modal-btn:not(.close-btn) {
  background: #42b983;
  color: white;
}

.modal-btn:not(.close-btn):hover {
  background: #359e75;
}

.close-btn {
  background: #f5f5f5;
  color: #666;
}

.close-btn:hover {
  background: #e0e0e0;
}

.parent-modal {
  border: 2px solid #42b983;
}
```

### ParentModal.vue

```html
<template>
  <div v-if="modelValue" class="modal-overlay" @click.self="handleClose">
    <div class="modal-container parent-modal">
      <h2 class="modal-title">父模态框</h2>
      <p>这是父级模态框，可打开子模态框</p>
      <button class="modal-btn" @click="isChildOpen = true">
        打开子模态框
      </button>
      <button class="modal-btn close-btn" @click="handleClose">
        关闭父模态框
      </button>
      <ChildModal v-model="isChildOpen" @close="isChildOpen = false" />
    </div>
  </div>
</template>

<script setup>
  import { ref, watch } from "vue";
  import { useScrollLock } from "./useScrollLock";
  import ChildModal from "./ChildModal.vue";
  const props = defineProps({
    modelValue: {
      type: Boolean,
      default: false,
    },
  });
  const emit = defineEmits(["update:modelValue", "close"]);
  const isChildOpen = ref(false);
  const { lock, unlock } = useScrollLock();
  watch(
    () => props.modelValue,
    (newVal) => {
      if (newVal) {
        lock();
      } else {
        unlock();
      }
    },
    { immediate: true }
  );
  const handleClose = () => {
    emit("update:modelValue", false);
    emit("close");
  };
</script>

<style scoped>
  @import "./model.css";
</style>
```

### ChildModal.vue

```html
<template>
  <div v-if="modelValue" class="child-overlay">
    <div class="modal-container child-modal">
      <h3 class="modal-title">子模态框</h3>
      <p>这是嵌套在父模态框中的子模态框</p>
      <button class="modal-btn close-btn" @click="handleClose">
        关闭子模态框
      </button>
    </div>
  </div>
</template>

<script setup>
  import { watch } from "vue";
  import { useScrollLock } from "./useScrollLock";
  const props = defineProps({
    modelValue: {
      type: Boolean,
      default: false,
    },
  });
  const emit = defineEmits(["update:modelValue", "close"]);
  const { lock, unlock } = useScrollLock();
  watch(
    () => props.modelValue,
    (newVal) => {
      if (newVal) {
        lock(); // 显示时锁定（lockCount +1）
      } else {
        unlock(); // 隐藏时解锁（lockCount -1）
      }
    },
    { immediate: true }
  );
  const handleClose = () => {
    emit("update:modelValue", false);
    emit("close");
  };
</script>

<style scoped>
  @import "./model.css";

  .child-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.3);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1010;
  }

  .child-modal {
    max-width: 300px;
    border: 2px solid #3498db;
  }
</style>
```
