# uniapp 的一个 tabble 组件

> 优秀第三方库:【[wot-ui 的 Table 表格](https://wot-ui.cn/component/table.html)】，支持锁定表头和列
> 锁定表头： 即分离 table-header 和 table-body， 将 table-body 高度固定，则可以实现锁定表头效果
> 锁定列：我的这个组件做不到，我的组件是第一层循环 `v-for in dataList` 渲染行，第二层循环 `v-for in columns` 渲染列的，这样无法实现锁定列效果.锁定列需要把表格拆成两部分，左侧一部分是锁定列，右侧一部分是非锁定列，然后两个部分并排显示，并且行高要一致才行，这样就比较麻烦了，所以锁定列功能就不做了,优先推荐好的作品`【wot-ui】`或者 uni 插件市场其他优秀作者

## table.vue

```html
<template>
  <scroll-view
    :id="computedTableId"
    :scroll-x="scrollX"
    :scroll-y="scrollY"
    :upper-threshold="upperThreshold"
    :lower-threshold="lowerThreshold"
    :scroll-top="scrollTop"
    :scroll-left="scrollLeft"
    :scroll-into-view="scrollIntoView"
    :scroll-with-animation="scrollWithAnimation"
    :enable-back-to-top="enableBackToTop"
    :show-scrollbar="showScrollbar"
    :refresher-enabled="refresherEnabled"
    :refresher-threshold="refresherThreshold"
    :refresher-default-style="refresherDefaultStyle"
    :refresher-background="refresherBackground"
    :refresher-triggered="refresherTriggered"
    :enable-flex="enableFlex"
    :scroll-anchoring="scrollAnchoring"
    :style="customStyle"
    @scrolltoupper="onScrollToUpper"
    @scrolltolower="onScrollToLower"
    @scroll="onScroll"
    @refresherpulling="onRefresherPulling"
    @refresherrefresh="onRefresherRefresh"
    @refresherrestore="onRefresherRestore"
    @refresherabort="onRefresherAbort"
  >
    <tableHeader
      v-if="ifShowHeader"
      :border="border"
      :border-radius="borderRadius"
      :column="column"
      :data="data"
    >
      <template #default="{ col, columnIndex }">
        <slot name="headerCell" :col="col" :column-index="columnIndex" />
      </template>
    </tableHeader>

    <view
      :style="[{ position: 'relative' }, showLoading ? { minHeight: '100vh' } : {}]"
    >
      <template v-if="data.length">
        <tableItem
          v-for="(item, dataIndex) in data"
          :key="item.id"
          :details="item"
          :border="border"
          :border-radius="borderRadius"
          :data-index="dataIndex"
          :column="column"
          :data-length="data.length"
          @cell-click="onTableCellClick"
          @cell-text-click="onTableCellTextClick"
        >
          <template #default="{ col, columnIndex }">
            <slot
              name="cell"
              :data-item="item"
              :data-index="dataIndex"
              :col="col"
              :column-index="columnIndex"
            />
          </template>
        </tableItem>
      </template>
      <template v-if="loading && showLoading">
        <view
          :style="[{ backgroundColor: 'rgba(255,255,255,0.8)' }, loadingCustomStyle]"
          class="absolute bottom-0 left-0 right-0 top-0 flex items-center justify-center"
        >
          <slot name="loading">
            <uv-loading-icon
              :timing-function="loadingTimingFunction"
              :duration="loadingDuration"
              :inactive-color="loadingInactiveColor"
              :color="loadingColor"
              :vertical="loadingVertical"
              :size="loadingSize"
              :mode="loadingMode"
              :text="loadingText"
              :text-style="loadingTextStyle"
            />
          </slot>
        </view>
      </template>
      <template v-if="!data.length && !loading">
        <slot name="empty">
          <view
            :style="[
              { border, borderRadius },
              ifShowHeader
                ? { borderTop: 'none', borderRadius: `0 0 ${borderRadius} ${borderRadius}` }
                : {},
              emptyCustomStyle,
            ]"
            class="py-[60rpx]"
          >
            <uv-empty mode="list" />
          </view>
        </slot>
      </template>
    </view>
  </scroll-view>
</template>

<script setup lang="ts">
  import { computed } from "vue";
  import tableHeader from "./table-header.vue";
  import tableItem from "./table-item.vue";

  export interface ColumnType {
    label: string;
    headerStyle: AnyStyleType;
    cellStyle: AnyStyleType;
    align?: "left" | "center" | "right";
    width?: string;
    border?: string;
    keyName: string;
  }

  export interface ScrollPropsType {
    scrollX?: boolean;
    scrollY?: boolean;
    upperThreshold?: string;
    lowerThreshold?: string;
    scrollTop?: number | string; // Number / String 设置竖向滚动条位置
    scrollLeft?: number | string; // Number / String 设置横向滚动条位置
    scrollIntoView?: string; // 值应为某子元素id（id不能以数字开头）。设置哪个方向可滚动，则在哪个方向滚动到该元素
    scrollWithAnimation?: boolean; // Boolean false 在设置滚动条位置时使用动画过渡 app - nvue，微信小程序
    enableBackToTop?: boolean; // Boolean false iOS点击顶部状态栏、安卓双击标题栏时，滚动条返回顶部，只支持竖向 app - nvue，微信小程序
    showScrollbar?: boolean; // Boolean true 控制是否出现滚动条 App - nvue 2.1.5 +
    refresherEnabled?: boolean; // Boolean false 开启自定义下拉刷新 H5、app - vue 2.5.12 +, 微信小程序基础库2.10.1 +、小红书小程序
    refresherThreshold?: number; // Number 45 设置自定义下拉刷新阈值 H5、app - vue 2.5.12 +, 微信小程序基础库2.10.1 +、小红书小程序
    refresherDefaultStyle?: "black" | "white" | "none"; // String "black" 设置自定义下拉刷新默认样式，支持设置 black，white，none，none 表示不使用默认样式 H5、app - vue 2.5.12 +, 微信小程序基础库2.10.1 +、小红书小程序
    refresherBackground?: string; // "#FFF" 设置自定义下拉刷新区域背景颜色 H5、app - vue 2.5.12 +, 微信小程序基础库2.10.1 +、小红书小程序
    refresherTriggered?: boolean; // Boolean false 设置当前下拉刷新状态，true 表示下拉刷新已经被触发，false 表示下拉刷新未被触发 H5、app - vue 2.5.12 +, 微信小程序基础库2.10.1 +、小红书小程序
    enableFlex?: boolean; // Boolean false 启用 flexbox 布局。开启后，当前节点声明了 display: flex 就会成为 flex container，并作用于其孩子节点。 微信小程序 2.7.3、小红书小程序
    scrollAnchoring?: boolean; // Boolean false 开启 scroll anchoring 特性，即控制滚动位置不随内容变化而抖动，仅在 iOS 下生效，安卓下可参考 CSS overflow - anchor 属性。 微信小程序 2.8.2
  }

  export interface LoadingPropsType {
    loadingMode?: "spinner" | "circle" | "semicircle";
    loadingColor?: string;
    loadingSize?: string;

    loadingText?: string;
    loadingTextStyle?: AnyStyleType;

    loadingVertical?: boolean;
    loadingTimingFunction?: string;
    loadingDuration?: number;
    loadingInactiveColor?: string;
    loadingCustomStyle?: AnyStyleType;
  }

  export interface TablePropsType {
    showLoading?: boolean;
    tableId?: string;
    loading?: boolean;
    ifShowHeader?: boolean;
    border?: string;
    borderRadius?: string;
    column: ColumnType[];
    data: any[];
    customStyle?: AnyStyleType;
    emptyCustomStyle?: AnyStyleType;
  }

  const props = withDefaults(
    defineProps<TablePropsType & ScrollPropsType & LoadingPropsType>(),
    {
      showLoading: false,
      tableId: "",
      loading: false,
      ifShowHeader: true,
      border: "2rpx solid #e5e5e5",
      borderRadius: "12rpx",
      column: () => [],
      data: () => [],
      customStyle: () => ({}),
      emptyCustomStyle: () => ({}),

      scrollX: false,
      scrollY: false,
      upperThreshold: "50",
      lowerThreshold: "50",
      scrollTop: 0,
      scrollLeft: 0,
      scrollIntoView: "",
      scrollWithAnimation: false,
      enableBackToTop: false,
      showScrollbar: true,
      refresherEnabled: false,
      refresherThreshold: 45,
      refresherDefaultStyle: "black",
      refresherBackground: "#FFF",
      refresherTriggered: false,
      enableFlex: false,
      scrollAnchoring: false,

      loadingMode: "spinner",
      loadingSize: "40rpx",
      loadingText: "加载中...",
      loadingTextStyle: () => ({
        fontSize: "26rpx",
        color: "#909193",
      }),
      loadingCustomStyle: () => ({}),
      loadingVertical: true,
      loadingTimingFunction: "ease-in-out",
      loadingDuration: 1200,
      loadingInactiveColor: "transparent",
    }
  );

  const emit = defineEmits([
    "cellClick",
    "cellTextClick",
    "scrolltoupper",
    "scrolltolower",
    "scroll",
    "refresherpulling",
    "refresherrefresh",
    "refresherrestore",
    "refresherabort",
  ]);

  const computedTableId = computed(() => {
    if (props.tableId) {
      return props.tableId;
    }
    return `table-${uni.$uv.guid()}`;
  });

  const onTableCellClick = (
    item: any,
    dataIndex: number,
    col: ColumnType,
    columnIndex: number
  ) => {
    console.log("onTableCellClick", props, {
      item,
      dataIndex,
      col,
      columnIndex,
    });
    emit("cellClick", { item, dataIndex, col, columnIndex });
  };

  const onTableCellTextClick = (
    item: any,
    dataIndex: number,
    col: ColumnType,
    columnIndex: number
  ) => {
    console.log("onTableCellTextClick", { item, dataIndex, col, columnIndex });
    emit("cellTextClick", { item, dataIndex, col, columnIndex });
  };

  const onScrollToUpper = (e: any) => {
    emit("scrolltoupper", e);
  };
  const onScrollToLower = (e: any) => {
    emit("scrolltolower", e);
  };
  const onScroll = (e: any) => {
    emit("scroll", e);
  };
  const onRefresherPulling = (e: any) => {
    emit("refresherpulling", e);
  };
  const onRefresherRefresh = (e: any) => {
    emit("refresherrefresh", e);
  };
  const onRefresherRestore = (e: any) => {
    emit("refresherrestore", e);
  };
  const onRefresherAbort = (e: any) => {
    emit("refresherabort", e);
  };
</script>
```

## table-header.vue

```html
<template>
  <view class="flex flex-row items-center">
    <view
      v-for="(item, index) in column"
      :key="index"
      class="[font-weight:500] flex-none shrink-0 whitespace-nowrap bg-[#F5F7FF] py-[18rpx] text-center text-right text-[26rpx] text-[#19245A] leading-[37rpx] font-[PingFangSC,_PingFang_SC] not-italic"
      :style="computedHeaderStyle(item, index)"
    >
      <slot :col="item" :column-index="index"> {{ item.label }} </slot>
    </view>
  </view>
</template>

<script setup lang="ts">
  import type { ColumnType } from "./index.vue";
  import { computed } from "vue";

  const props = withDefaults(
    defineProps<{
      border?: string;
      borderRadius?: string;
      column: ColumnType[];
    }>(),
    {
      border: "2rpx solid #e5e5e5",
      borderRadius: "12rpx",
      column: () => [],
    }
  );

  const computedHeaderStyle = computed(
    () => (item: ColumnType, index: number) => {
      const style: AnyStyleType = {
        borderTop: props.border,
        borderRight: props.border,
        borderLeft: index === 0 ? props.border : "none",
        textAlign: item.align || "center",
        borderRadius:
          index === 0
            ? `${props.borderRadius} 0 0 0`
            : index === props.column.length - 1
            ? `0 ${props.borderRadius} 0 0 `
            : "0",
      };
      if (item.cellStyle?.width) {
        style.width = item.cellStyle?.width;
      } else if (item.headerStyle?.width) {
        style.width = item.headerStyle?.width;
      } else if (item.width) {
        style.width = item.width;
      } else {
        style.flex = 1;
      }

      Object.assign(style, item.headerStyle || {});

      console.log(
        "computedHeaderStyle",
        index,
        index === props.column.length - 1,
        style
      );
      return style;
    }
  );

  console.log("table-header", props);
</script>
```

## table-item.vue

```html
<template>
  <view class="flex shrink-0 flex-row items-stretch">
    <view
      v-for="(col, columnIndex) in column"
      :key="col.keyName"
      class="[font-weight:400] flex shrink-0 items-center justify-center py-[18rpx] text-center text-[26rpx] text-[#5E6E7B] leading-[37rpx] font-[PingFangSC,_PingFang_SC] not-italic"
      :style="computedItemStyle(col, columnIndex)"
      @click.stop="onTableCellClick(dataIndex, col, columnIndex)"
    >
      <slot :data-index="dataIndex" :col="col" :column-index="columnIndex">
        <text
          class="[font-weight:400] text-[26rpx] text-[#5E6E7B] leading-[37rpx] font-[PingFangSC,_PingFang_SC] not-italic"
          @click.stop="onTableCellTextClick(dataIndex, col, columnIndex)"
        >
          {{ details[col.keyName] }}
        </text>
      </slot>
    </view>
  </view>
</template>

<script setup lang="ts">
  import type { ColumnType } from "./index.vue";
  import { computed } from "vue";

  const props = withDefaults(
    defineProps<{
      border?: string;
      borderRadius?: string;
      dataIndex: number;
      column: ColumnType[];
      dataLength: number;
      details: AnyObject;
    }>(),
    {
      border: "2rpx solid #e5e5e5",
      borderRadius: "12rpx",
      dataIndex: -1,
      column: () => [],
      dataLength: 0,
      details: () => ({}),
    }
  );

  const emit = defineEmits(["cellClick", "cellTextClick"]);

  const computedItemStyle = computed(
    () => (col: ColumnType, columnIndex: number) => {
      const style: AnyStyleType = {
        borderTop: props.dataIndex === 0 ? "none" : props.border,
        borderRight: props.border,
        borderLeft: columnIndex === 0 ? props.border : "none",
        borderBottom:
          props.dataIndex === props.dataLength - 1 ? props.border : "none",
        textAlign: col.align || "center",
        borderRadius:
          props.dataIndex === props.dataLength - 1
            ? columnIndex === 0
              ? `0 0 0 ${props.borderRadius}`
              : columnIndex === props.column.length - 1
              ? `0 0 ${props.borderRadius} 0`
              : "0"
            : "0",
      };
      if (col.headerStyle?.width) {
        style.width = col.headerStyle?.width;
      } else if (col.cellStyle?.width) {
        style.width = col.cellStyle?.width;
      } else if (col.width) {
        style.width = col.width;
      } else {
        style.flex = 1;
      }

      Object.assign(style, col.cellStyle || {});
      return style;
    }
  );

  const onTableCellClick = (
    dataIndex: number,
    col: ColumnType,
    columnIndex: number
  ) => {
    console.log("tableCellClick", props, { dataIndex, col, columnIndex });
    emit("cellClick", { dataIndex, col, columnIndex });
  };

  const onTableCellTextClick = (
    dataIndex: number,
    col: ColumnType,
    columnIndex: number
  ) => {
    console.log("onTableCellTextClick", props, { dataIndex, col, columnIndex });
    emit("cellTextClick", { dataIndex, col, columnIndex });
  };
</script>
```
