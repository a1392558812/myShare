# swiper-actions 组件

> 水文章，此处抽取的是[【wot-ui】](https://wot-ui.cn/component/swipe-action.html)的 swipe-action 组件。做了一些简化和把一些工具方法都提到一个文件里，方便复制

- 部分工具函数已经抽取，本人人懒，推荐先看工具函数有无重复代码
  - @/utils/components-tools.ts ---> 04.杂项整理/35.components-tools.md
  - @/hooks/use-comp-relation.ts ---> 04.杂项整理/36.use-comp-relation.md
  - @/utils/type-check.ts ---> 03.杂项整理/14.类型保护工具函数.md
  - @/components/transition/index.vue ---> 07.uniapp 的自定义 Transition 过渡组件.md

```html
<template>
  <!-- 注意阻止横向滑动的穿透：横向移动时阻止冒泡 -->
  <view
    class="custom-swipe-action"
    :style="customStyle"
    @click.stop="onClick()"
    @touchstart="startDrag"
    @touchmove="onDrag"
    @touchend="endDrag"
    @touchcancel="endDrag"
  >
    <!-- 容器 -->
    <view class="custom-swipe-action-wrapper" :style="wrapperStyle">
      <!-- 左侧操作 -->
      <view
        :id="swipeActionLeft"
        :style="computedLeftStyle"
        @click="onClick('left')"
      >
        <slot name="left" />
      </view>
      <!-- 内容 -->
      <slot />
      <!-- 右侧操作 -->
      <view
        :id="swipeActionRight"
        :style="computedRightStyle"
        @click="onClick('right')"
      >
        <slot name="right" />
      </view>
    </view>
  </view>
</template>

<script lang="ts" setup>
  import { isArray } from "@/utils/type-check";
  import {
    computed,
    getCurrentInstance,
    onBeforeMount,
    onMounted,
    reactive,
    ref,
    watch,
  } from "vue";

  export type RectResultType<T extends boolean> = T extends true
    ? UniApp.NodeInfo[]
    : UniApp.NodeInfo;

  export type SwipeActionReason = "click" | "swipe" | "value";
  export type SwipeActionStatus = "left" | "close" | "right";
  export type SwipeActionPosition = SwipeActionStatus | "inside";
  export interface TouchType {
    startX: number;
    startY: number;
    isSwipe: boolean;
    direction: "" | "left" | "right" | "up" | "down";
  }

  export interface SwipeActionPropsType {
    modelValue?: SwipeActionStatus; // 'left'（左滑）、'close'（关闭状态）、'right'（右滑）。
    disabled?: boolean; // 是否禁用滑动操作
    customStyle?: AnyStyleType;
    leftStyle?: AnyStyleType;
    rightStyle?: AnyStyleType;
    beforeClose?: (
      reason: SwipeActionReason,
      position: SwipeActionPosition
    ) => void; // 关闭前的回调函数
  }

  defineOptions({
    addGlobalClass: true,
    virtualHost: true,
    styleIsolation: "shared",
  });

  const props = withDefaults(defineProps<SwipeActionPropsType>(), {
    modelValue: "close",
    disabled: false,
    beforeClose: () => {},
    customStyle: () => ({}),
    leftStyle: () => ({}),
    rightStyle: () => ({}),
  });

  const emit = defineEmits(["click", "update:modelValue"]);

  const getRandomInt = (min: number = 0, max: number = 10): number => {
    const realMin = Math.min(min, max);
    const realMax = Math.max(min, max);
    return Math.floor(Math.random() * (realMax - realMin + 1)) + realMin;
  };

  // 可以找个专门的uuid算法，我这里就偷懒了
  const uuid = `${getRandomInt()}${getRandomInt()}${getRandomInt()}${getRandomInt()}${getRandomInt()}${new Date().getTime()}`;
  const swipeActionLeft = `swipeActionLeft${uuid}`;
  const swipeActionRight = `swipeActionRight${uuid}`;

  const wrapperStyle = ref<string>("");

  // 滑动开始时，wrapper的偏移量
  const originOffset = ref<number>(0);
  // wrapper现在的偏移量
  const wrapperOffset = ref<number>(0);

  const touch = reactive<TouchType>({
    startX: 0,
    startY: 0,
    isSwipe: false,
    direction: "",
  });

  const computedLeftStyle = computed<AnyStyleType>(() => {
    return {
      position: "absolute",
      top: 0,
      left: 0,
      height: "100%",
      transform: "translate3d(-100%, 0, 0)",
      ...props.leftStyle,
    };
  });

  const computedRightStyle = computed<AnyStyleType>(() => {
    return {
      position: "absolute",
      top: 0,
      right: 0,
      height: "100%",
      transform: "translate3d(100%, 0, 0)",
      ...props.rightStyle,
    };
  });

  const { proxy } = getCurrentInstance() as any;

  /**
   * 获取节点信息
   * @param selector 节点选择器 #id,.class
   * @param all 是否返回所有 selector 对应的节点
   * @param scope 作用域（支付宝小程序无效）
   * @param useFields 是否使用 fields 方法获取节点信息
   * @returns 节点信息或节点信息数组
   */
  const getRect = <T extends boolean>(
    selector: string,
    all: T,
    scope?: any,
    useFields?: boolean
  ): Promise<RectResultType<T>> => {
    return new Promise<RectResultType<T>>((resolve, reject) => {
      let query: UniNamespace.SelectorQuery | null = null;
      if (scope) {
        query = uni.createSelectorQuery().in(scope);
      } else {
        query = uni.createSelectorQuery();
      }

      const method = all ? "selectAll" : "select";

      const callback = (rect: UniApp.NodeInfo | UniApp.NodeInfo[]) => {
        if (all && isArray(rect) && rect.length > 0) {
          resolve(rect as RectResultType<T>);
        } else if (!all && rect) {
          resolve(rect as RectResultType<T>);
        } else {
          reject(new Error("No nodes found"));
        }
      };

      if (useFields) {
        query[method](selector)
          .fields({ size: true, node: true }, callback)
          .exec();
      } else {
        query[method](selector).boundingClientRect(callback).exec();
      }
    });
  };

  /**
   * @description 获取左/右操作按钮的宽度
   * @return {Promise<[number, number]>} 左宽度、右宽度
   */
  const getWidths = () => {
    return Promise.all([
      getRect(`#${swipeActionLeft}`, false, proxy).then((rect) => {
        return rect.width ? rect.width : 0;
      }),
      getRect(`#${swipeActionRight}`, false, proxy).then((rect) => {
        return rect.width ? rect.width : 0;
      }),
    ]);
  };

  /**
   * @description wrapper滑动函数
   * @param {number} offset 滑动漂移量
   */
  const swipeMove = (offset = 0) => {
    // this.offset = offset
    const transform = `translate3d(${offset}px, 0, 0)`;
    // 跟随手指滑动，不需要动画
    const transition = touch.isSwipe
      ? "none"
      : ".6s cubic-bezier(0.18, 0.89, 0.32, 1)";
    wrapperStyle.value = `
        -webkit-transform: ${transform};
        -webkit-transition: ${transition};
        transform: ${transform};
        transition: ${transition};
      `;
    // 记录容器当前偏移的量
    wrapperOffset.value = offset;
  };

  /**
   * @description 关闭操过按钮，并在合适的时候调用 beforeClose
   */
  const close = (reason: SwipeActionReason, position?: SwipeActionPosition) => {
    if (reason === "swipe" && originOffset.value === 0) {
      // offset：0 ——> offset：0
      return swipeMove(0);
    } else if (reason === "swipe" && originOffset.value > 0) {
      // offset > 0 ——> offset：0
      position = "left";
    } else if (reason === "swipe" && originOffset.value < 0) {
      // offset < 0 ——> offset：0
      position = "right";
    }

    if (reason && position) {
      props.beforeClose && props.beforeClose(reason, position);
    }

    swipeMove(0);
    if (props.modelValue !== "close") {
      emit("update:modelValue", "close");
    }
  };

  const changeState = (value: SwipeActionStatus, old?: SwipeActionStatus) => {
    if (props.disabled) {
      return;
    }
    getWidths().then(([leftWidth, rightWidth]) => {
      switch (value) {
        case "close":
          // 调用此函数时，偏移量本就是0
          if (wrapperOffset.value === 0) return;
          close("value", old);
          break;
        case "left":
          swipeMove(leftWidth);
          break;
        case "right":
          swipeMove(-rightWidth);
          break;
      }
    });
  };

  /**
   * @description click的handler
   * @param event
   */
  const onClick = (position?: SwipeActionPosition) => {
    if (props.disabled || wrapperOffset.value === 0) {
      return;
    }

    position = position || "inside";
    close("click", position);
    emit("click", {
      value: position,
    });
  };

  const getSwipeDirection = (dx: number, dy: number) => {
    if (Math.abs(dx) > Math.abs(dy)) {
      return dx > 0 ? "right" : "left";
    } else {
      return dy > 0 ? "down" : "up";
    }
  };

  const startDrag = (event: TouchEvent) => {
    if (props.disabled) return;

    originOffset.value = wrapperOffset.value;

    touch.isSwipe = false;
    touch.startX = event.touches[0].clientX;
    touch.startY = event.touches[0].clientY;
    touch.direction = "";
  };

  const onDrag = (event: TouchEvent) => {
    if (props.disabled) return;

    // 本次滑动，wrapper应该设置的偏移量
    const dx = event.touches[0].clientX - touch.startX;
    const dy = event.touches[0].clientY - touch.startY;
    touch.direction = getSwipeDirection(dx, dy);
    touch.isSwipe = true;

    console.log("direction", touch.direction);
    if (["left", "right"].includes(touch.direction)) {
      event.preventDefault();
      event.stopPropagation();
    } else {
      return;
    }

    const offset = originOffset.value + dx;
    getWidths().then(([leftWidth, rightWidth]) => {
      // 如果需要想滑出来的按钮不存在，对应的按钮肯定滑不出来，容器处于初始状态。此时需要模拟一下位于此处的start事件。
      if ((leftWidth === 0 && offset > 0) || (rightWidth === 0 && offset < 0)) {
        swipeMove(0);
        return startDrag(event);
      }
      // 按钮已经展示完了，再滑动没有任何意义，相当于滑动结束。此时需要模拟一下位于此处的start事件。
      if (leftWidth !== 0 && offset >= leftWidth) {
        swipeMove(leftWidth);
        return startDrag(event);
      } else if (rightWidth !== 0 && -offset >= rightWidth) {
        swipeMove(-rightWidth);
        return startDrag(event);
      }
      swipeMove(offset);
    });
  };

  const endDrag = () => {
    if (props.disabled) return;
    touch.isSwipe = false;
    // 滑出"操作按钮"的阈值
    const THRESHOLD = 0.3;

    getWidths().then(([leftWidth, rightWidth]) => {
      if (
        originOffset.value < 0 && // 之前展示的是右按钮
        wrapperOffset.value < 0 && // 目前仍然是右按钮
        wrapperOffset.value - originOffset.value < rightWidth * THRESHOLD // 并且滑动的范围不超过右边框阀值
      ) {
        swipeMove(-rightWidth); // 回归右按钮
        emit("update:modelValue", "right");
      } else if (
        originOffset.value > 0 && // 之前展示的是左按钮
        wrapperOffset.value > 0 && // 现在仍然是左按钮
        originOffset.value - wrapperOffset.value < leftWidth * THRESHOLD // 并且滑动的范围不超过左按钮阀值
      ) {
        swipeMove(leftWidth); // 回归左按钮
        emit("update:modelValue", "left");
      } else if (
        rightWidth > 0 &&
        originOffset.value >= 0 && // 之前是初始状态或者展示左按钮显
        wrapperOffset.value < 0 && // 现在展示右按钮
        Math.abs(wrapperOffset.value) > rightWidth * THRESHOLD // 视图中已经展示的右按钮长度超过阀值
      ) {
        swipeMove(-rightWidth);
        emit("update:modelValue", "right");
      } else if (
        leftWidth > 0 &&
        originOffset.value <= 0 && // 之前初始状态或者右按钮显示
        wrapperOffset.value > 0 && // 现在左按钮
        Math.abs(wrapperOffset.value) > leftWidth * THRESHOLD // 视图中已经展示的左按钮长度超过阀值
      ) {
        swipeMove(leftWidth);
        emit("update:modelValue", "left");
      } else {
        // 回归初始状态
        close("swipe");
      }
    });
  };

  watch(
    () => props.modelValue,
    (value, old) => {
      changeState(value, old);
    },
    {
      deep: true,
    }
  );

  onBeforeMount(() => {
    originOffset.value = 0;
    wrapperOffset.value = 0;
  });

  onMounted(() => {
    touch.isSwipe = true;
    changeState(props.modelValue);
    touch.isSwipe = false;
  });

  defineExpose({ close });
</script>

<style lang="scss" scoped>
  .custom-swipe-action {
    position: relative;
    overflow: hidden;
  }
</style>
```
