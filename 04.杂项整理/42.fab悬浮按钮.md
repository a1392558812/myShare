# fab 悬浮按钮

- 部分工具函数已经抽取，本人人懒，推荐先看工具函数有无重复代码
  - @/utils/components-tools.ts ---> 04.杂项整理/35.components-tools.md

## 使用

```html
<template>
  <view>
    <Fab
      v-model:position="position"
      :auto-stick="['bottom', 'right', 'top', 'left']"
      @update:position="onUpdatePosition"
    >
      <view
        class="h-[200rpx] w-[200rpx] break-all border-[1rpx] border-[#000] border-solid"
      >
        <view>top: {{ position.top }}</view>
        <view>left: {{ position.left }}</view>
      </view>
    </Fab>
  </view>
</template>

<script setup lang="ts">
  import Fab from "@/components/fab/index.vue";
  import { ref } from "vue";

  const position = ref({
    top: 200,
    left: 200,
  });

  // 更新位置
  const onUpdatePosition = (pos: { left: number; top: number }) => {
    console.log(pos);
  };
</script>

<style scoped lang="scss"></style>

<route type="home" lang="json">
  { "style": { "navigationBarTitleText": "我的" } }
</route>
```

## index.vue

```html
<template>
  <view
    :id="triggerId"
    ref="triggerRef"
    :style="[{ position: 'fixed' }, fabStyle, customStyle]"
    :class="[customClass]"
    @touchstart="handleTouchstart"
    @touchmove.stop.prevent="handleTouchmove"
    @touchend="handleTouchend"
  >
    <slot />
    <template v-if="showCenterDot">
      <view
        class="fixed left-1/2 top-1/2 h-[8rpx] w-[8rpx] rounded-full bg-[#000] -translate-x-1/2 -translate-y-1/2"
      />
      <view
        class="absolute left-1/2 top-1/2 h-[8rpx] w-[8rpx] rounded-full bg-[#ff0000] -translate-x-1/2 -translate-y-1/2"
      />
    </template>
  </view>
</template>

<script lang="ts"></script>

<script setup lang="ts">
  import { getUuid, queryRect } from "@/utils/components-tools";
  import { computed, getCurrentInstance, onMounted, reactive, ref } from "vue";

  /**
   * top: 自动吸边，按钮中心位置在视口顶部时，自动吸附顶部
   * bottom: 自动吸边，按钮中心位置在视口底部时，自动吸附底部
   * left: 自动吸边，按钮中心位置在视口左边时，自动吸附左边
   * right: 自动吸边，按钮中心位置在视口右边时，自动吸附右边
   *
   * TOP: 自动吸附顶部
   * BOTTOM: 自动吸附底部
   * LEFT: 自动吸附左边
   * RIGHT: 自动吸附右边
   */
  export type AutoStickType =
    | "top"
    | "bottom"
    | "left"
    | "right"
    | "TOP"
    | "BOTTOM"
    | "LEFT"
    | "RIGHT";

  export interface FabPropsType {
    draggable?: boolean;
    autoStick?: AutoStickType[];
    showCenterDot?: boolean;
    // 按钮与视口的间距， 不传则没有限制，会拖拽到看不见
    gap?:
      | {
          top: number;
          bottom: number;
          left: number;
          right: number;
        }
      | undefined;
    // 初始位置
    position?: {
      top: number;
      left: number;
    };
    customClass?: string;
    customStyle?: AnyStyleType;
  }

  defineOptions({
    name: "CustomDropdownItem",
    addGlobalClass: true,
    virtualHost: true,
    styleIsolation: "shared",
  });

  const props = withDefaults(defineProps<FabPropsType>(), {
    draggable: true,
    autoStick: () => [],
    showCenterDot: true,
    gap: undefined,
    position: () => ({
      top: 0,
      left: 0,
    }),
    customClass: "",
    customStyle: () => ({}),
  });

  const emit = defineEmits<{
    (e: "update:position", position: Required<FabPropsType>["position"]): void;
  }>();

  const uuid = getUuid();
  const triggerId = `trigger${uuid}`;
  const triggerRef = ref<HTMLElement>();

  const instance = getCurrentInstance();
  const dragging = ref(false);

  const minLeft = ref(0);
  const maxLeft = ref(0);
  const minTop = ref(0);
  const maxTop = ref(0);

  const position = reactive({
    top: props.position.top,
    left: props.position.left,
  });
  const btnInfo = ref<UniApp.NodeInfo & { width: number; height: number }>({
    width: 56,
    height: 56,
  });
  const start = reactive({
    x: 0,
    y: 0,
  });

  // 计算悬浮按钮样式
  const fabStyle = computed(() => {
    const style: Record<string, any> = {
      transition: dragging.value ? "none" : "all 0.3s ease",
      left: `${position.left}px`,
      top: `${position.top}px`,
    };
    return style;
  });

  const effectiveWindowHeight = (sysInfo: UniApp.GetSystemInfoResult) => {
    let height = sysInfo.windowHeight;

    // #ifdef H5
    height = sysInfo.windowTop + sysInfo.windowHeight;
    // #endif

    return height;
  };

  // 拖动开始事件
  const handleTouchstart = (e: TouchEvent) => {
    if (!props.draggable) return;

    const touches = e.touches[0];
    start.x = touches.clientX;
    start.y = touches.clientY;
    dragging.value = true;
  };

  // 拖动移动事件
  const handleTouchmove = (e: TouchEvent) => {
    if (!props.draggable) return;

    const touches = e.touches[0];
    const deltaX = touches.clientX - start.x;
    const deltaY = touches.clientY - start.y;

    position.left += deltaX;
    position.top += deltaY;

    start.x = touches.clientX;
    start.y = touches.clientY;

    // 设置边界，防止拖出边界
    position.left = Math.max(
      minLeft.value,
      Math.min(maxLeft.value, position.left),
    );
    position.top = Math.max(minTop.value, Math.min(maxTop.value, position.top));

    emit("update:position", position);
  };

  const stickSide = () => {
    if (!props.autoStick.length) {
      position.left = Math.max(
        minLeft.value,
        Math.min(maxLeft.value, position.left),
      );
      position.top = Math.max(
        minTop.value,
        Math.min(maxTop.value, position.top),
      );
      emit("update:position", position);
      dragging.value = false;
      return;
    }

    const sysInfo = uni.getSystemInfoSync();

    const middleW = sysInfo.windowWidth / 2;
    const middleH = effectiveWindowHeight(sysInfo) / 2;

    const buttonCenterW = position.left + btnInfo.value.width / 2;
    const buttonCenterH = position.top + btnInfo.value.height / 2;

    const gapTop = props.gap?.top || 0;
    const gapBottom = props.gap?.bottom || 0;
    const gapLeft = props.gap?.left || 0;
    const gapRight = props.gap?.right || 0;

    // 自动吸边，按钮中心位置在视口左边时，自动吸附左边
    if (props.autoStick.includes("left")) {
      position.left = buttonCenterW < middleW ? gapLeft : position.left;
    } else if (props.autoStick.includes("LEFT")) {
      position.left = gapLeft;
    }

    // 自动吸边，按钮中心位置在视口顶部时，自动吸附顶部
    if (props.autoStick.includes("top")) {
      position.top =
        buttonCenterH < middleH ? gapTop + sysInfo.windowTop : position.top;
    } else if (props.autoStick.includes("TOP")) {
      position.top = gapTop + sysInfo.windowTop;
    }

    // 自动吸边，按钮中心位置在视口右边时，自动吸附右边
    if (props.autoStick.includes("right")) {
      position.left =
        buttonCenterW > middleW
          ? sysInfo.windowWidth - btnInfo.value.width - gapRight
          : position.left;
    } else if (props.autoStick.includes("RIGHT")) {
      position.left = sysInfo.windowWidth - btnInfo.value.width - gapRight;
    }

    // 自动吸边，按钮中心位置在视口底部时，自动吸附底部
    if (props.autoStick.includes("bottom")) {
      position.top =
        buttonCenterH > middleH
          ? effectiveWindowHeight(sysInfo) - btnInfo.value.height - gapBottom
          : position.top;
    } else if (props.autoStick.includes("BOTTOM")) {
      position.top =
        effectiveWindowHeight(sysInfo) - btnInfo.value.height - gapBottom;
    }

    emit("update:position", position);
    dragging.value = false;
  };

  // 拖动结束事件
  const handleTouchend = () => {
    if (!props.draggable) return;

    stickSide();

    dragging.value = false;
  };

  const init = () => {
    queryRect(`#${triggerId}`, instance, triggerRef.value).then((data) => {
      const result = data as UniApp.NodeInfo & {
        width: number;
        height: number;
      };
      const sysInfo = uni.getSystemInfoSync();

      const gapTop = props.gap?.top || -99999;
      const gapBottom = props.gap?.bottom || -99999;
      const gapLeft = props.gap?.left || -99999;
      const gapRight = props.gap?.right || -99999;

      btnInfo.value = result;
      minLeft.value = gapLeft;
      minTop.value = gapTop + sysInfo.windowTop;
      maxLeft.value = sysInfo.windowWidth - btnInfo.value.width - gapRight;
      maxTop.value =
        effectiveWindowHeight(sysInfo) - btnInfo.value.height - gapBottom;
    });
  };

  const setPosition = (pos: { left: number; top: number }) => {
    position.left = pos.left;
    position.top = pos.top;
    emit("update:position", position);
  };

  onMounted(() => {
    init();
  });

  defineExpose({
    stickSide, // 用于吸边，常用于初始化位置/手动更改位置后去吸边
    setPosition, // 用于设置位置
  });
</script>
```
