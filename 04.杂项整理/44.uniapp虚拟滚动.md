# 虚拟滚动

- 部分工具函数已经抽取，本人人懒，推荐先看工具函数有无重复代码
  - @/utils/components-tools.ts ---> 04.杂项整理/35.components-tools.md

## 使用

```html
<template>
  <view class="h-[100vh] flex flex-col overflow-hidden">
    <uv-sticky :offset-top="0" :custom-nav-height="0">
      <uv-navbar
        :auto-back="true"
        :placeholder="false"
        :fixed="false"
        title="virtual-scroll-demo"
        bg-color="rgba(255,255,255,0)"
      />

      <view class="shrink-0 p-[20rpx]">
        <uv-tabs
          :current="tabsData.current"
          :list="tabsData.list"
          @change="onCurrentChange"
        />
      </view>
    </uv-sticky>

    <view class="info shrink-0">
      <text>滚动到 index： </text>
      <uv-input v-model.number="inputIndex" class="control-btn" type="number">
        <template #suffix />
      </uv-input>
      <uv-button @click="scrollTo"> 确定 </uv-button>
    </view>

    <view class="info shrink-0">
      <text>添加数据： </text>
      <uv-input v-model.number="dataNum" class="control-btn" type="number">
        <template #suffix />
      </uv-input>
      <uv-button @click="addData"> 确定 </uv-button>
    </view>

    <swiper
      :current="tabsData.current"
      class="flex-1 shrink-0 overflow-hidden"
      @change="onSwiperChange"
    >
      <swiper-item>
        <view
          class="demo-section h-full flex flex-col overflow-hidden px-[20rpx]"
        >
          <view class="demo-title shrink-0 py-[20rpx]">
            固定高度示例 (每个item高度{{ itemHeight }}px)
          </view>
          <view class="flex-1 shrink-0 overflow-hidden">
            <VirtualScroll
              v-if="virtualScrollHeight"
              ref="virtualScrollFixedRef"
              :data="fixedData"
              :item-height="itemHeight"
              :height="virtualScrollHeight"
              :buffer-size="5"
              @scroll="onScroll"
            >
              <template #header>
                <view
                  class="list-item h-[250rpx] flex items-center justify-center bg-[#f0ad4e]"
                >
                  header
                </view>
              </template>
              <template #default="{ item, index }">
                <view
                  class="fixed-item list-item"
                  :style="{ backgroundColor: item.color, height: `${itemHeight}px` }"
                >
                  <text> 索引: {{ index }} </text>
                  <text> 内容: {{ item.text }} </text>
                </view>
              </template>
              <template #footer>
                <view
                  class="list-item h-[150rpx] flex items-center justify-center bg-[#4cd964]"
                >
                  footer
                </view>
              </template>
            </VirtualScroll>
          </view>

          <view class="info shrink-0">
            <text> 总数据: {{ fixedData.length }} </text>
            <text> 可见范围: {{ visibleRangeFixed }} </text>
          </view>
        </view>
      </swiper-item>
      <swiper-item>
        <view
          class="demo-section h-full flex flex-col overflow-hidden px-[20rpx]"
        >
          <view class="demo-title shrink-0 py-[20rpx]">
            动态高度示例 (每个item高度不同)
          </view>
          <view class="flex-1 shrink-0 overflow-hidden">
            <VirtualScroll
              v-if="virtualScrollHeight"
              ref="virtualScrollDynamicRef"
              :data="dynamicData"
              :buffer-size="20"
              :estimated-item-height="150"
              :height="virtualScrollHeight"
              @scroll="onScroll"
            >
              <template #header>
                <view
                  class="list-item h-[50rpx] flex items-center justify-center bg-[#f0ad4e]"
                >
                  header
                </view>
              </template>
              <template #default="{ item, index }">
                <view
                  class="dynamic-item list-item"
                  :style="{ height: `${item.height}px`, backgroundColor: item.color }"
                >
                  <text> 索引: {{ index }} </text>
                  <text> 高度: {{ item.height }}px </text>
                  <text> 内容: {{ item.text }} </text>
                </view>
              </template>
              <template #footer>
                <view
                  class="list-item h-[150rpx] flex items-center justify-center bg-[#4cd964]"
                >
                  footer
                </view>
              </template>
            </VirtualScroll>
          </view>
          <view class="info shrink-0">
            <text> 总数据: {{ dynamicData.length }} </text>
            <text> 可见范围: {{ visibleRangeDynamic }} </text>
          </view>
        </view>
      </swiper-item>
    </swiper>

    <uv-safe-bottom />
  </view>
</template>

<script setup lang="ts">
  import VirtualScroll from "@/components/virtual/index.vue";
  import { computed, reactive, ref } from "vue";

  const virtualScrollFixedRef = ref();
  const virtualScrollDynamicRef = ref();

  const getRandomRgbaColor = () => {
    const r = Math.floor(Math.random() * 256);
    const g = Math.floor(Math.random() * 256);
    const b = Math.floor(Math.random() * 256);
    const a = Number(Math.random().toFixed(2)); // toFixed(2) 保留 2 位小数，转为 Number 类型避免字符串拼接问题
    return `rgba(${r}, ${g}, ${b}, ${a})`;
  };

  // 50-100随机数
  const getRandomNum = () => {
    return Math.floor(Math.random() * 101);
  };

  const inputIndex = ref(0);
  const dataNum = ref(20);

  const tabsData = reactive({
    current: 0,
    list: [{ name: "fixed" }, { name: "dynamic" }],
  });
  const getFixedDataFun = (lastIndex = 0, dataNum = 20) => {
    return Array.from({ length: dataNum }, (_, i) => ({
      id: lastIndex + i,
      text: `这是第 ${lastIndex + i + 1} 条数据`,
      color: getRandomRgbaColor(),
    }));
  };

  const getDynamicDataFun = (lastIndex = 0, dataNum = 20) => {
    return Array.from({ length: dataNum }, (_, i) => {
      const height = 100 + getRandomNum();
      return {
        id: lastIndex + i,
        text: `这是第 ${lastIndex + i + 1} 条数据，高度为 ${height}px`,
        height,
        color: getRandomRgbaColor(),
      };
    });
  };

  const itemHeight = ref(100);
  const virtualScrollHeight = ref(500);
  const fixedData = ref(getFixedDataFun());
  const dynamicData = ref(getDynamicDataFun());

  const visibleRangeFixed = computed(() => {
    if (!virtualScrollFixedRef.value) {
      return "-";
    }
    return `${virtualScrollFixedRef.value.startIndex} - ${virtualScrollFixedRef.value.endIndex}`;
  });

  const visibleRangeDynamic = computed(() => {
    if (!virtualScrollDynamicRef.value) {
      return "-";
    }
    return `${virtualScrollDynamicRef.value.startIndex} - ${virtualScrollDynamicRef.value.endIndex}`;
  });

  const onCurrentChange = (data: { index: number }) => {
    tabsData.current = data.index;
  };

  const onSwiperChange = (e: any) => {
    tabsData.current = e.detail.current;
  };

  const onScroll = (e: any) => {
    console.log("滚动事件:", e.detail.scrollTop);
  };

  const scrollTo = () => {
    let index = Number(inputIndex.value);
    if (
      tabsData.list[tabsData.current].name === "fixed" &&
      virtualScrollFixedRef.value
    ) {
      index =
        index < 0
          ? 0
          : index >= fixedData.value.length
            ? fixedData.value.length - 1
            : index;
      virtualScrollFixedRef.value.scrollToIndex(index);
    } else if (
      tabsData.list[tabsData.current].name === "dynamic" &&
      virtualScrollDynamicRef.value
    ) {
      index =
        index < 0
          ? 0
          : index >= dynamicData.value.length
            ? dynamicData.value.length - 1
            : index;
      virtualScrollDynamicRef.value.scrollToIndex(index);
    }
  };

  const addData = () => {
    let num = Number(dataNum.value);
    num = num < 0 ? 0 : num > 100 ? 100 : num;
    dataNum.value = num;

    if (
      tabsData.list[tabsData.current].name === "fixed" &&
      virtualScrollFixedRef.value
    ) {
      fixedData.value = fixedData.value.concat(
        getFixedDataFun(fixedData.value.length, num),
      );
    } else if (
      tabsData.list[tabsData.current].name === "dynamic" &&
      virtualScrollDynamicRef.value
    ) {
      dynamicData.value = dynamicData.value.concat(
        getDynamicDataFun(dynamicData.value.length, num),
      );
    }
  };
</script>

<style lang="scss" scoped>
  .virtual-scroll-demo {
    box-sizing: border-box;
  }

  .demo-section {
    margin-bottom: 30rpx;
    .demo-title {
      font-size: 28rpx;
      font-weight: bold;
      color: #333;
    }

    .list-item {
      display: flex;
      flex-direction: column;
      padding: 20rpx;
      margin-bottom: 10rpx;
      border-radius: 8rpx;
      color: #fff;
      font-size: 28rpx;

      text {
        margin-bottom: 8rpx;
      }
    }

    .fixed-item {
      box-sizing: border-box;
    }

    .dynamic-item {
      box-sizing: border-box;
    }
  }

  .info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20rpx;
    background: #f5f5f5;
    border-radius: 8rpx;
    margin-top: 20rpx;
    font-size: 26rpx;
    color: #666;
  }
</style>
```

## index.vue

```html
<template>
  <!-- 虚拟滚动容器 -->
  <scroll-view
    :id="virtualScrollId"
    ref="virtualScrollRef"
    class="virtual-scroll"
    :upper-threshold="upperThreshold"
    :lower-threshold="lowerThreshold"
    :scroll-with-animation="false"
    :show-scrollbar="showScrollbar"
    :refresher-enabled="refresherEnabled"
    :refresher-threshold="refresherThreshold"
    :refresher-default-style="refresherDefaultStyle"
    :refresher-background="refresherBackground"
    :refresher-triggered="refresherTriggered"
    :style="containerStyle"
    :scroll-y="true"
    :scroll-into-view="scrollIntoView"
    @scroll="onScroll"
    @scrolltoupper="onScrollToUpper"
    @scrolltolower="onScrollToLower"
    @refresherpulling="onRefresherPulling"
    @refresherrefresh="onRefresherRefresh"
    @refresherrestore="onRefresherRestore"
    @refresherabort="onRefresherAbort"
  >
    <view :style="{ height: `${totalHeight}px` }">
      <view :style="{ transform: `translateY(${offsetY}px)` }">
        <view
          :id="virtualScrollHeaderId"
          ref="virtualScrollHeaderRef"
          :style="customHeaderStyle"
        >
          <slot name="header" />
        </view>

        <view
          v-for="(item, index) in visibleData"
          :id="getItemId(startIndex + index)"
          ref="virtualScrollItemRef"
          :key="startIndex + index"
          class="virtual-item"
        >
          <slot name="default" :item="item" :index="startIndex + index" />
        </view>

        <view
          :id="virtualScrollFooterId"
          ref="virtualScrollFooterRef"
          :style="customFooterStyle"
        >
          <slot name="footer" />
        </view>
      </view>
    </view>
  </scroll-view>
</template>

<script setup lang="ts">
  import { getUuid, queryRect, sleep } from "@/utils/components-tools";
  import {
    computed,
    getCurrentInstance,
    nextTick,
    onMounted,
    ref,
    watch,
  } from "vue";

  export interface VirtualScrollProps {
    upperThreshold?: number; // 触发上拉加载的阈值
    lowerThreshold?: number; // 触发下拉加载的阈值
    showScrollbar?: boolean; // 是否显示滚动条
    refresherEnabled?: boolean; // 是否开启下拉刷新
    refresherThreshold?: number; // 下拉刷新触发阈值
    refresherDefaultStyle?: "black" | "white" | "none"; // 下拉刷新默认样式
    refresherBackground?: string; // 下拉刷新背景颜色
    refresherTriggered?: boolean; // 下拉刷新是否触发

    data: any[]; // 数据源
    itemHeight?: number; // 固定高度模式下的item高度，为0表示动态高度
    estimatedItemHeight?: number; // 动态高度模式下的预估高度
    bufferSize?: number; // 缓冲区大小，上下各渲染bufferSize个不可见item

    customStyle?: AnyStyleType; // 自定义容器样式
    customHeaderStyle?: AnyStyleType; // 自定义header样式
    customFooterStyle?: AnyStyleType; // 自定义footer样式
  }

  const props = withDefaults(defineProps<VirtualScrollProps>(), {
    upperThreshold: 50,
    lowerThreshold: 50,
    showScrollbar: true,
    refresherEnabled: false,
    refresherThreshold: 50,
    refresherDefaultStyle: "black",
    refresherBackground: "#fff",
    refresherTriggered: false,

    data: () => [],
    itemHeight: 0, // 0表示动态高度模式
    estimatedItemHeight: 0,
    bufferSize: 5,
    customStyle: () => ({}),
    customHeaderStyle: () => ({}),
    customFooterStyle: () => ({}),
  });

  const emit = defineEmits<{
    (e: "scroll", data: any): void; // 滚动事件
    (e: "scrolltoupper", data: any): void; // 滚动到顶部事件
    (e: "scrolltolower", data: any): void; // 滚动到底部事件
    (e: "refresherpulling", data: any): void; // 下拉刷新中事件
    (e: "refresherrefresh", data: any): void; // 下拉刷新触发事件
    (e: "refresherrestore", data: any): void; // 下拉刷新恢复事件
    (e: "refresherabort", data: any): void; // 下拉刷新中止事件
  }>();

  const instance = getCurrentInstance();
  const uuid = ref(getUuid());

  const virtualScrollId = `virtualScrollId${uuid.value}`;
  const virtualScrollRef = ref<HTMLElement>();
  const virtualScrollHeight = ref(0);

  const virtualScrollItemId = `virtualScrollItemId${uuid.value}`;
  const virtualScrollItemRef = ref<HTMLElement[]>([]);

  const virtualScrollHeaderId = `virtualScrollHeaderId${uuid.value}`;
  const virtualScrollHeaderRef = ref<HTMLElement>();
  const headerHeight = ref(0);

  const virtualScrollFooterId = `virtualScrollFooterId${uuid.value}`;
  const virtualScrollFooterRef = ref<HTMLElement>();
  const footerHeight = ref(0);

  const scrollIntoView = ref("");

  // 当前滚动位置
  const scrollTop = ref(0);
  // 存储每个item的实际高度（动态高度模式）
  const itemHeights = ref<number[]>([]);
  // 是否正在测量中
  const isMeasuring = ref(false);
  // 已测量的item索引集合，避免重复测量
  const measuredIndices = ref<Set<number>>(new Set());
  // 待测量的item索引集合
  const pendingMeasureIndices = ref<Set<number>>(new Set());

  const containerStyle = computed<AnyStyleType>(() => {
    return {
      height: "100%",
      width: "100%",
      overflow: "auto",
      position: "relative",
      ...props.customStyle,
    };
  });

  const isFixedHeight = computed(() => props.itemHeight > 0);

  // 计算总高度：item总高度 + header高度 + footer高度
  const totalHeight = computed(() => {
    let itemsHeight = 0;
    if (isFixedHeight.value) {
      itemsHeight = props.data.length * props.itemHeight;
    } else {
      itemsHeight = itemHeights.value.reduce((sum, h) => sum + h, 0);
    }
    return itemsHeight + headerHeight.value + footerHeight.value;
  });

  // 计算起始索引：考虑header高度，scrollTop需要减去header高度才是实际的item滚动位置
  const startIndex = computed(() => {
    // 实际的item滚动位置（减去header高度）
    const actualScrollTop = Math.max(0, scrollTop.value - headerHeight.value);

    if (isFixedHeight.value) {
      // 固定高度模式：直接用实际scrollTop除以item高度
      return Math.max(
        0,
        Math.floor(actualScrollTop / props.itemHeight) - props.bufferSize,
      );
    }

    // 动态高度模式：累加item高度找到第一个超过实际scrollTop的索引
    let accumulatedHeight = 0;
    for (let i = 0; i < itemHeights.value.length; i++) {
      accumulatedHeight += itemHeights.value[i];
      if (accumulatedHeight > actualScrollTop) {
        return Math.max(0, i - props.bufferSize);
      }
    }
    return Math.max(0, itemHeights.value.length - props.bufferSize);
  });

  // 计算结束索引
  const endIndex = computed(() => {
    // 实际的item滚动位置
    const actualScrollTop = Math.max(0, scrollTop.value - headerHeight.value);
    // 可见区域的底部位置
    const scrollBottom = actualScrollTop + virtualScrollHeight.value;

    if (isFixedHeight.value) {
      // 固定高度模式：直接计算
      return Math.min(
        props.data.length - 1,
        Math.ceil(scrollBottom / props.itemHeight) + props.bufferSize,
      );
    }

    // 动态高度模式：累加item高度找到第一个超过scrollBottom的索引
    let accumulatedHeight = 0;
    for (let i = 0; i < itemHeights.value.length; i++) {
      accumulatedHeight += itemHeights.value[i];
      if (accumulatedHeight > scrollBottom) {
        return Math.min(props.data.length - 1, i + props.bufferSize);
      }
    }
    return Math.min(
      props.data.length - 1,
      itemHeights.value.length + props.bufferSize,
    );
  });

  // 计算偏移量：将可见区域定位到正确的位置
  const offsetY = computed(() => {
    if (isFixedHeight.value) {
      // 固定高度模式：起始索引乘以item高度
      return startIndex.value * props.itemHeight;
    }

    // 动态高度模式：累加起始索引之前所有item的高度
    let accumulatedHeight = 0;
    for (let i = 0; i < startIndex.value; i++) {
      accumulatedHeight += itemHeights.value[i];
    }
    return accumulatedHeight;
  });

  const visibleData = computed(() => {
    return props.data.slice(startIndex.value, endIndex.value + 1);
  });

  const getItemId = (index: number) => {
    return `${virtualScrollItemId}-${index}`;
  };

  // 测量单个item的高度
  const measureItemHeight = async (index: number) => {
    if (isFixedHeight.value || measuredIndices.value.has(index)) {
      return;
    }

    try {
      const rect = await queryRect(
        `#${getItemId(index)}`,
        instance,
        virtualScrollItemRef.value[index],
      );
      if (rect && rect.height) {
        const oldHeight = itemHeights.value[index];
        const newHeight = rect.height;

        // 只有高度变化超过1px才更新，避免微小变化导致频繁重渲染
        if (Math.abs(oldHeight - newHeight) > 1) {
          itemHeights.value[index] = newHeight;
        }

        // 标记为已测量
        measuredIndices.value.add(index);
      }
    } catch (error) {
      console.warn(`Failed to measure item height for index ${index}:`, error);
    }
  };

  const measureHeaderHeight = async () => {
    try {
      const rect = await queryRect(
        `#${virtualScrollHeaderId}`,
        instance,
        virtualScrollHeaderRef.value,
      );
      if (rect && rect.height) {
        headerHeight.value = rect.height;
      }
    } catch (error) {
      console.warn("Failed to measure header height:", error);
    }
  };

  const measureFooterHeight = async () => {
    try {
      const rect = await queryRect(
        `#${virtualScrollFooterId}`,
        instance,
        virtualScrollFooterRef.value,
      );
      if (rect && rect.height) {
        footerHeight.value = rect.height;
      }
    } catch (error) {
      console.warn("Failed to measure footer height:", error);
    }
  };

  // 测量可见区域内所有未测量的item
  const measureVisibleItems = async () => {
    // 固定高度模式或正在测量中则跳过
    if (isFixedHeight.value || isMeasuring.value) {
      return;
    }

    // 设置测量锁，防止并发测量
    isMeasuring.value = true;

    await nextTick();

    // 收集需要测量的索引
    const indicesToMeasure: number[] = [];

    for (let i = startIndex.value; i <= endIndex.value; i++) {
      // 只测量未测量且不在待测量队列中的索引
      if (
        i >= 0 &&
        i < props.data.length &&
        !measuredIndices.value.has(i) &&
        !pendingMeasureIndices.value.has(i)
      ) {
        indicesToMeasure.push(i);
        pendingMeasureIndices.value.add(i);
      }
    }

    // 并行测量所有可见item
    if (indicesToMeasure.length > 0) {
      const currentScrollTop = scrollTop.value;

      // 使用Promise.all并行测量
      await Promise.all(
        indicesToMeasure.map((index) => measureItemHeight(index)),
      );

      // 清除待测量标记
      indicesToMeasure.forEach((index) => {
        pendingMeasureIndices.value.delete(index);
      });

      // 如果滚动位置未变化，等待Node更新完成
      if (scrollTop.value === currentScrollTop) {
        await nextTick();
      }
    }

    // 释放测量锁
    isMeasuring.value = false;
  };

  const updateItemHeights = () => {
    if (!isFixedHeight.value && props.data.length > 0) {
      // 初始化所有item高度为预估高度
      itemHeights.value = props.data.map(() => props.estimatedItemHeight);
      // 清空已测量标记
      measuredIndices.value.clear();
      pendingMeasureIndices.value.clear();
    }
  };

  const onScroll = (e: any) => {
    scrollTop.value = e.detail.scrollTop;
    emit("scroll", e);
  };

  const onScrollToUpper = (e: any) => {
    emit("scrolltoupper", e);
  };

  const onScrollToLower = (e: any) => {
    emit("scrolltolower", e);
  };

  const onRefresherPulling = (e: any) => {
    emit("refresherpulling", e);
  };

  const onRefresherRefresh = (e: any) => {
    emit("refresherrefresh", e);
  };

  const onRefresherRestore = (e: any) => {
    emit("refresherrestore", e);
  };

  const onRefresherAbort = (e: any) => {
    emit("refresherabort", e);
  };

  const scrollToIndex = (index: number) => {
    if (index < 0 || index >= props.data.length) {
      return;
    }

    let targetScrollTop = 0;

    if (isFixedHeight.value) {
      // 固定高度模式：直接计算scrollTop（需要加上header高度）
      targetScrollTop = index * props.itemHeight + headerHeight.value;
    } else {
      // 动态高度模式：累加目标索引之前所有item的高度（需要加上header高度）
      let accumulatedHeight = 0;
      for (let i = 0; i < index; i++) {
        accumulatedHeight += itemHeights.value[i] || props.estimatedItemHeight;
      }
      targetScrollTop = accumulatedHeight + headerHeight.value;
    }

    // 更新scrollTop状态
    scrollTop.value = targetScrollTop;

    nextTick(() => {
      scrollIntoView.value = getItemId(index);
    });
  };

  // 手动更新指定item的高度
  const updateItemHeight = (index: number, height: number) => {
    if (!isFixedHeight.value) {
      itemHeights.value[index] = height;
      measuredIndices.value.add(index);
    }
  };

  watch(
    () => props.data,
    () => {
      updateItemHeights();
    },
    { deep: true },
  );

  watch(
    () => props.itemHeight,
    () => {
      updateItemHeights();
    },
  );

  watch([startIndex, endIndex], () => {
    measureVisibleItems();
  });

  const init = () => {
    queryRect(`#${virtualScrollId}`, instance, virtualScrollRef.value).then(
      (rect) => {
        virtualScrollHeight.value = rect.height || 0;
        updateItemHeights();
        nextTick(() => {
          sleep(100).then(() => {
            measureHeaderHeight();
            measureFooterHeight();
            measureVisibleItems();
          });
        });
      },
    );
  };

  onMounted(() => {
    init();
  });

  defineExpose({
    visibleData,
    startIndex,
    endIndex,
    scrollTop,
    scrollToIndex,
    updateItemHeight,
    measureItemHeight,
    updateItemHeights,
    measureVisibleItems,
    headerHeight,
    footerHeight,
    init,
  });
</script>

<style lang="scss" scoped>
  .virtual-scroll {
    box-sizing: border-box;
    width: 100%;
    height: 100%;
    .virtual-item {
      will-change: transform;
    }
  }
</style>
```
