# tour 漫游-引导

> 水水水水水水水，此处抽取的是[【wot-ui】](https://wot-ui.cn/component/tour.html)的 tour 组件。

- 部分工具函数已经抽取，本人人懒，推荐先看工具函数有无重复代码
  - @/utils/components-tools.ts ---> 04.杂项整理/35.components-tools.md
  - @/utils/use-raf.ts ---> 04.杂项整理/40.use-raf 动画帧.md

## 使用

```html
<template>
  <view>
    <view id="step1" :ref="(ref) => setTargetRef(ref, 0)" class="tour-item">
      <text class="tour-title"> 第一步-{{ current }} </text>
      <text class="tour-content"> 这是引导的第一步，介绍基本功能 </text>
    </view>

    <view id="step2" :ref="(ref) => setTargetRef(ref, 1)" class="tour-item">
      <text class="tour-title"> 第二步-{{ current }} </text>
      <text class="tour-content"> 这是引导的第二步，展示更多功能 </text>
    </view>

    <button @click="showTour = !showTour">开始引导</button>

    <customTour
      v-model:current="current"
      v-model="showTour"
      :steps="steps"
      @finish="onFinish"
    />
  </view>
</template>

<script lang="ts" setup>
  import type { TourStep } from "@/components/tour/index.vue";
  import customTour from "@/components/tour/index.vue";
  import { ref } from "vue";

  const showTour = ref(false);
  const current = ref(0);

  const steps = ref<TourStep[]>([
    {
      element: "#step1",
      targetRef: null,
      content: "这是第一步的说明",
    },
    {
      element: "#step2",
      targetRef: null,
      content: "这是第二步的说明",
    },
  ]);

  function setTargetRef(ref: HTMLElement, index: number) {
    steps.value[index].targetRef = ref;
  }

  function onFinish() {
    console.log("引导完成");
  }
</script>
```

## index.vue

```html
<template>
  <view
    v-if="modelValue"
    class="custom-tour"
    :style="rootStyle"
    @touchmove.stop.prevent="noop"
  >
    <view class="custom-tour-mask" @click.stop="handleMask">
      <slot name="highlight" :element-info="highlightElementInfo">
        <view :class="highlightClass" :style="highlightStyle" />
      </slot>
      <view class="custom-tour-popover" :style="popoverStyle">
        <slot name="content">
          <view class="custom-tour-popover-info">
            <rich-text :nodes="currentStep.content" />
          </view>
        </slot>

        <view v-if="showTourButtons" class="custom-tour-popover-buttons">
          <!-- 上一步按钮 -->
          <view
            v-if="currentIndex > 0"
            class="custom-tour-popover-buttons-prev"
            @click.stop="handlePrev"
          >
            <slot name="prev">
              <view class="custom-tour-popover-buttons-prev-default">
                {{ prevText }}
              </view>
            </slot>
          </view>

          <!-- 跳过按钮 -->
          <view
            class="custom-tour-popover-buttons-skip"
            @click.stop="handleSkip"
          >
            <slot v-if="$slots.skip" name="skip" />
            <view v-else class="custom-tour-popover-buttons-skip-default">
              {{ skipText }}
            </view>
          </view>

          <!-- 下一步按钮 -->
          <view
            v-if="currentIndex !== steps.length - 1"
            class="custom-tour-popover-buttons-next"
            @click.stop="handleNext"
          >
            <slot name="next">
              <view class="custom-tour-popover-buttons-next-default">
                {{ `${nextText}(${currentIndex + 1}/${steps.length})` }}
              </view>
            </slot>
          </view>

          <!-- 完成按钮 -->
          <view
            v-if="currentIndex === steps.length - 1"
            class="custom-tour-popover-buttons-finish"
            @click.stop="handleFinish"
          >
            <slot name="finish">
              <view class="custom-tour-popover-buttons-finish-default">
                {{ finishText }}
              </view>
            </slot>
          </view>
        </view>
      </view>
    </view>
  </view>
</template>

<script lang="ts"></script>

<script lang="ts" setup>
  import type { ComponentInternalInstance, CSSProperties } from "vue";
  import { useRaf } from "@/hooks/use-raf";
  import { queryRect } from "@/utils/components-tools";
  import { computed, nextTick, ref, watch } from "vue";

  export interface TourStep {
    element: string; // 需要高亮的元素选择器
    targetRef: any; // 自定义目标元素引用
    content: string; // 引导文字内容
    padding?: number; // 覆盖当前步骤的内边距
    offset?: number; // 覆盖当前步骤的提示与高亮间距
    placement?: "auto" | "top" | "bottom" | "left" | "right"; // 强制提示位置
  }

  export interface TourPropsType {
    modelValue?: boolean;
    steps?: TourStep[];
    current?: number; // 当前步骤索引
    mask?: boolean; // 是否显示遮罩层
    maskColor?: string; // 遮罩层颜色
    offset?: number; // 提示与高亮间距
    duration?: number; // 动画时长
    borderRadius?: number; // 高亮元素圆角
    padding?: number; // 高亮元素内边距
    prevText?: string; // 上一步按钮文本
    skipText?: string; // 跳过按钮文本
    nextText?: string; // 下一步按钮文本
    finishText?: string; // 完成按钮文本
    bottomSafetyOffset?: number; // 底部安全偏移量
    topSafetyOffset?: number; // 顶部安全偏移量
    customNav?: boolean; // 是否自定义导航按钮
    clickMaskNext?: boolean; // 点击遮罩层是否下一步
    highlightStyle?: AnyStyleType; // 自定义高亮元素样式
    zIndex?: number; // 自定义z-index
    showTourButtons?: boolean; // 是否显示导航按钮
    scope?: ComponentInternalInstance | null; // 自定义作用域插槽名称
    targetRef?: any; // 自定义目标元素引用
    missingStrategy?: "skip" | "stop" | "hide"; // 缺失元素处理策略
  }

  export interface TourEmitsValueType {
    prevCurrent: number;
    current: number;
    total: number;
    isElementInTop: boolean;
  }

  defineOptions({
    addGlobalClass: true,
    virtualHost: true,
    styleIsolation: "shared",
  });

  const props = withDefaults(defineProps<TourPropsType>(), {
    modelValue: false,
    steps: () => [],
    current: 0,
    mask: true,
    maskColor: "rgba(0, 0, 0, 0.5)",
    offset: 20,
    duration: 300,
    borderRadius: 8,
    padding: 8,
    prevText: "上一步",
    skipText: "跳过",
    nextText: "下一步",
    finishText: "完成",
    bottomSafetyOffset: 100,
    topSafetyOffset: 0,
    customNav: false,
    clickMaskNext: false,
    highlightStyle: () => ({}),
    zIndex: 10,
    showTourButtons: true,
    scope: null,
    targetRef: null,
    missingStrategy: "stop",
  });

  const emit = defineEmits<{
    (e: "update:modelValue", value: boolean): void;
    (e: "update:current", value: number): void;
    (e: "next", value: TourEmitsValueType): void;
    (e: "prev", value: TourEmitsValueType): void;
    (e: "change", value: { current: number }): void;
    (
      e: "error",
      value: {
        message: string;
        element: string;
      }
    ): void;
    (
      e: "skip",
      value: {
        current: number;
        total: number;
      }
    ): void;
    (
      e: "finish",
      value: {
        current: number;
        total: number;
      }
    ): void;
  }>();

  function isDef<T>(value: T): value is NonNullable<T> {
    return value !== undefined && value !== null;
  }

  const currentIndex = ref<number>(0); // 当前步骤索引
  const elementInfo = ref<UniApp.NodeInfo>({
    top: 0,
    left: 0,
    width: 0,
    height: 0,
  }); // 元素信息
  const windowHeight = ref<number>(0); // 窗口高度
  const windowTop = ref<number>(0); // 窗口顶部位置
  const isElementInTop = ref<boolean>(true); // 判断元素位置，确定提示信息在该元素的上方还是下方，true为上方，false为下方
  const lastScrollTop = ref<number>(0); // 记录上一次滚动位置
  const statusBarHeight = ref<number>(0); // 状态栏高度
  const menuButtonInfo = ref(
    null as UniNamespace.GetMenuButtonBoundingClientRectRes | null
  );
  const topOffset = ref<number>(0); // 顶部偏移量

  const rootStyle = computed(() => {
    const style: CSSProperties = {};
    if (props.zIndex) {
      style.zIndex = props.zIndex;
    }
    return style;
  });

  const highlightClass = computed(() => {
    return `custom-tour-highlight ${
      props.mask ? "custom-tour-highlight-mask" : ""
    }`;
  });

  // 计算属性
  const currentStep = computed(() => {
    return props.steps[currentIndex.value] || {};
  });
  // 提取公共的默认样式函数
  const getDefaultStyle = (): CSSProperties => {
    return {
      transition: `${props.duration}ms all`,
    };
  };
  // 提取公共的高亮样式计算函数
  const calculateHighlightStyle = (padding: number): CSSProperties => {
    return {
      transition: `${props.duration}ms all,boxShadow 0s,height 0s,width 0s`,
      borderRadius: `${props.borderRadius}px`,
      padding: `${padding}px`,
    };
  };
  const highlightStyle = computed(() => {
    // 如果元素信息尚未获取到，返回空样式避免闪烁
    if (!elementInfo.value.width && !elementInfo.value.height) {
      return getDefaultStyle();
    }
    const stepPadding = Number(
      isDef(currentStep.value.padding)
        ? currentStep.value.padding
        : props.padding
    );
    const baseStyle = calculateHighlightStyle(stepPadding);
    const style: CSSProperties = {
      ...baseStyle,
      top: `${(elementInfo.value.top || 0) - stepPadding}px`,
      left: `${(elementInfo.value.left || 0) - stepPadding}px`,
      height: `${elementInfo.value.height || 0}px`,
      width: `${elementInfo.value.width || 0}px`,
    };
    if (isDef(props.mask) && isDef(props.maskColor)) {
      style.boxShadow = `0 0 0 100vh ${props.maskColor}`;
    }
    return Object.assign({}, style, props.highlightStyle);
  });

  const popoverStyle = computed(() => {
    const style: CSSProperties = {};
    if (isDef(props.zIndex)) {
      const zIndex = Number(props.zIndex);
      style.zIndex = zIndex + 1;
      style.transitionDuration = `${props.duration}ms`;
    }
    const stepPadding = Number(
      isDef(currentStep.value.offset) ? currentStep.value.offset : props.offset
    );
    const placement = isDef(currentStep.value.placement)
      ? currentStep.value.placement
      : "auto";
    const down =
      placement === "bottom" || (placement === "auto" && isElementInTop.value);
    if (down) {
      // 提示在元素下方
      style.top = `${
        (elementInfo.value.top || 0) +
        (elementInfo.value.height || 0) +
        Number(stepPadding)
      }px`;
    } else {
      // 提示在元素上方
      style.bottom = `${
        windowHeight.value +
        windowTop.value -
        (elementInfo.value.top || 0) +
        Number(stepPadding)
      }px`;
    }

    return style;
  });

  const highlightElementInfo = computed(() => {
    const stepPadding = Number(
      isDef(currentStep.value.padding)
        ? currentStep.value.padding
        : props.padding
    );
    // 如果元素信息尚未获取到，返回空样式避免闪烁
    if (!elementInfo.value.width && !elementInfo.value.height) {
      return getDefaultStyle();
    }

    const baseStyle = calculateHighlightStyle(stepPadding);
    const style: CSSProperties = {
      ...baseStyle,
      top: `${(elementInfo.value.top || 0) - stepPadding}px`,
      left: `${(elementInfo.value.left || 0) - stepPadding}px`,
      width: `${(elementInfo.value.width || 0) + stepPadding * 2}px`,
      height: `${(elementInfo.value.height || 0) + stepPadding * 2}px`,
    };
    if (isDef(props.mask) && isDef(props.maskColor)) {
      style.boxShadow = `0 0 0 100vh ${props.maskColor}`;
    }
    return style;
  });
  const noop = () => {};
  // 方法
  const updateElementInfo = async () => {
    updateSystemInfo();
    if (!currentStep.value.element || !currentStep.value.targetRef) return;
    try {
      const res = (await queryRect(
        currentStep.value.element,
        props.scope,
        currentStep.value.targetRef
      )) as UniApp.NodeInfo;
      console.log("查询到的元素信息:", res, res.top, currentStep.value.element);
      initializeElementInfo(res);
      const effectiveBoundaries = getEffectiveBoundaries();
      const scrollNeeds = checkScrollNeeds(res, effectiveBoundaries);
      handleScrolling(res, scrollNeeds, effectiveBoundaries);
      calculateTipPosition(res);
    } catch (error) {
      console.error("updateElementInfo error:", error);
      emit("error", {
        message: "无法找到指定的引导元素",
        element: currentStep.value.element,
      });
      if (props.missingStrategy === "skip") {
        handleNext();
      } else if (props.missingStrategy === "hide") {
        emit("update:modelValue", false);
      }
    }
  };

  // 更新系统信息
  const updateSystemInfo = () => {
    const sysInfo = uni.getSystemInfoSync();
    console.log("系统信息:", sysInfo);
    windowHeight.value = sysInfo.windowHeight;
    windowTop.value = sysInfo.windowTop || 0;
    statusBarHeight.value = sysInfo.statusBarHeight || 0;
  };

  // 初始化元素信息
  const initializeElementInfo = (res: UniApp.NodeInfo) => {
    elementInfo.value = res;
    // 调整元素位置信息，加上窗口顶部偏移量
    elementInfo.value.top = (res.top || 0) + windowTop.value;
    elementInfo.value.bottom =
      ((res.bottom !== undefined
        ? res.bottom
        : (res.top || 0) + (res.height || 0)) as number) + windowTop.value;
    console.log("调整后的元素信息:", elementInfo.value.top);
  };
  // 获取有效的页面边界（顶部和底部安全区域）
  const getEffectiveBoundaries = () => {
    // 有效顶部边界初始化为窗口顶部 + 顶部偏移量
    const effectiveWindowTop = windowTop.value + Number(topOffset.value);
    // 有效底部边界为窗口高度
    const effectiveWindowBottom = windowHeight.value;
    return {
      top: effectiveWindowTop,
      bottom: effectiveWindowBottom,
    };
  };
  // 检查是否需要滚动
  const checkScrollNeeds = (
    res: UniApp.NodeInfo,
    boundaries: { top: number; bottom: number }
  ) => {
    // 判断元素是否被顶部遮挡（需要向上滚动）
    const needScrollUp = Number(res.top) < boundaries.top;
    // 判断元素是否被底部遮挡（需要向下滚动）
    const needScrollDown =
      (res.bottom !== undefined ? res.bottom : 0) +
        Number(props.bottomSafetyOffset) >
      boundaries.bottom;
    return {
      up: needScrollUp, // 提示框往上走
      down: needScrollDown, // 提示框往下走
    };
  };

  // 处理滚动逻辑
  const handleScrolling = (
    res: UniApp.NodeInfo,
    scrollNeeds: { up: boolean; down: boolean },
    boundaries: { top: number; bottom: number }
  ) => {
    if (scrollNeeds.up) {
      // 元素被顶部遮挡，需要提示框往上走，页面往下走
      scrollUp(res, boundaries);
    } else if (scrollNeeds.down) {
      // 元素被底部遮挡，需要提示框向下走，页面向上走
      scrollDown(res);
    }
  };

  // 向引导上滚动处理
  const scrollUp = (
    res: UniApp.NodeInfo,
    boundaries: { top: number; bottom: number }
  ) => {
    console.log("滚动前元素信息:", res, boundaries);
    // 计算需要滚动的距离
    const scrollDistance =
      lastScrollTop.value + Number(res.top) - props.padding - boundaries.top;
    // 更新元素位置信息（滚动后）
    elementInfo.value.top = boundaries.top + props.padding;
    elementInfo.value.bottom =
      windowHeight.value - (boundaries.top + props.padding);
    uni.pageScrollTo({
      scrollTop: scrollDistance,
      duration: Number(props.duration),
      success: () => {
        // 更新已滚动距离
        lastScrollTop.value = scrollDistance;
      },
    });
  };

  // 引导向下滚动处理
  const scrollDown = (res: UniApp.NodeInfo) => {
    // 计算需要滚动的距离
    const bottom = res.bottom || 0;
    const scrollDistance =
      bottom -
      windowHeight.value +
      props.padding +
      Number(props.bottomSafetyOffset);

    // 更新元素位置信息（滚动后）
    elementInfo.value.top =
      windowHeight.value -
      bottom -
      props.padding -
      Number(props.bottomSafetyOffset); // 应该是减去安全偏移量
    elementInfo.value.bottom =
      windowHeight.value - props.padding - Number(props.bottomSafetyOffset);

    uni.pageScrollTo({
      scrollTop: scrollDistance + lastScrollTop.value,
      duration: Number(props.duration),
      success: () => {
        // 更新已滚动距离
        lastScrollTop.value = scrollDistance + lastScrollTop.value;
      },
    });
  };

  // 计算提示框显示位置（上方或下方）
  const calculateTipPosition = (res: UniApp.NodeInfo) => {
    // 计算导航区域总高度
    const totalNavHeight = statusBarHeight.value;
    // 计算屏幕中心点位置
    const screenCenter =
      (windowHeight.value + totalNavHeight) / 2 + windowTop.value;

    // 计算元素中心点位置
    const elementCenter =
      (res.top || 0) + (res.height || 0) / 2 + windowTop.value;

    // 根据元素位置决定提示框显示在上方还是下方
    if (elementCenter < screenCenter) {
      isElementInTop.value = true;
    } else {
      isElementInTop.value = false;
    }
  };

  const handlePrev = () => {
    if (currentIndex.value > 0) {
      const oldIndex = currentIndex.value;
      currentIndex.value--;
      emit("prev", {
        prevCurrent: oldIndex,
        current: currentIndex.value,
        total: props.steps.length,
        isElementInTop: isElementInTop.value,
      });
      emit("change", { current: currentIndex.value });
    }
  };

  const handleNext = () => {
    if (currentIndex.value < props.steps.length - 1) {
      const oldIndex = currentIndex.value;
      currentIndex.value++;
      emit("next", {
        prevCurrent: oldIndex,
        current: currentIndex.value,
        total: props.steps.length,
        isElementInTop: isElementInTop.value,
      });
      emit("change", { current: currentIndex.value });
    } else {
      handleFinish();
    }
  };

  const handleFinish = () => {
    emit("finish", {
      current: currentIndex.value,
      total: props.steps.length,
    });
    currentIndex.value = 0;
    lastScrollTop.value = 0; // 重置滚动位置
    emit("update:modelValue", false);
  };

  const handleSkip = () => {
    emit("skip", {
      current: currentIndex.value,
      total: props.steps.length,
    });
    currentIndex.value = 0;
    lastScrollTop.value = 0; // 重置滚动位置
    emit("update:modelValue", false);
  };
  const handleMask = () => {
    if (props.clickMaskNext) {
      handleNext();
    }
  };

  watch(
    () => props.current,
    (newVal) => {
      currentIndex.value = newVal;
    }
  );
  // 监听 currentIndex 变化，同步到父组件
  watch(
    () => currentIndex.value,
    (newVal) => {
      const raf = useRaf(updateElementInfo);
      nextTick(() => {
        raf.start();
      });
      emit("update:current", newVal);
    }
  );

  // 监听 modelValue 变化，当组件显示时更新系统信息
  watch(
    () => props.modelValue,
    (newVal) => {
      if (newVal) {
        // 组件显示时重置滚动位置并更新系统信息
        lastScrollTop.value = 0;
        updateSystemInfo();
        const raf = useRaf(() => {
          updateElementInfo();
          emit("update:current", currentIndex.value);
        });
        nextTick(() => {
          raf.start();
        });
      }
    },
    {
      immediate: true,
    }
  );

  // 所有平台统一处理逻辑
  if (props.customNav) {
    // 开启了自定义导航栏
    if (props.topSafetyOffset && Number(props.topSafetyOffset) > 0) {
      // 用户传入了顶部安全偏移量，优先使用用户设置的值
      topOffset.value = Number(props.topSafetyOffset);
    } else {
      // 未传入顶部偏移量
      // #ifdef MP
      // 微信小程序平台获取菜单按钮信息并使用其顶部位置
      menuButtonInfo.value = uni.getMenuButtonBoundingClientRect() || null;
      topOffset.value = menuButtonInfo.value ? menuButtonInfo.value.top : 0;
      // #endif
      // #ifndef MP
      // 非微信小程序平台默认为0
      topOffset.value = 0;
      // #endif
    }
  } else {
    // 未开启自定义导航栏，直接使用用户传入的顶部安全偏移量
    topOffset.value = Number(props.topSafetyOffset) || 0;
  }
  defineExpose({
    handlePrev,
    handleNext,
    handleFinish,
    handleSkip,
  });
</script>

<style lang="scss" scoped>
  .custom-tour {
    position: fixed;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 999;

    .custom-tour-mask {
      position: fixed;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
    }

    .custom-tour-highlight {
      position: fixed;
      background: transparent;
      box-sizing: content-box;
      animation: tour-show 0.3s ease-in-out;
      top: 0;
      left: 0;
      width: 100vw;
      height: 0;
      border-radius: 0;
      padding: 0;

      .custom-tour-highlight-mask {
        box-shadow: 0 0 0 100vh rgba(0, 0, 0, 0.65);
      }
    }

    .custom-tour-popover {
      z-index: 9999;
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      max-width: 340px;
      text-align: center;
      transition: 0.3s all;
      background-color: rgb(255, 255, 255);
      padding: 10px 12px;
      border-radius: 8px;
      width: fit-content;
      min-width: 200px;
      .custom-tour-popover-info {
        font-size: 12px;
        background: rgb(255, 255, 255);
        border: 1px solid rgb(255, 255, 255);
        color: rgb(0, 0, 0);
        width: fit-content;
        text-align: left;
      }
      .custom-tour-popover-buttons {
        display: flex;
        justify-content: flex-end;
        align-items: center;
        padding-top: 6px;
        color: rgb(0, 0, 0);
        .custom-tour-popover-buttons-prev {
          .custom-tour-popover-buttons-prev-default {
            font-size: 12px;
            border-radius: 4px;
            padding: 4px 8px;
            white-space: nowrap;
          }
        }

        .custom-tour-popover-buttons-next {
          .custom-tour-popover-buttons-next-default {
            font-size: 12px;
            border-radius: 4px;
            padding: 4px 8px;
            background: #4d80f0;
            color: rgb(255, 255, 255);
            white-space: nowrap;
          }
        }

        .custom-tour-popover-buttons-finish {
          .custom-tour-popover-buttons-finish-default {
            font-size: 12px;
            border-radius: 4px;
            padding: 4px 8px;
            background: #4d80f0;
            color: rgb(255, 255, 255);
            white-space: nowrap;
          }
        }

        .custom-tour-popover-buttons-skip {
          .custom-tour-popover-buttons-skip-default {
            font-size: 12px;
            border-radius: 4px;
            padding: 4px 8px;
            white-space: nowrap;
          }
        }
      }
    }
  }

  @keyframes tour-show {
    0% {
      opacity: 0;
    }

    100% {
      opacity: 1;
    }
  }
</style>
```
