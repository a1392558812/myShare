# dropdown 下拉菜单

> 1. 相较于原版，做了较多修改，默认的文字回显的改为插槽，需手动指定插槽内容来达到效果，需手动处理 active 和 default 的样式，
> 2. 去除 popup 内容 options 配置项，改为统一的插槽渲染，dropdown 不再负责任何弹窗内的逻辑，只负责打开弹窗，弹窗内的逻辑由子组件自行处理
> 3. 在弹窗打开时，注意锁定滚动条，由于各个平台特性不同，此处无法做统一处理

## 使用

```html
<!-- 
  menuList：菜单项列表
  item：当前item
  index： 当前item的索引
  current: 当前展开项的的索引，没有展开项为时为-2， current >= 0 时表示某个popup展开
-->
<custom-dropdown>
  <template #text="{ menuList, item, index, current }">
    {{ item.title }}-{{ index }}-{{ current }}
  </template>
  <customDropdownItem title="选项1" :title-style="{ color: 'red' }">
    <view class="bg-[#fff]">
      选项1选项1选项1选项1选项1选项1选项1选项1选项1选项1选项1选项1选项1选项1选项1选项1选项1选项1选项1选项1选项1选项1选项1选项1
    </view>
  </customDropdownItem>
  <customDropdownItem title="选项2">
    <view>
      选项2选项2选项2选项2选项2选项2选项2选项2选项2选项2选项2选项2选项2选项2选项2选项2选项2选项2选项2选项2选项2选项2选项2选项2
    </view>
  </customDropdownItem>
  <customDropdownItem title="选项3">
    <view>
      选项3选项3选项3选项3选项3选项3选项3选项3选项3选项3选项3选项3选项3选项3选项3选项3选项3选项3选项3选项3选项3选项3选项3选项3
    </view>
  </customDropdownItem>
</custom-dropdown>
```

## utils/components-tools.ts

```typescript
import type { ComponentInternalInstance } from "vue";
import { isArray } from "@/utils/type-check";

/**
 * 获取节点信息
 * @param selector 节点选择器 #id,.class
 * @param all 是否返回所有 selector 对应的节点
 * @param scope 作用域（支付宝小程序无效）
 * @param useFields 是否使用 fields 方法获取节点信息
 * @returns 节点信息或节点信息数组
 */

export type RectResultType<T extends boolean> = T extends true
  ? UniApp.NodeInfo[]
  : UniApp.NodeInfo;
export const getRect = <T extends boolean>(
  selector: string,
  all: T,
  scope?: any,
  useFields?: boolean
): Promise<RectResultType<T>> => {
  return new Promise<RectResultType<T>>((resolve, reject) => {
    let query: UniNamespace.SelectorQuery | null = null;
    if (scope) {
      query = uni.createSelectorQuery().in(scope);
    } else {
      query = uni.createSelectorQuery();
    }

    const method = all ? "selectAll" : "select";

    const callback = (rect: UniApp.NodeInfo | UniApp.NodeInfo[]) => {
      if (all && isArray(rect) && rect.length > 0) {
        resolve(rect as RectResultType<T>);
      } else if (!all && rect) {
        resolve(rect as RectResultType<T>);
      } else {
        reject(new Error("No nodes found"));
      }
    };

    if (useFields) {
      query[method](selector)
        .fields({ size: true, node: true }, callback)
        .exec();
    } else {
      query[method](selector).boundingClientRect(callback).exec();
    }
  });
};

export const getUuid = (componentName: string = ""): string => {
  const s4 = () =>
    Math.floor((1 + Math.random()) * 0x10000)
      .toString(16)
      .substring(1);
  return `${componentName}${s4()}${s4()}${s4()}${s4()}${s4()}${s4()}${s4()}${s4()}`;
};

export const sleep = (ms: number) => {
  return new Promise((resolve) => setTimeout(resolve, ms));
};

export const getParent = (
  name: string,
  parent: ComponentInternalInstance["proxy"] | undefined
) => {
  let target = parent!.$parent;
  // 通过while历遍，这里主要是为了H5需要多层解析的问题
  while (target) {
    // 父组件
    if (target.$options && target.$options.name !== name) {
      // 如果组件的name不相等，继续上一级寻找
      target = target!.$parent;
    } else {
      return target;
    }
  }
  return false;
};
```

## hooks/use-comp-relation.ts

```typescript
import { getUuid } from "@/utils/components-tools.ts";
import {
  computed,
  getCurrentInstance,
  nextTick,
  onMounted,
  onUnmounted,
  reactive,
  ref,
} from "vue";

// 类型定义
interface ParentContext {
  name: string;
  addChild: (child: ChildContext) => void;
  removeChild: (childId: string) => void;
  broadcast: (event: string, data?: any, childIds?: string | string[]) => void;
  broadcastToChildren: (
    componentName: string,
    event: string,
    data?: any
  ) => void;
  getChildren: () => ChildContext[];
  getExposed: () => Record<string, any>;
  getChildExposed: (childId: string) => Record<string, any>;
  getChildrenExposed: () => Array<{
    id: string;
    name: string;
    exposed: Record<string, any>;
  }>;
  getInstance: () => any;
}

interface ChildContext {
  id: string;
  name: string;
  getChildIndex: () => number;
  emitToParent: (event: string, data?: any) => void;
  getParentExposed: () => Record<string, any>;
  getInstance: () => any;
  getExposed: () => Record<string, any>;
}

// 符号定义
const PARENT_CONTEXT_SYMBOL = Symbol("parent_context");

/**
 * 查找父组件实例
 */
const findParentInstance = (name: string, instance: any): any => {
  if (!instance) return null;

  let parent = instance.parent;
  while (parent) {
    const parentName = parent.type?.name || parent.type?.__name;
    if (parentName === name) {
      return parent;
    }
    parent = parent.parent;
  }
  return null;
};

/**
 * 获取父组件上下文
 */
const getParentContext = (
  name: string,
  instance: any
): ParentContext | null => {
  const parentInstance = findParentInstance(name, instance);
  return parentInstance?.proxy?.[PARENT_CONTEXT_SYMBOL] || null;
};

/**
 * 递归查找所有指定名称的子组件
 */
const findAllChildComponents = (
  componentName: string,
  instance: any
): any[] => {
  const components: any[] = [];

  function traverse(currentInstance: any) {
    if (!currentInstance?.subTree) return;

    const subTree = currentInstance.subTree?.children || [];
    const children = Array.isArray(subTree) ? subTree : [subTree];

    children.forEach((vnode: any) => {
      const child = vnode.component;
      if (!child) return;

      const name = child.type?.name || child.type?.__name;
      if (name === componentName) {
        components.push(child);
      }
      traverse(child);
    });
  }

  traverse(instance);
  console.log(`Found ${components.length} ${componentName} components`);
  return components;
};

/**
 * 父组件 Hook
 */
export const useParent = (componentName?: string) => {
  const instance = getCurrentInstance();
  if (!instance) {
    throw new Error("useParent must be called within setup function");
  }

  const name = componentName || instance.type.name || instance.type.__name;
  if (!name) {
    throw new Error("Component name is required for useParent");
  }

  const children = reactive<ChildContext[]>([]);
  const childrenMap = new Map<string, ChildContext>();

  const broadcast = (
    event: string,
    data?: any,
    childIds?: string | string[]
  ) => {
    const targetChildren = childIds
      ? ((Array.isArray(childIds) ? childIds : [childIds])
          .map((id) => childrenMap.get(id))
          .filter(Boolean) as ChildContext[])
      : Array.from(childrenMap.values());

    console.log(
      `Parent ${name} broadcasting event: ${event} to ${targetChildren.length} children`
    );

    targetChildren.forEach((child) => {
      const exposed = child.getExposed();
      if (exposed && typeof exposed[event] === "function") {
        try {
          exposed[event](data);
        } catch (error) {
          console.warn(`Error calling child method ${event}:`, error);
        }
      }
    });
  };

  const broadcastToChildren = (
    componentName: string,
    event: string,
    data?: any
  ) => {
    console.log(
      `Parent ${name} broadcasting event: ${event} to all ${componentName} components`
    );

    const childComponents = findAllChildComponents(componentName, instance);
    let successCount = 0;

    childComponents.forEach((childComponent) => {
      const exposed = childComponent.exposed || childComponent.proxy;
      if (exposed && typeof exposed[event] === "function") {
        try {
          exposed[event](data);
          successCount++;
        } catch (error) {
          console.warn(
            `Error calling ${componentName} method ${event}:`,
            error
          );
        }
      }
    });

    console.log(
      `Parent ${name} successfully called ${successCount} of ${childComponents.length} ${componentName} components`
    );
  };

  const parentContext: ParentContext = {
    name,
    addChild(child: ChildContext) {
      if (!childrenMap.has(child.id)) {
        childrenMap.set(child.id, child);
        children.push(child);
        console.log(`Parent ${name} added child: ${child.name}`);
      }
    },
    removeChild(childId: string) {
      if (childrenMap.has(childId)) {
        childrenMap.delete(childId);
        const index = children.findIndex((c) => c.id === childId);
        if (index > -1) children.splice(index, 1);
        console.log(`Parent ${name} removed child: ${childId}`);
      }
    },
    broadcast,
    broadcastToChildren,
    getChildren: () => Array.from(childrenMap.values()),
    getExposed: () => instance.exposed || {},
    getChildExposed(childId: string) {
      const child = childrenMap.get(childId);
      return child?.getExposed?.() || {};
    },
    getChildrenExposed() {
      return Array.from(childrenMap.values())
        .filter((child) => child.getExposed)
        .map((child) => ({
          id: child.id,
          name: child.name,
          exposed: child.getExposed(),
        }))
        .filter((item) => Object.keys(item.exposed).length > 0);
    },
    getInstance: () => instance,
  };

  if (instance.proxy) {
    (instance.proxy as any)[PARENT_CONTEXT_SYMBOL] = parentContext;
  }

  onUnmounted(() => {
    childrenMap.forEach((_, childId) => parentContext.removeChild(childId));
    if (instance.proxy) {
      delete (instance.proxy as any)[PARENT_CONTEXT_SYMBOL];
    }
    console.log(`Parent ${name} unmounted and cleaned up`);
  });

  return {
    parentName: name,
    children,
    broadcast,
    broadcastToChildren,
    getChildren: parentContext.getChildren,
    getChildExposed: parentContext.getChildExposed,
    getChildrenExposed: parentContext.getChildrenExposed,
    getExposed: parentContext.getExposed,
    getInstance: parentContext.getInstance,
  };
};

/**
 * 子组件 Hook
 */
export const useChildren = (componentName?: string, parentName?: string) => {
  const instance = getCurrentInstance();
  if (!instance) {
    throw new Error("useChildren must be called within setup function");
  }

  const name = componentName || instance.type.name || instance.type.__name;
  const instanceId = getUuid(name || "anonymous");
  const parentRef = ref<any | null>(null);
  const parentExposed = ref<Record<string, any>>({});

  const createSimulatedParentContext = (
    parentInstance: any
  ): ParentContext => ({
    name:
      parentInstance?.type?.name || parentInstance?.type?.__name || "unknown",
    addChild: () => console.log("Simulated parent added child"),
    removeChild: () => console.log("Simulated parent removed child"),
    broadcast: () => console.log("Simulated parent broadcasting"),
    broadcastToChildren: () =>
      console.log("Simulated parent broadcasting to children"),
    getChildren: () => [],
    getExposed: () => parentInstance?.exposed || {},
    getChildExposed: () => ({}),
    getChildrenExposed: () => [],
    getInstance: () => parentInstance,
  });

  const getParentExposed = (): Record<string, any> => {
    if (parentRef.value) {
      const exposed = parentRef.value.getExposed();
      parentExposed.value = exposed;
      return exposed;
    }
    return {};
  };

  const getExposed = (): Record<string, any> => instance.exposed || {};

  const findParent = (): ParentContext | null => {
    if (parentName) {
      const parentContext = getParentContext(parentName, instance);
      if (parentContext) {
        if (!parentContext.getInstance) {
          parentContext.getInstance = () =>
            findParentInstance(parentName, instance);
        }
        return parentContext;
      }

      const parentInstance = findParentInstance(parentName, instance);
      if (parentInstance) {
        return createSimulatedParentContext(parentInstance);
      }
    }

    let current = instance.parent;
    while (current) {
      const context = (current.proxy as any)?.[PARENT_CONTEXT_SYMBOL];
      if (context) {
        if (!context.getInstance) {
          context.getInstance = () => current;
        }
        return context;
      }
      current = current.parent;
    }

    return instance.parent
      ? createSimulatedParentContext(instance.parent)
      : null;
  };

  const emitToParent = (event: string, data?: any) => {
    if (parentRef.value) {
      const exposed = getParentExposed();
      if (exposed && typeof exposed[event] === "function") {
        try {
          exposed[event](data, instanceId, name);
        } catch (error) {
          console.warn(`Error calling parent method ${event}:`, error);
        }
      }
    }
  };

  const getChildIndex = () => {
    if (!parentRef.value) return -1;
    try {
      const children = parentRef.value.getChildren();
      return children.findIndex(
        (child: ChildContext) => child.id === instanceId
      );
    } catch (error) {
      console.warn(`Error finding child index in parent:`, error);
      return -1;
    }
  };

  const childContext: ChildContext = {
    id: instanceId,
    name: name || "anonymous",
    getChildIndex,
    emitToParent,
    getParentExposed,
    getInstance: () => instance,
    getExposed,
  };

  const linkParent = (): boolean => {
    const parent = findParent();
    if (parent) {
      parentRef.value = parent;
      if (parent.addChild && childContext) {
        parent.addChild(childContext);
      }
      getParentExposed();
      console.log(
        `Child ${name || "anonymous"} linked to parent ${parent.name}`
      );
      return true;
    }
    console.log(
      `Child ${name || "anonymous"} no parent found, working in standalone mode`
    );
    return false;
  };

  console.log(`Child ${name || "anonymous"} registered, looking for parent`);

  onMounted(() => {
    let connected = linkParent();
    nextTick(() => {
      connected = linkParent();
      if (!connected) {
        setTimeout(linkParent, 500);
      }
    });
  });

  onUnmounted(() => {
    if (parentRef.value?.removeChild) {
      parentRef.value.removeChild(instanceId);
    }
    console.log(`Child ${name || "anonymous"} unmounted`);
  });

  return {
    childId: instanceId,
    childName: name || "anonymous",
    childIndex: computed(getChildIndex),
    parent: parentRef,
    emitToParent,
    getParentExposed,
    parentExposed: computed(() => parentExposed.value),
    getExposed,
  };
};

/**
 * 检查父组件是否存在
 */
export const hasParent = (parentName?: string): boolean => {
  const instance = getCurrentInstance();
  if (!instance) return false;

  if (parentName) {
    return getParentContext(parentName, instance) !== null;
  }

  let current = instance.parent;
  while (current) {
    if ((current.proxy as any)?.[PARENT_CONTEXT_SYMBOL]) return true;
    current = current.parent;
  }
  return false;
};

/**
 * 获取父组件上下文
 */
export const getParentContextByName = (
  parentName: string
): ParentContext | null => {
  const instance = getCurrentInstance();
  return instance ? getParentContext(parentName, instance) : null;
};

/**
 * 热更新清理函数
 */
export const cleanupComponentRelations = (): void => {
  console.log("Cleaning up component relations for hot reload");
};

// 热更新处理
if (import.meta.hot) {
  import.meta.hot.accept(() => {
    console.log(
      "Hot reload detected, relations will be automatically reconnected"
    );
  });
}
```

## dropdown-index

```html
<template>
  <view
    class="custom-dropdown"
    :style="[styles, customStyle]"
    :class="customClass"
  >
    <view
      :id="customDropdownMenuId"
      class="custom-dropdown-menu"
      :style="[{ height: dropDownMenuHeight }, customDropdownMenuWrapStyle]"
    >
      <view
        v-for="(item, index) in menuList"
        :key="index"
        :style="item.titleStyle"
        class="custom-dropdown-menu-item"
        @tap.stop="menuClick(index)"
      >
        <slot name="text" :item="item" :index="index" :current="current" />
      </view>
    </view>
    <view
      class="custom-dropdown-content"
      :style="[
        dropDownContentStyle,
        {
          transition: `opacity ${Number(duration) / 1000}s linear`,
          top: dropDownMenuHeight,
          height: `${contentHeight}px`,
        },
        customDropDownContentStyle,
      ]"
      @tap="maskClick"
      @touchmove.stop.prevent
    >
      <view
        class="custom-dropdown-content-popup"
        :style="[dropDownContentPopupStyle]"
        @tap.stop.prevent
      >
        <slot />
      </view>
      <view class="custom-dropdown-content-mask" />
    </view>
  </view>
</template>

<script setup lang="ts">
  import { getUuid, useParent } from "@/hooks/use-comp-relation";
  import { isArray } from "@/utils/type-check";
  import { computed, getCurrentInstance, nextTick, onMounted, ref } from "vue";

  export type RectResultType<T extends boolean> = T extends true
    ? UniApp.NodeInfo[]
    : UniApp.NodeInfo;
  export interface MenuListItemType {
    title: string;
    disabled: boolean;
    titleStyle: AnyStyleType;
    childIndex: number;
  }
  export interface DropDownPropsType {
    closeOnClickMask?: boolean;
    closeOnClickSelf?: boolean;
    duration?: number;
    dropDownMenuHeight?: string;
    customClass?: string;

    customDropdownMenuWrapStyle?: AnyStyleType;
    customDropDownContentStyle?: AnyStyleType;
    customDropDownContentPopupStyle?: AnyStyleType;
    customStyle?: AnyStyleType;
  }

  defineOptions({
    name: "CustomDropdown",
    addGlobalClass: true,
    virtualHost: true,
    styleIsolation: "shared",
  });

  const props = withDefaults(defineProps<DropDownPropsType>(), {
    closeOnClickMask: true,
    closeOnClickSelf: true,
    duration: 300,
    dropDownMenuHeight: "80rpx",
    customClass: "",

    customDropdownMenuWrapStyle: () => ({}),
    customDropDownContentStyle: () => ({}),
    customDropDownContentPopupStyle: () => ({}),
    customStyle: () => ({}),
  });

  const emit = defineEmits(["open", "close"]);

  const getRect = <T extends boolean>(
    selector: string,
    all: T,
    scope?: any,
    useFields?: boolean
  ): Promise<RectResultType<T>> => {
    return new Promise<RectResultType<T>>((resolve, reject) => {
      let query: UniNamespace.SelectorQuery | null = null;
      if (scope) {
        query = uni.createSelectorQuery().in(scope);
      } else {
        query = uni.createSelectorQuery();
      }

      const method = all ? "selectAll" : "select";

      const callback = (rect: UniApp.NodeInfo | UniApp.NodeInfo[]) => {
        if (all && isArray(rect) && rect.length > 0) {
          resolve(rect as RectResultType<T>);
        } else if (!all && rect) {
          resolve(rect as RectResultType<T>);
        } else {
          reject(new Error("No nodes found"));
        }
      };

      if (useFields) {
        query[method](selector)
          .fields({ size: true, node: true }, callback)
          .exec();
      } else {
        query[method](selector).boundingClientRect(callback).exec();
      }
    });
  };

  const { children } = useParent("custom-dropdown");

  const uuid = getUuid();

  const menuList = ref<MenuListItemType[]>([]);
  const active = ref(false);
  const current = ref<number>(-2);
  const dropDownContentStyle = ref<any>({ zIndex: -1, opacity: 0 });
  const contentHeight = ref<number>(0);
  const instance = getCurrentInstance();
  const customDropdownMenuId = `customDropdownMenu${uuid}`;

  // 兼容头条样式
  const styles = computed(() => {
    const style: AnyStyleType = {};
    // #ifdef MP-TOUTIAO
    style.width = "100vw";
    // #endif
    return style;
  });

  const dropDownContentPopupStyle = computed<any>(() => {
    const style: AnyStyleType = Object.assign(
      {},
      props.customDropDownContentPopupStyle
    );
    // 进行Y轴位移，展开状态时，恢复原位。收齐状态时，往上位移100%，进行隐藏
    style.transform = `translateY(${active.value ? 0 : "-100%"})`;
    style["transition-duration"] = `${Number(props.duration) / 1000}s`;
    return style;
  });

  const getContentHeight = () => {
    const windowHeight = uni.getSystemInfoSync().windowHeight;

    getRect(`#${customDropdownMenuId}`, false, instance?.proxy).then(
      (res: any) => {
        // 这里获取的是dropdown的尺寸，在H5上，uniapp获取尺寸是有bug的(以前提出修复过，后来又出现了此bug，目前hx2.8.11版本)
        // H5端bug表现为元素尺寸的top值为导航栏底部到到元素的上边沿的距离，但是元素的bottom值确是导航栏顶部到元素底部的距离
        // 二者是互相矛盾的，本质原因是H5端导航栏非原生，uni的开发者大意造成
        // 这里取菜单栏的botton值合理的，不能用res.top，否则页面会造成滚动
        console.log("res", res);
        contentHeight.value = windowHeight - res.bottom;
      }
    );
  };

  const init = () => {
    menuList.value = [];
    children.forEach((child: any) => {
      const show = child?.getExposed()?.props.show !== false;
      if (!show) return;

      menuList.value.push({
        title: child?.getExposed()?.props.title ?? "",
        disabled: child?.getExposed()?.props.disabled ?? false,
        titleStyle: child?.getExposed()?.props.titleStyle ?? {},
        childIndex: children.indexOf(child),
      });
    });
  };

  const open = (index: number) => {
    // 嵌套popup使用时可能获取不到正确的高度，重新计算
    if (contentHeight.value < 1) getContentHeight();
    dropDownContentStyle.value = { zIndex: 11 };
    active.value = true;
    current.value = index;
    // 历遍所有的子元素，将索引匹配的项标记为激活状态，因为子元素是通过v-if控制切换的
    // 之所以不是因display: none，是因为nvue没有display这个属性
    const childIndex = menuList.value[index]?.childIndex; // 避免访问到show为false的项
    children.forEach((child: any, idx: number) => {
      child?.getExposed()?.setActive(childIndex === idx);
    });
    emit("open", current.value);
  };

  const close = () => {
    emit("close", current.value);
    active.value = false;
    current.value = -2;
    dropDownContentStyle.value = { zIndex: -1, opacity: 0 };
  };

  const menuClick = (index: number) => {
    // 判断是否被禁用
    if (menuList.value[index]?.disabled) return;
    // 如果点击时的索引和当前激活项索引相同，意味着点击了激活项，需要收起下拉菜单
    if (index === current.value && props.closeOnClickSelf) {
      close();
      // 等动画结束后，再移除下拉菜单中的内容，否则直接移除，也就没有下拉菜单收起的效果了
      const childIndex = menuList.value[index]?.childIndex; // 避免访问到show为false的项
      setTimeout(() => {
        if (childIndex !== undefined && children[childIndex]) {
          children[childIndex]?.getExposed()?.setActive(false);
        }
      }, Number(props.duration));
      return;
    }
    open(index);
  };

  const maskClick = () => {
    if (!props.closeOnClickMask) return;
    close();
  };

  onMounted(() => {
    getContentHeight();
    nextTick(() => {
      init();
    });
  });

  defineExpose({
    init,
    close,
    open,
    getContentHeight,
    children,
    menuList,
  });
</script>

<style scoped lang="scss">
  .custom-dropdown {
    flex: 1;
    width: 100%;
    position: relative;

    .custom-dropdown-menu {
      position: relative;
      z-index: 11;
      /* #ifndef APP-NVUE */
      display: flex;
      flex-direction: row;
      /* #endif */
      height: 80rpx;

      .custom-dropdown-menu-item {
        flex: 1;
        /* #ifndef APP-NVUE */
        display: flex;
        flex-direction: row;
        /* #endif */
        justify-content: center;
        align-items: center;
      }
    }

    .custom-dropdown-content {
      position: absolute;
      z-index: 8;
      width: 100%;
      left: 0px;
      bottom: 0;
      overflow: hidden;

      .custom-dropdown-content-mask {
        position: absolute;
        z-index: 9;
        background: rgba(0, 0, 0, 0.3);
        width: 100%;
        left: 0;
        top: 0;
        bottom: 0;
      }

      .custom-dropdown-content-popup {
        position: relative;
        z-index: 10;
        transition: all 0.3s;
        transform: translate3D(0, -100%, 0);
        overflow: hidden;
      }
    }
  }
</style>
```

## dropdown-item

```html
<template>
  <view
    v-if="show && active"
    :class="customClass"
    :style="customStyle"
    @touchmove.stop.prevent
    @tap.stop.prevent
  >
    <slot />
  </view>
</template>

<script setup lang="ts">
  import { useChildren } from "@/hooks/use-comp-relation";
  import { ref, watch } from "vue";

  export interface DropDownItemPropsType {
    title?: string;
    disabled?: boolean;
    show?: boolean;
    customClass?: string;
    titleStyle?: AnyStyleType;
    customStyle?: AnyStyleType;
  }

  defineOptions({
    name: "CustomDropdownItem",
    addGlobalClass: true,
    virtualHost: true,
    styleIsolation: "shared",
  });
  // props 定义
  const props = withDefaults(defineProps<DropDownItemPropsType>(), {
    show: true,
    title: "",
    disabled: false,
    customClass: "",
    titleStyle: () => ({}),
    customStyle: () => ({}),
  });

  // emits 定义
  const { emitToParent } = useChildren("CustomDropdownItem", "CustomDropdown");

  // 当前项是否处于展开状态
  const active = ref(false);

  watch(
    () => props.show,
    () => {
      emitToParent("init");
    }
  );

  const setActive = (value: boolean) => {
    active.value = value;
  };

  defineExpose({
    setActive,
    props,
  });
</script>
```
