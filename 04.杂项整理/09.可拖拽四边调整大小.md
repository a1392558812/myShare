# 可拖拽四边调整大小

> 水水水水水水水水水水水水水水

<vue3-sfc>
<vue3-file name="App.vue">
<template>
  <wrap :defaultWidth="boxData.width" :defaultHeight="boxData.height" :defaultX="boxData.x" :defaultY="boxData.y" @updateMove="onUpdateMove" :minWidth="200" :minHeight="100">
    <div class="card-grid">
       可拖拽主体移动 + 拖拽四边调整大小
        <p>宽: {{ boxData.width }}px, 高: {{ boxData.height }}px</p>
        <p>位置: ({{ boxData.x }}px, {{ boxData.y }}px)</p>
    </div>
  </wrap>
</template>

<script setup>
import { reactive } from 'vue';
import wrap from './wrap.vue'

const boxData = reactive({
  width: 200,
  height: 100,
  x: 150,
  y: 150
})

const onUpdateMove = (data) => {
  Object.assign(boxData, data)
}
</script>
</vue3-file>

<vue3-file name="wrap.vue">
<template>
  <div class="canvas-container">
    <div class="canvas" ref="canvasRef">
      <div class="resizable-element" :style="{
        width: `${width}px`,
        height: `${height}px`,
        left: `${x}px`,
        top: `${y}px`
      }" ref="elementRef" @mousedown="(e) => startDrag(e)" :class="{ resizing: isResizing, dragging: isDragging }">
        <div class="element-content">
          <slot></slot>
        </div>

        <div class="resize-handle top" @mousedown="(e) => startResize('top', e)"></div>
        <div class="resize-handle right" @mousedown="(e) => startResize('right', e)"></div>
        <div class="resize-handle bottom" @mousedown="(e) => startResize('bottom', e)"></div>
        <div class="resize-handle left" @mousedown="(e) => startResize('left', e)"></div>
        <div class="resize-handle top-left" @mousedown="(e) => startResize('top-left', e)"></div>
        <div class="resize-handle top-right" @mousedown="(e) => startResize('top-right', e)"></div>
        <div class="resize-handle bottom-right" @mousedown="(e) => startResize('bottom-right', e)"></div>
        <div class="resize-handle bottom-left" @mousedown="(e) => startResize('bottom-left', e)"></div>
      </div>
    </div>

  </div>
</template>

<script setup>
import { ref, onUnmounted, watch } from 'vue';

const props = defineProps({
  defaultWidth: { type: Number, default: 300 },
  defaultHeight: { type: Number, default: 300 },
  defaultX: { type: Number, default: 100 },
  defaultY: { type: Number, default: 100 },
  minWidth: { type: Number, default: 100 },
  minHeight: { type: Number, default: 100 },
})

const width = ref(props.defaultWidth);
const height = ref(props.defaultHeight);
const x = ref(props.defaultX);
const y = ref(props.defaultY);

const emit = defineEmits(['updateMove']);

watch(() => [width.value, height.value, x.value, y.value], (newValue) => {
  emit('updateMove', {
    width: newValue[0],
    height: newValue[1],
    x: newValue[2],
    y: newValue[3]
  });
});

const canvasRef = ref(null);
const elementRef = ref(null);

const isResizing = ref(false); // 调整大小状态
const isDragging = ref(false); // 拖拽位置状态
const resizeDirection = ref('');

const startX = ref(0);
const startY = ref(0);
const startWidth = ref(0);
const startHeight = ref(0);
const startLeft = ref(0);
const startTop = ref(0);

const offsetX = ref(0);
const offsetY = ref(0);

const startResize = (direction, e) => {
  e.preventDefault();
  e.stopPropagation();
  isResizing.value = true;
  isDragging.value = false; // 确保拖拽状态关闭
  resizeDirection.value = direction;

  startX.value = e.clientX;
  startY.value = e.clientY;
  startWidth.value = width.value;
  startHeight.value = height.value;
  startLeft.value = x.value;
  startTop.value = y.value;

  document.addEventListener('mousemove', handleResize);
  document.addEventListener('mouseup', stopAll); // 统一用stopAll停止

  if (elementRef.value) {
    elementRef.value.classList.add('resizing');
  }
};

const handleResize = (e) => {
  if (!isResizing.value) return;

  const deltaX = e.clientX - startX.value;
  const deltaY = e.clientY - startY.value;
  const canvasRect = canvasRef.value.getBoundingClientRect();

  switch (resizeDirection.value) {
    case 'right':
      width.value = Math.max(props.minWidth, startWidth.value + deltaX);
      break;
    case 'left':
      const newLeft = startLeft.value + deltaX;
      const newWidth = startWidth.value - deltaX;
      if (newLeft >= 0 && newWidth >= props.minWidth) {
        x.value = newLeft;
        width.value = newWidth;
      }
      break;
    case 'bottom':
      height.value = Math.max(props.minHeight, startHeight.value + deltaY);
      break;
    case 'top':
      const newTop = startTop.value + deltaY;
      const newHeight = startHeight.value - deltaY;
      if (newTop >= 0 && newHeight >= props.minHeight) {
        y.value = newTop;
        height.value = newHeight;
      }
      break;
    case 'bottom-right':
      width.value = Math.max(props.minWidth, startWidth.value + deltaX);
      height.value = Math.max(props.minHeight, startHeight.value + deltaY);
      break;
    case 'bottom-left':
      const blNewLeft = startLeft.value + deltaX;
      const blNewWidth = startWidth.value - deltaX;
      const blNewHeight = startHeight.value + deltaY;
      if (blNewLeft >= 0 && blNewWidth >= props.minWidth) {
        x.value = blNewLeft;
        width.value = blNewWidth;
      }
      height.value = Math.max(props.minHeight, blNewHeight);
      break;
    case 'top-right':
      const trNewWidth = startWidth.value + deltaX;
      const trNewTop = startTop.value + deltaY;
      const trNewHeight = startHeight.value - deltaY;
      width.value = Math.max(props.minWidth, trNewWidth);
      if (trNewTop >= 0 && trNewHeight >= props.minHeight) {
        y.value = trNewTop;
        height.value = trNewHeight;
      }
      break;
    case 'top-left':
      const tlNewLeft = startLeft.value + deltaX;
      const tlNewWidth = startWidth.value - deltaX;
      const tlNewTop = startTop.value + deltaY;
      const tlNewHeight = startHeight.value - deltaY;
      if (tlNewLeft >= 0 && tlNewWidth >= props.minWidth) {
        x.value = tlNewLeft;
        width.value = tlNewWidth;
      }
      if (tlNewTop >= 0 && tlNewHeight >= props.minHeight) {
        y.value = tlNewTop;
        height.value = tlNewHeight;
      }
      break;
  }

  const maxX = canvasRect.width - width.value;
  const maxY = canvasRect.height - height.value;
  x.value = Math.min(maxX, Math.max(0, x.value));
  y.value = Math.min(maxY, Math.max(0, y.value));
};

const startDrag = (e) => {
  // 只有当不是调整大小状态时，才允许拖拽位置
  if (isResizing.value) return;

  e.preventDefault();
  isDragging.value = true;
  const canvasRect = canvasRef.value.getBoundingClientRect();
  const elementRect = elementRef.value.getBoundingClientRect();

  offsetX.value = e.clientX - (elementRect.left - canvasRect.left);
  offsetY.value = e.clientY - (elementRect.top - canvasRect.top);

  document.addEventListener('mousemove', handleDrag);
  document.addEventListener('mouseup', stopAll);

  if (elementRef.value) {
    elementRef.value.classList.add('dragging');
  }
};

const handleDrag = (e) => {
  if (!isDragging.value) return;

  const canvasRect = canvasRef.value.getBoundingClientRect();
  let newX = e.clientX - offsetX.value;
  let newY = e.clientY - offsetY.value;

  const maxX = canvasRect.width - width.value;
  const maxY = canvasRect.height - height.value;
  newX = Math.min(maxX, Math.max(0, newX));
  newY = Math.min(maxY, Math.max(0, newY));

  x.value = newX;
  y.value = newY;
};

const stopAll = () => {
  isResizing.value = false;
  isDragging.value = false;
  resizeDirection.value = '';

  document.removeEventListener('mousemove', handleResize);
  document.removeEventListener('mousemove', handleDrag);
  document.removeEventListener('mouseup', stopAll);

  if (elementRef.value) {
    elementRef.value.classList.remove('resizing', 'dragging');
  }
};

onUnmounted(() => {
  document.removeEventListener('mousemove', handleResize);
  document.removeEventListener('mousemove', handleDrag);
  document.removeEventListener('mouseup', stopAll);
});
</script>

<style scoped>
.canvas-container {
  padding: 20px;
}

.canvas {
  width: 100%;
  height: 500px;
  background-color: #f0f2f5;
  border: 2px dashed #ccc;
  position: relative;
  overflow: hidden;
}

.resizable-element {
  position: absolute;
  background-color: #ffffff;
  border: 2px solid #42b983;
  border-radius: 4px;
  padding: 16px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
  transition: border-color 0.2s, cursor 0.2s;
  cursor: move;
}

.resizable-element.dragging {
  border-color: #2c975d;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
}

.resizable-element.resizing {
  border-color: #2c975d;
  user-select: none;
  cursor: inherit;
}

.element-content {
  color: #333;
  font-size: 14px;
}

.element-content p {
  margin-top: 8px;
  font-size: 12px;
  color: #666;
  margin: 8px 0 0;
}

.resize-handle {
  position: absolute;
  background-color: #fff;
  border: 1px solid #42b983;
  z-index: 10;
  cursor: inherit;
}

.resize-handle.top,
.resize-handle.bottom {
  height: 6px;
  width: 40px;
  margin-left: -20px;
  left: 50%;
  cursor: ns-resize;
}

.resize-handle.left,
.resize-handle.right {
  width: 6px;
  height: 40px;
  margin-top: -20px;
  top: 50%;
  cursor: ew-resize;
}

.resize-handle.top {
  top: -4px;
}

.resize-handle.right {
  right: -4px;
}

.resize-handle.bottom {
  bottom: -4px;
}

.resize-handle.left {
  left: -4px;
}

.resize-handle.top-left,
.resize-handle.bottom-right {
  cursor: nwse-resize;
}

.resize-handle.top-right,
.resize-handle.bottom-left {
  cursor: nesw-resize;
}

.resize-handle.top-left {
  top: -5px;
  left: -5px;
  width: 10px;
  height: 10px;
}

.resize-handle.top-right {
  top: -5px;
  right: -5px;
  width: 10px;
  height: 10px;
}

.resize-handle.bottom-right {
  bottom: -5px;
  right: -5px;
  width: 10px;
  height: 10px;
}

.resize-handle.bottom-left {
  bottom: -5px;
  left: -5px;
  width: 10px;
  height: 10px;
}

.resize-handle:hover {
  background-color: #42b983;
}
</style>

</vue3-file>
</vue3-sfc>

// 👇👇👇 纯 demo 演示

<iframe width="100%" height="500px" frameborder="1" scrolling="auto" src="https://code.juejin.cn/pen/7551251954874187811"></iframe>
