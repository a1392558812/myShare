# waterfall 瀑布流

> 水水水水水水水，此处抽取的是[【uv-ui】](https://www.uvui.cn/components/waterfall.html)的 waterfall 组件。

- 部分工具函数已经抽取，本人人懒，推荐先看工具函数有无重复代码
  - @/utils/components-tools.ts ---> 04.杂项整理/35.components-tools.md
  - @/utils/type-check.ts ---> 03.杂项整理/14.类型保护工具函数.md

```html
<template>
  <view class="custom-waterfall" :style="[customStyle]">
    <!-- #ifndef APP-NVUE -->
    <view class="custom-waterfall-gap-left" :style="[{ width: leftGap }]" />
    <template v-if="columnNum >= 1">
      <view id="custom-waterfall-1" class="custom-waterfall-column">
        <slot name="list1" />
      </view>
    </template>
    <template v-if="columnNum >= 2">
      <view
        class="custom-waterfall-gap-center"
        :style="[{ width: columnGap }]"
      />
      <view id="custom-waterfall-2" class="custom-waterfall-column">
        <slot name="list2" />
      </view>
    </template>
    <template v-if="columnNum >= 3">
      <view
        class="custom-waterfall-gap-center"
        :style="[{ width: columnGap }]"
      />
      <view id="custom-waterfall-3" class="custom-waterfall-column">
        <slot name="list3" />
      </view>
    </template>
    <template v-if="columnNum >= 4">
      <view
        class="custom-waterfall-gap-center"
        :style="[{ width: columnGap }]"
      />
      <view id="custom-waterfall-4" class="custom-waterfall-column">
        <slot name="list4" />
      </view>
    </template>
    <template v-if="columnNum >= 5">
      <view
        class="custom-waterfall-gap-center"
        :style="[{ width: columnGap }]"
      />
      <view id="custom-waterfall-5" class="custom-waterfall-column">
        <slot name="list5" />
      </view>
    </template>
    <view class="custom-waterfall-gap-right" :style="[{ width: rightGap }]" />
    <!-- #endif -->
    <!-- #ifdef APP-NVUE -->
    <waterfall
      :column-count="columnNum"
      :show-scrollbar="false"
      column-width="auto"
      :column-gap="columnGap"
      :left-gap="leftGap"
      :right-gap="rightGap"
      :always-scrollable-vertical="true"
      :style="[nvueWaterfallStyle]"
      @loadmore="scrolltolower"
    >
      <slot />
    </waterfall>
    <!-- #endif -->
  </view>
</template>

<script setup lang="ts">
  import { queryRect, sleep } from "@/utils/components-tools";
  import { isArray } from "@/utils/type-check";
  import { computed, getCurrentInstance, onMounted, ref, watch } from "vue";

  export interface WaterfallPropsType {
    value?: any[];
    modelValue?: any[];
    columnCount: number;
    leftGap: string;
    rightGap: string;
    columnGap: string;
    width: string;
    height: string;
    customNvueContentStyle?: AnyStyleType;
    customStyle?: AnyStyleType;
    addTime: number;
    idKey: string;
    ifManualControl?: boolean;
  }

  const props = withDefaults(defineProps<WaterfallPropsType>(), {
    value: () => [],
    modelValue: () => [],
    columnCount: 2,
    leftGap: "0",
    rightGap: "0",
    columnGap: "0",
    width: "100%",
    height: "auto",
    customNvueContentStyle: () => ({}),
    customStyle: () => ({}),
    addTime: 0,
    idKey: "waterfallId",
    ifManualControl: false,
  });

  const emit = defineEmits<{
    (e: "scrolltolower"): void;
    (e: "changeList", data: any): void;
    (e: "finish"): void;
    (e: "input", data: any[]): void;
    (e: "update:modelValue", data: any[]): void;
    (e: "clear"): void;
    (e: "remove", id: any): void;
  }>();

  // 数据定义
  const list1 = ref([]);
  const list2 = ref([]);
  const list3 = ref([]);
  const list4 = ref([]);
  const list5 = ref([]);

  const customWaterfall1Ref = ref<HTMLElement>();
  const customWaterfall2Ref = ref<HTMLElement>();
  const customWaterfall3Ref = ref<HTMLElement>();
  const customWaterfall4Ref = ref<HTMLElement>();
  const customWaterfall5Ref = ref<HTMLElement>();

  const tempList = ref<any[]>([]);
  const instance = getCurrentInstance();

  const columnNum = computed(() => {
    return props.columnCount <= 0
      ? 0
      : props.columnCount >= 5
      ? 5
      : props.columnCount;
  });

  const nvueWaterfallStyle = computed(() => {
    const style: any = {};
    if (props.width) {
      style.width = props.width;
    } else {
      style.width = `${uni.getSystemInfoSync().windowWidth}px`;
    }

    if (props.height) {
      style.height = props.height;
    } else {
      style.height = `${uni.getSystemInfoSync().windowHeight}px`;
    }

    return Object.assign({}, style, props.customNvueContentStyle);
  });

  const getMin = (arr: (UniApp.NodeInfo & { name: number })[]) => {
    let result: (UniApp.NodeInfo & { name: number }) | null = null;
    const filter = arr.filter((item) => item.height === 0);
    if (!filter.length) {
      const min = Math.min(
        ...arr.map((item) => {
          return item.height!;
        })
      );
      const [item] = arr.filter((item) => item.height === min);
      result = item;
    } else {
      const newArr: {
        len: number;
        item: UniApp.NodeInfo & { name: number };
      }[] = [];
      arr.forEach((item, index) => {
        const listRefs = [list1, list2, list3, list4, list5];
        newArr.push({ len: listRefs[index].value.length, item });
      });
      const minLen = Math.min(
        ...newArr.map((item) => {
          return item.len;
        })
      );
      try {
        const { item } = newArr.find(
          (item) => item.len === minLen && item.item.height === 0
        )!;
        result = item;
      } catch (e) {
        console.log(e);
        const { item } = newArr.find((item) => item.item.height === 0)!;
        result = item;
      }
    }
    return result;
  };

  // 方法定义
  const scrolltolower = (e: Event) => {
    sleep(30).then(() => {
      console.log(e);
      emit("scrolltolower");
    });
  };

  // 初始化完成或者watch监听到新数据添加时，递归调用splitData

  /**
   * 当ifManualControl为true时，
   * 1. 则需要自己手动的去调用splitData方法，通常在异步获得数据后，相当不推荐使用，除非后台没有返图片宽高
   * 2. 不可以在tempList.value.length递归还未完成就再去加载新的数据（在splitData函数还未递归结束，触底/下拉刷新等会造成数据紊乱）
   *
   *
   *
   * <customWaterfall ref="waterfallRef" :if-manual-control="true" v-model="list" @changeList="changeList">
   *    <!-- 第一列数据 -->
   *    <template v-slot:list1>
   *      <!-- 为了磨平部分平台的BUG，必须套一层view -->
   *      <view>
   *        <!-- 图片需要封装一下，防止图片过大一直卡在加载图片，需要设置一个图片最大加载时间，超过时间未加载完成则认为加载失败,比如500ms -->
   *        <customImage
   *          v-for="(item, index) in list1"
   *          :key="item.id"
   *          :style="{ width: item.width + 'px' }"
   *          :src="item.image"
   *          @load="onImageLoad"
   *          @error="onImageError" />
   *      </view>
   *    </template>
   *    <!-- 第二列数据 -->
   *    <template v-slot:list2>
   *      ......
   *    </template>
   *  </customWaterfall>
   *
   *
   * const pageData = reactive({
   *    list: [],
   *    list1: [],
   *    list2: [],
   *    total: 0,
   *    status: 'loadMore',
   * })
   *
   * const changeList = (e: { name: string; value: any }) => {
   *    pageData[e.name].push(e.value);
   * }
   *
   *
   * const toSplitData = () => {
   *    nextTick(async () => {
   *      if (waterfallRef.value.tempList.value.length) {
   *        await sleep(timeout < 200 ? 200 : timeout)
   *        waterfallRef.value?.splitData()
   *      }
   *    })
   * }
   *
   * const getList = async () => {
   *    // ......
   *    pageData.list.value = res.data || []
   *    pageData.total = res.total || 0
   *    pageData.status = pageData.list.value.length >= pageData.total ? 'noMore' : 'loadMore'
   *    toSplitData()
   * }
   *
   * // 手动在获取图片加载完成或者加载错误后再去向list1 list2 中push数据
   * const onImageLoad = () => {
   *    toSplitData()
   * }
   *
   * // 手动在获取图片加载完成或者加载错误后再去向list1 list2 中push数据
   * const onImageError = (e: any) => {
   *   toSplitData()
   * }
   *
   *
   */
  const splitData = async () => {
    const rectArr: (UniApp.NodeInfo & { name: number })[] = [];
    const emitList: any = {};
    if (!tempList.value.length) return;
    const refMap: AnyObject = {
      1: customWaterfall1Ref.value,
      2: customWaterfall2Ref.value,
      3: customWaterfall3Ref.value,
      4: customWaterfall4Ref.value,
      5: customWaterfall5Ref.value,
    };
    for (let i = 1; i <= columnNum.value; i++) {
      const rect = await queryRect(
        `#custom-waterfall-${i}`,
        instance!,
        refMap[i]
      );
      rectArr.push({ ...rect, name: i });
    }
    const item = tempList.value[0];
    // 因为经过上面两个await节点查询和定时器，数组有可能会变成空[]，导致item的值为undefined
    // 解决多次快速滚动会导致数据乱的问题
    if (!item) return;
    const minCol = getMin(rectArr);
    // 列宽可能使用的到
    item.width = minCol.width;
    const listRefs: any[] = [list1, list2, list3, list4, list5];
    listRefs[minCol.name - 1].value.push(item);
    emitList.name = `list${minCol.name}`;
    emitList.value = item;
    emit("changeList", emitList);
    // 移除临时数组中已处理的数据
    tempList.value.splice(0, 1);
    // 如果还有数据则继续执行
    if (tempList.value.length) {
      if (!props.ifManualControl) {
        let _timeout = props.addTime;
        // 部分平台在延时较短的情况会出现BUG
        // #ifdef MP-BAIDU
        _timeout = _timeout < 200 ? 200 : _timeout;
        // #endif
        await sleep(_timeout);
        splitData();
      }
    } else {
      emit("finish");
    }
  };

  const clear = async () => {
    // 清除数据
    for (let i = 0; i < props.columnCount; i++) {
      const listRefs = [list1, list2, list3, list4, list5];
      if (listRefs[i]) {
        listRefs[i].value = [];
      }
    }
    // #ifdef VUE2
    emit("input", []);
    // #endif
    // #ifdef VUE3
    emit("update:modelValue", []);
    // #endif
    tempList.value = [];
    await sleep(300);
    emit("clear");
  };

  const remove = (id: any) => {
    let index = -1;
    // 删除组件数据
    for (let i = 1; i <= props.columnCount; i++) {
      const listRefs = [list1, list2, list3, list4, list5];
      if (listRefs[i - 1]) {
        index = listRefs[i - 1].value.findIndex(
          (item: any) => item[props.idKey] === id
        );
        if (index !== -1) {
          listRefs[i - 1].value.splice(index, 1);
        }
      }
    }
    // 同时删除父组件对应的数据
    // #ifdef VUE2
    index = props.value.findIndex((item: any) => item[props.idKey] === id);
    if (index !== -1) {
      const newData = [...props.value];
      newData.splice(index, 1);
      emit("input", newData);
    }
    // #endif
    // #ifdef VUE3
    index = props.modelValue.findIndex((item: any) => item[props.idKey] === id);
    if (index !== -1) {
      const newData = [...props.modelValue];
      newData.splice(index, 1);
      emit("update:modelValue", newData);
    }
    // #endif
    emit("remove", id);
  };

  // 监听
  watch(
    props.modelValue,
    (nVal, oVal) => {
      // #ifndef APP-NVUE
      if (nVal.length !== 0) {
        // 取出数组发生变化的部分
        const startIndex = isArray(oVal) && oVal.length > 0 ? oVal.length : 0;
        // 拼接原有数据
        tempList.value = tempList.value.concat(
          uni.$uv.deepClone(nVal.slice(startIndex))
        );
        if (!props.ifManualControl) {
          splitData();
        }
      }
      // #endif
    },
    { deep: true }
  );

  // 生命周期
  onMounted(() => {
    // #ifndef APP-NVUE
    tempList.value = uni.$uv.deepClone(props.modelValue);
    if (!props.ifManualControl) {
      splitData();
    }
    // #endif
  });

  defineExpose({
    tempList, // 在tempList.value.length未等于0前，不可以去加载新的数据
    clear,
    remove,
  });
</script>

<style lang="scss" scoped>
  .custom-waterfall {
    // #ifndef APP-NVUE
    display: flex;
    // #endif
    flex-direction: row;
    align-items: flex-start;

    .custom-waterfall-column {
      // #ifndef APP-NVUE
      display: flex;
      // #endif
      flex-direction: row;
      flex: 1;
      // #ifndef APP-NVUE
      height: auto;
      // #endif
    }
  }
</style>
```
