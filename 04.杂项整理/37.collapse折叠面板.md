# collapse 折叠面板

> @/utils/components-tools.ts ---> 04.杂项整理/35.components-tools.md

## 使用

```html
<template>
  <view>
    <customCollapse :show="show">
      <template #label="slotData">
        <view @click="slotData.animating ? () => {} : show = !show">
          标题-{{ slotData.show }}-{{ slotData.animating }}
        </view>
      </template>
      <template #content>
        <view class="bg-[pink]">
          <view>内容内容内容内容内容内容内容内容内容内容内容</view>
          <view>内容内容内容内容内容内容内容内容内容内容内容</view>
          <view>内容内容内容内容内容内容内容内容内容内容内容</view>
          <view>内容内容内容内容内容内容内容内容内容内容内容</view>
        </view>
      </template>
    </customCollapse>
    <view>123123123</view>
  </view>
</template>

<script setup lang="ts">
  import customCollapse from "@/components/collapse/index.vue";
  import { ref } from "vue";

  const show = ref(false);
</script>
```

## index.vue

```html
<template>
  <view class="custom-collapse" :class="customClass" :style="customStyle">
    <slot name="label" :show="show" :animating="animating" />
    <view
      :id="contentWrapId"
      ref="contentWrapRef"
      :style="customContentWrapStyle"
      :animation="animationData"
      class="custom-collapse-content-wrap"
    >
      <view :id="contentId" ref="contentRef" :style="customContentStyle">
        <slot v-if="show || animating" name="content" />
      </view>
    </view>
  </view>
</template>

<script setup lang="ts">
  import { getUuid, queryRect, sleep } from "@/utils/components-tools";
  import { getCurrentInstance, nextTick, ref, watch } from "vue";

  const props = withDefaults(
    defineProps<{
      show: boolean;
      duration?: number;

      customClass?: string;
      customStyle?: AnyStyleType;
      customContentStyle?: AnyStyleType;
      customContentWrapStyle?: AnyStyleType;
    }>(),
    {
      show: false,
      duration: 300,

      customClass: "",
      customStyle: () => ({}),
      customContentStyle: () => ({}),
      customContentWrapStyle: () => ({}),
    }
  );

  // #ifdef APP-NVUE
  const animationDom = uni.requireNativePlugin("animation");
  // #endif

  const uuid = getUuid();

  const contentId = `content${uuid}`;
  const contentRef = ref<HTMLElement>();

  const contentWrapId = `contentWrap${uuid}`;
  const contentWrapRef = ref<HTMLElement>();
  const animationData = ref<AnyStyleType>({ height: 0 });

  const instance = getCurrentInstance();
  const animating = ref(false);

  const getContentRect = (): Promise<UniApp.NodeInfo> => {
    return new Promise((resolve, reject) => {
      queryRect(`#${contentId}`, instance!, contentRef.value)
        .then((rect) => {
          console.log("getContentHeight", rect);
          resolve(rect);
        })
        .catch(reject);
    });
  };

  const setContentAnimate = () => {
    // 每次面板打开或者收起时，都查询元素尺寸
    // 好处是，父组件从服务端获取内容后，变更折叠面板后可以获得最新的高度
    getContentRect().then((rect) => {
      const height = props.show ? rect.height || 0 : 0;
      animating.value = true;
      // #ifdef APP-NVUE
      animationDom.transition(
        contentWrapRef.value,
        {
          styles: {
            height: `${height}px`,
          },
          duration: props.duration,
          // 必须设置为true，否则会到面板收起或展开时，页面其他元素不会随之调整它们的布局
          needLayout: true,
          timingFunction: "ease-in-out",
        },
        () => {
          animating.value = false;
        }
      );
      // #endif

      // #ifndef APP-NVUE
      const animation = uni.createAnimation({
        timingFunction: "ease-in-out",
      });
      animation
        .height(height)
        .step({
          duration: props.duration,
        })
        .step();
      // 导出动画数据给面板的animationData值
      animationData.value = animation.export();
      // 标识动画结束
      sleep(props.duration).then(() => {
        animating.value = false;
      });
      // #endif
    });
  };

  watch(
    () => props.show,
    () => {
      nextTick(async () => {
        // #ifndef H5 || MP-WEIXIN
        await sleep(60);
        // #endif
        setContentAnimate();
      });
    },
    { immediate: true }
  );

  defineExpose({
    setContentAnimate,
    animationData,
    animating, // 用于防抖，防止动画没结束就点击关闭
  });
</script>

<style lang="scss" scoped>
  .custom-collapse {
    position: relative;
    .custom-collapse-content-wrap {
      overflow: hidden;
    }
  }
</style>
```
