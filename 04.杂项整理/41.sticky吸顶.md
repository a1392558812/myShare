# sticky 吸顶

> 水水水水水水水，此处抽取的是[【uv-ui】](https://www.uvui.cn/components/sticky.html)的 sticky 组件。

- 部分工具函数已经抽取，本人人懒，推荐先看工具函数有无重复代码
  - @/utils/components-tools.ts ---> 04.杂项整理/35.components-tools.md

```html
<template>
  <view :id="elId" class="custom-sticky" :style="[style]">
    <view :style="[stickyContent]" class="custom-sticky-content">
      <slot />
    </view>
  </view>
</template>

<script setup lang="ts">
  import { getRect, getUuid } from "@/utils/components-tools";
  import {
    computed,
    getCurrentInstance,
    nextTick,
    onMounted,
    onUnmounted,
    ref,
    watch,
  } from "vue";

  export interface StickyPropsType {
    offsetTop?: number;
    customNavHeight?: number;
    disabled?: boolean;
    bgColor?: string;
    zIndex?: number | string;
    index?: string;
    customStyle?: object;
  }

  const props = withDefaults(defineProps<StickyPropsType>(), {
    offsetTop: 0,
    customNavHeight: 0,
    disabled: false,
    bgColor: "rgba(255, 255, 255, 1)",
    zIndex: 970,
    index: "",
    customStyle: () => ({}),
  });

  const cssSticky = ref(false); // 是否使用css的sticky实现
  const stickyTop = ref(0); // 吸顶的top值，因为可能受自定义导航栏影响，最终的吸顶值非offsetTop值
  const elId = ref(`customSticky${getUuid()}`);
  const left = ref(0); // js模式时，吸顶的内容因为处于postition: fixed模式，为了和原来保持一致的样式，需要记录并重新设置它的left，height，width属性
  const width = ref("auto");
  const height = ref("auto");
  const fixed = ref(false); // js模式时，是否处于吸顶模式

  let observer: UniApp.IntersectionObserver | null = null;

  const instance = getCurrentInstance();

  const style = computed(() => {
    const style: AnyStyleType = {};
    if (!props.disabled) {
      if (cssSticky.value) {
        style.position = "sticky";
        style.zIndex = props.zIndex;
        style.top = `${stickyTop.value}px`;
      } else {
        style.height = fixed.value ? height.value : "auto";
      }
    } else {
      // 无需吸顶时，设置会默认的relative(nvue)和非nvue的static静态模式即可
      // #ifdef APP-NVUE
      style.position = "relative";
      // #endif
      // #ifndef APP-NVUE
      style.position = "static";
      // #endif
    }
    style.backgroundColor = props.bgColor;
    return Object.assign({}, style, props.customStyle);
  });

  const stickyContent = computed(() => {
    const style: AnyStyleType = {};
    if (!cssSticky.value) {
      style.position = fixed.value ? "fixed" : "static";
      style.top = `${stickyTop.value}px`;
      style.left = `${left.value}px`;
      style.width = width.value === "auto" ? "auto" : `${width.value}px`;
      style.zIndex = props.zIndex;
    }
    return style;
  });

  const setFixed = (top: number) => {
    // 判断是否出于吸顶条件范围
    fixed.value = top <= stickyTop.value;
  };

  const disconnectObserver = () => {
    // 断掉观察，释放资源
    observer && observer.disconnect();
  };

  const observeContent = () => {
    // 先断掉之前的观察
    disconnectObserver();
    observer = uni.createIntersectionObserver({
      // 检测的区间范围
      thresholds: [0.95, 0.98, 1],
    });
    // 到屏幕顶部的高度时触发
    observer.relativeToViewport({
      top: -stickyTop.value,
    });
    // 绑定观察的元素
    observer.observe(`#${elId.value}`, (res) => {
      setFixed(res.boundingClientRect.top);
    });
  };

  const initObserveContent = () => {
    // 获取吸顶内容的高度，用于在js吸顶模式时，给父元素一个填充高度，防止"塌陷"
    getRect(`#${elId.value}`, false, instance?.proxy).then((res) => {
      height.value = res.height ? `${res.height}px` : "auto";
      left.value = res.left || 0;
      width.value = res.width ? `${res.width}px` : "auto";
      nextTick(() => {
        observeContent();
      });
    });
  };

  // H5通过创建元素的形式嗅探是否支持css sticky
  // 判断浏览器是否支持sticky属性
  const checkCssStickyForH5 = () => {
    // 方法内进行判断，避免在其他平台生成无用代码
    // #ifdef H5
    const vendorList = ["", "-webkit-", "-ms-", "-moz-", "-o-"];
    const vendorListLength = vendorList.length;
    const stickyElement = document.createElement("div");
    for (let i = 0; i < vendorListLength; i++) {
      stickyElement.style.position = `${vendorList[i]}sticky`;
      if (stickyElement.style.position !== "") {
        return true;
      }
    }
    return false;
    // #endif
  };

  // 在APP和微信小程序上，通过uni.createSelectorQuery可以判断是否支持css sticky
  const checkComputedStyle = (): Promise<boolean> => {
    // 方法内进行判断，避免在其他平台生成无用代码
    // #ifdef APP-VUE || MP-WEIXIN
    return new Promise((resolve) => {
      uni
        .createSelectorQuery()
        .in(instance?.proxy)
        .select(`#${elId.value}`)
        .fields(
          {
            computedStyle: ["position"],
          },
          (res) => {
            console.log("checkComputedStyle error", res);
          }
        )
        .exec((e) => {
          resolve(e[0].position === "sticky");
        });
    });
    // #endif
  };

  const checkSupportCssSticky = async () => {
    // #ifdef H5
    // H5，一般都是现代浏览器，是支持css sticky的，这里使用创建元素嗅探的形式判断
    if (checkCssStickyForH5()) {
      cssSticky.value = true;
    }
    // #endif

    // 如果安卓版本高于8.0，依然认为是支持css sticky的(因为安卓7在某些机型，可能不支持sticky)
    const info = uni.getSystemInfoSync();
    if (info.platform.toLowerCase() === "android" && Number(info.system) > 8) {
      cssSticky.value = true;
    }

    // APP-Vue和微信平台，通过computedStyle判断是否支持css sticky
    // #ifdef APP-VUE || MP-WEIXIN
    cssSticky.value = await checkComputedStyle();
    // #endif

    // ios上，从ios6开始，都是支持css sticky的
    if (info.platform.toLowerCase() === "ios") {
      cssSticky.value = true;
    }

    // nvue，是支持css sticky的
    // #ifdef APP-NVUE
    cssSticky.value = true;
    // #endif
  };

  const getStickyTop = () => {
    stickyTop.value = props.offsetTop + props.customNavHeight;
  };

  const init = () => {
    getStickyTop();
    // 判断使用的模式
    checkSupportCssSticky();
    // 如果不支持css sticky，则使用js方案，此方案性能比不上css方案
    if (!cssSticky.value) {
      !props.disabled && initObserveContent();
    }
  };

  onMounted(() => {
    init();
  });

  onUnmounted(() => {
    disconnectObserver();
  });
</script>

<style lang="scss" scoped>
  .custom-sticky {
    /* #ifdef APP-VUE || MP-WEIXIN */
    // 此处默认写sticky属性，是为了给微信和APP通过uni.createSelectorQuery查询是否支持css sticky使用
    position: sticky;
    /* #endif */
  }
</style>
```
