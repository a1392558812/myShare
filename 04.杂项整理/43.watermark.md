# watermark æ°´å°

- éƒ¨åˆ†å·¥å…·å‡½æ•°å·²ç»æŠ½å–ï¼Œæœ¬äººäººæ‡’ï¼Œæ¨èå…ˆçœ‹å·¥å…·å‡½æ•°æœ‰æ— é‡å¤ä»£ç 
  - @/utils/components-tools.ts ---> 04.æ‚é¡¹æ•´ç†/35.components-tools.md

```html
<template>
  <view
    :id="watermarkWrapId"
    ref="watermarkWrapRef"
    class="custom-watermark"
    :class="customClass"
    :style="[
      {
        position: 'fixed',
        overflow: 'hidden',
        zIndex: '999',
        left: '0',
        top: `${navBarHeight}px`,
        right: '0',
        bottom: '0',
      },
      customStyle,
    ]"
  >
    <view
      class="custom-watermark-content"
      :style="[{ opacity }, customContentStyle]"
    >
      <view
        :id="`${calculateId}`"
        ref="calculateRef"
        :style="[itemWrapStyle, {
          position: 'fixed',
          opacity: 0,
          top: 0,
          left: 0,
          transform: `rotate(0deg)`,
        }]"
      >
        <rich-text :nodes="watermark" :style="[itemStyle]" />
      </view>

      <view
        v-for="(item, index) in forLength"
        :key="index"
        :style="[itemWrapStyle]"
      >
        <rich-text :nodes="watermark" :style="[itemStyle]" />
      </view>
    </view>
  </view>
</template>

<script setup lang="ts">
  import { getUuid, queryRect, sleep } from "@/utils/components-tools";
  import {
    computed,
    getCurrentInstance,
    nextTick,
    onMounted,
    ref,
    watch,
  } from "vue";

  export interface WatermarkPropsType {
    watermark?: string; //  æ°´å°å†…å®¹ï¼Œæ”¯æŒhtmlå¯Œæ–‡æœ¬
    navBarHeight?: number; //  å¯¼èˆªæ é«˜åº¦ï¼Œé»˜è®¤0
    color?: string; //  æ°´å°æ–‡å­—é»˜è®¤é¢œè‰²
    fontSize?: number; //  æ°´å°æ–‡å­—é»˜è®¤å¤§å°
    opacity?: number; //  æ°´å°é€æ˜åº¦
    margin?: number; //  æ°´å°ä¹‹é—´ä¸Šä¸‹é—´è·
    rotate?: number; //  æ°´å°æ—‹è½¬è§’åº¦
    column?: number; //  æ°´å°åˆ—æ•°

    customClass?: string; //  è‡ªå®šä¹‰ç±»å
    customStyle?: AnyStyleType; //  è‡ªå®šä¹‰æ ·å¼
    customContentStyle?: AnyStyleType; //  è‡ªå®šä¹‰å†…å®¹æ ·å¼
    customWatermarkItemWrapStyle?: AnyStyleType; //  å•ä¸ªæ°´å°è‡ªå®šä¹‰åŒ…è£¹æ ·å¼
    customWatermarkItemStyle?: AnyStyleType; //  å•ä¸ªæ°´å°è‡ªå®šä¹‰æ ·å¼
  }

  const props = withDefaults(defineProps<WatermarkPropsType>(), {
    watermark: "<div>ğŸ®ğŸºğŸ®ğŸºğŸ®ğŸº</div>",
    color: "#114514",
    navBarHeight: 0,
    fontSize: 16,
    opacity: 0.3,
    margin: 10,
    rotate: -20,
    column: 3,

    customClass: "",
    customStyle: () => ({}),
    customContentStyle: () => ({}),
    customWatermarkItemWrapStyle: () => ({}),
    customWatermarkItemStyle: () => ({}),
  });

  const instance = getCurrentInstance();
  const uuid = getUuid();

  const calculateId = `calculate${uuid}`;
  const calculateRef = ref<HTMLElement>();

  const watermarkWrapId = `watermarkWrap${uuid}`;
  const watermarkWrapRef = ref<HTMLElement>();

  const forLength = ref(0); // æ°´å°æ•°é‡

  const itemWrapStyle = computed<AnyStyleType>(() => {
    return {
      boxSizing: "border-box",
      width: `calc(100% / ${props.column})`,
      padding: `${props.margin}px`,
      flexShrink: 0,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transform: `rotate(${props.rotate}deg)`,
      ...props.customWatermarkItemWrapStyle,
    };
  });

  const itemStyle = computed<AnyStyleType>(() => {
    return Object.assign(
      {},
      {
        boxSizing: "border-box",
        color: props.color,
        fontSize: `${props.fontSize}px`,
        width: `100%`,
        textAlign: "center",
      },
      props.customWatermarkItemStyle,
    );
  });

  const countForLength = () => {
    // è®¡ç®—æ°´å°æ•°é‡
    nextTick(() => {
      sleep(60).then(() => {
        Promise.all([
          queryRect(`#${watermarkWrapId}`, instance, watermarkWrapRef.value),
          queryRect(`#${calculateId}`, instance, calculateRef.value),
        ]).then(([wrapRes, contentRes]) => {
          const wrapH = wrapRes.height || 0;
          const itemH = contentRes.height || 0;

          // é¢å¤–+1é˜²æ­¢è®¡ç®—ç»“æœä¸º0æˆ–è€…è®¡ç®—ç²¾åº¦ä¸å¤Ÿ
          forLength.value = Math.ceil((wrapH / itemH || 0) + 1) * props.column;
        });
      });
    });
  };

  watch(
    () => props.watermark,
    (newVal) => {
      if (newVal) {
        countForLength();
      }
    },
  );

  onMounted(() => {
    if (props.watermark) {
      countForLength();
    }
  });
</script>

<style lang="scss" scoped>
  .custom-watermark {
    /* #ifndef APP-NVUE */
    pointer-events: none;
    /* #endif */

    .custom-watermark-mold {
      position: fixed;
      left: -0;
      top: -0;
      z-index: -1;
      opacity: 0;
    }

    .custom-watermark-content {
      width: 100%;
      height: 100%;
      overflow: hidden;
      display: flex;
      flex-direction: row;
      flex-wrap: wrap;
      justify-content: space-around;
    }
  }
</style>
```
