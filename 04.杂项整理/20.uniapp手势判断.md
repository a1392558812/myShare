# uniapp 手势判断

```typescript
import { onUnmounted, reactive } from "vue";

export interface TouchState {
  startX: number; // 初始化触摸开始点X坐标
  startY: number; // 初始化触摸开始点Y坐标
  startTime: number; // 初始化触摸开始时间
  lastTapTime: number; // 上次点击时间
  longTapTimer: number | undefined; // 长按定时器
  isLongTap: boolean; // 长按标记
  fingerCount: number; // 手指数量
  startDistance: number; // 双指距离
  startAngle: number; // 双指开始角度
  isSwipe: boolean; // 滑动标记
  direction: "" | "left" | "right" | "up" | "down"; // 滑动方向
  swipeThreshold: number; // 滑动距离阈值（px）
  startCenterX: number; // 双指开始中心点X坐标
  startCenterY: number; // 双指开始中心点Y坐标
  isPinch: boolean; // 缩放标记
  pinchThreshold: number; // 双指缩放距离阈值（px）
  rotateThreshold: number; // 双指旋转角度阈值（度）
  doubleFingerSwipeThreshold: number; // 双指滑动距离阈值（px）
  scale: number; // 初始化缩放比例
  rotation: number; // 初始化旋转角度
  isDoubleTap: boolean; // 初始化双击标记
}

export function useGesture(data?: {
  swiperCallBack?: (e: any) => void;
  doubleFingerSwiperCallBack?: (e: any) => void;
  scaleCallBack?: (e: any) => void;
  tapCallBack?: (e: any) => void;
  doubleTapCallBack?: (e: any) => void;
  longTapCallBack?: (e: any) => void;
  touchStart?: (e: any) => void;
  touchMove?: (e: any) => void;
  touchEnd?: (e: any) => void;
  touchState?: Partial<TouchState>;
}) {
  const defaultTouchState: TouchState = {
    startX: 0,
    startY: 0,
    startTime: 0,
    lastTapTime: 0,
    longTapTimer: undefined,
    isLongTap: false,
    fingerCount: 0,
    startDistance: 0,
    startAngle: 0,
    isSwipe: false,
    direction: "",
    swipeThreshold: 150,
    startCenterX: 0,
    startCenterY: 0,
    isPinch: false,
    pinchThreshold: 50,
    rotateThreshold: 10,
    doubleFingerSwipeThreshold: 150,
    scale: 1,
    rotation: 0,
    isDoubleTap: false,
  };

  const touchState = reactive<TouchState>(
    Object.assign(defaultTouchState, data?.touchState || {})
  );

  const calcDistance = (t1: Touch, t2: Touch) => {
    const dx = t2.clientX - t1.clientX;
    const dy = t2.clientY - t1.clientY;
    return Math.sqrt(dx * dx + dy * dy);
  };

  const calcAngle = (t1: Touch, t2: Touch) => {
    const dx = t2.clientX - t1.clientX;
    const dy = t2.clientY - t1.clientY;
    return (Math.atan2(dy, dx) * 180) / Math.PI;
  };

  const calcCenterPoint = (t1: Touch, t2: Touch) => {
    return {
      x: (t1.clientX + t2.clientX) / 2,
      y: (t1.clientY + t2.clientY) / 2,
    };
  };

  const getSwipeDirection = (dx: number, dy: number) => {
    if (Math.abs(dx) > Math.abs(dy)) {
      return dx > 0 ? "right" : "left";
    } else {
      return dy > 0 ? "down" : "up";
    }
  };

  const onTouchStart = (e: any) => {
    const touch = e.touches[0];
    const now = Date.now();

    touchState.startX = touch.clientX;
    touchState.startY = touch.clientY;
    touchState.startTime = now;
    touchState.fingerCount = e.touches.length;
    touchState.isSwipe = false;
    touchState.isLongTap = false;
    touchState.isPinch = false;
    touchState.isDoubleTap = false;
    touchState.direction = "";

    if (touchState.fingerCount === 1) {
      const tapInterval = now - touchState.lastTapTime;
      if (tapInterval < 300 && tapInterval > 0) {
        touchState.isDoubleTap = true;
        touchState.lastTapTime = 0;
        clearTimeout(touchState.longTapTimer);
        data?.doubleTapCallBack?.(e);
        return data?.touchStart?.(e);
      }
      touchState.lastTapTime = now;

      touchState.longTapTimer = setTimeout(() => {
        touchState.isLongTap = true;
        data?.longTapCallBack?.(e);
      }, 500);
      return data?.touchStart?.(e);
    }

    if (touchState.fingerCount === 2) {
      const t1 = e.touches[0];
      const t2 = e.touches[1];
      touchState.startDistance = calcDistance(t1, t2);
      touchState.startAngle = calcAngle(t1, t2);
      const center = calcCenterPoint(t1, t2);
      touchState.startCenterX = center.x;
      touchState.startCenterY = center.y;
      touchState.scale = 1.0;
      touchState.rotation = 0;
      return data?.touchStart?.(e);
    }
    data?.touchStart?.(e);
  };

  const onTouchMove = (e: any) => {
    touchState.direction = "";

    if (touchState.fingerCount === 1 && !touchState.isLongTap) {
      const touch = e.touches[0];
      const dx = touch.clientX - touchState.startX;
      const dy = touch.clientY - touchState.startY;

      if (
        Math.abs(dx) > touchState.swipeThreshold ||
        Math.abs(dy) > touchState.swipeThreshold
      ) {
        touchState.isSwipe = true;
        const direction = getSwipeDirection(dx, dy);
        touchState.direction = direction;
        touchState.startX = touch.clientX;
        touchState.startY = touch.clientY;
        data?.swiperCallBack?.(e);
        return data?.touchMove?.(e);
      }
      return data?.touchMove?.(e);
    }

    if (touchState.fingerCount === 2) {
      const t1 = e.touches[0];
      const t2 = e.touches[1];

      const currentDistance = calcDistance(t1, t2);
      const currentAngle = calcAngle(t1, t2);
      const currentCenter = calcCenterPoint(t1, t2);

      const distanceDiff = Math.abs(currentDistance - touchState.startDistance);
      const angleDiff = Math.abs(currentAngle - touchState.startAngle);
      const centerXDiff = Math.abs(currentCenter.x - touchState.startCenterX);
      const centerYDiff = Math.abs(currentCenter.y - touchState.startCenterY);

      if (
        distanceDiff >= touchState.pinchThreshold ||
        angleDiff >= touchState.rotateThreshold
      ) {
        touchState.isPinch = true;
        const scale = Number(
          (currentDistance / touchState.startDistance).toFixed(2)
        );
        const rotation = Number(
          (currentAngle - touchState.startAngle).toFixed(1)
        );
        touchState.scale = scale;
        touchState.rotation = rotation;
        touchState.startDistance = currentDistance;
        touchState.startAngle = currentAngle;
        data?.scaleCallBack?.(e);
        return data?.touchMove?.(e);
      }

      if (
        centerXDiff >= touchState.doubleFingerSwipeThreshold ||
        centerYDiff >= touchState.doubleFingerSwipeThreshold
      ) {
        touchState.isPinch = false;
        touchState.scale = 1.0;
        touchState.rotation = 0;
        const dx = currentCenter.x - touchState.startCenterX;
        const dy = currentCenter.y - touchState.startCenterY;
        const direction = getSwipeDirection(dx, dy);
        touchState.direction = direction;
        touchState.startCenterX = currentCenter.x;
        touchState.startCenterY = currentCenter.y;
        data?.doubleFingerSwiperCallBack?.(e);
        return data?.touchMove?.(e);
      }
      return data?.touchMove?.(e);
    }
    return data?.touchEnd?.(e);
  };

  const onTouchEnd = (e: any) => {
    const now = Date.now();

    clearTimeout(touchState.longTapTimer);

    if (
      touchState.fingerCount === 1 &&
      !touchState.isLongTap &&
      !touchState.isSwipe &&
      !touchState.isDoubleTap
    ) {
      const touchTime = now - touchState.startTime;
      if (touchTime < 300) {
        data?.tapCallBack?.(e);
      }
    }

    touchState.fingerCount = 0;
    touchState.isLongTap = false;
    touchState.isSwipe = false;
    touchState.isPinch = false;
    touchState.isDoubleTap = false;
    touchState.direction = "";
    touchState.scale = 1;
    touchState.rotation = 0;
    return data?.touchEnd?.(e);
  };

  const clearGestureTimer = () => {
    clearTimeout(touchState.longTapTimer);
  };

  onUnmounted(() => {
    clearGestureTimer();
  });

  return {
    touchState,
    onTouchStart,
    onTouchMove,
    onTouchEnd,
    clearGestureTimer,
  };
}
```
