# uniapp 视图层与逻辑层通信之 renderjs 与 wxs

> 百度小程序的 Filter 过滤器和支付宝小程序的 SJS,由于本人没有深入研究过，就不做过多介绍了

> 前置: [【谜之 wxs，uni-app 如何用它大幅提升性能】](https://ask.dcloud.net.cn/article/36386)

> [【renderjs 详解】](https://ask.dcloud.net.cn/article/40060)

> [【wxs 事件系统】](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html)

引入 renderjs 或者 wxs

引入 wxs

```html
<template>
  <view
    :status="status"
    :change:status="wxs.statusChange"
    :size="size"
    :change:size="wxs.sizeChange"
    @touchstart="wxs.touchstart"
    @touchmove="wxs.touchmove"
    @touchend="wxs.touchend"
  >
    <text>touch-move</text>
  </view>
</template>
<script src="./index.wxs" module="wxs" lang="wxs"></script>
<script>
  export default {
    data() {
      return {
        size: {},
        status: "close", // close, open, move
      };
    },
    methods: {
      closeOther() {
        // 提供对应的方法，呼应在index.wxs中的 `ownerInstance.callMethod` 方法的回调
      },
      setState(status) {
        console.log(status);
      },
    },
  };
</script>
```

以上是视图层调用逻辑层方法，理论上逻辑层是不可用调用视图层方法，但是我们可以偷巧

比如我们可以自定义一个专门用来回调的变量`callbackfunction`

```html
<view :callbackfunction="callbackfunction"> </view>
```

在 index.wxs 中监听事件

```js
// 定义好被逻辑层触发的函数
function func1() {}
function func2() {}
function func3() {}

function callBackFunction(newValue, oldValue, ownerInstance, instance) {
  if (newValue === "func1") {
    func1();
    return;
  }
  if (newValue === "func2") {
    func2();
    return;
  }
  if (newValue === "func3") {
    func3();
    return;
  }
}
```

定义 index.wxs

```js
// 从基础库版本2.4.4开始，支持使用WXS函数绑定事件，WXS函数接受2个参数，第一个是event，在原有的event的基础上加了event.instance对象，第二个参数是ownerInstance，和event.instance一样是一个ComponentDescriptor对象。具体使用如下：
// wxs内部不支持es6语法，变量只能使用var定义，无法使用解构，箭头函数等特性

/**
  【重要】 编写wxs、sjs、filter.js 内容时必须遵循相应语法规范
  【重要】 module所指定的模块名不可与data、methods、computed内的属性重名
  vue3 项目不支持 setup script 用法
  目前各个小程序正在完善相关规范，可能会有较大改动，请务必仔细阅读相应平台的文档
  支付宝小程序请使用sjs规范，详见
  支付宝小程序sjs只能定义在.sjs 文件中，然后使用<script>标签引入
  支付宝小程序script的标签属性name、from被统一为了module、src以便后续实现多平台统一写法
  百度小程序中请使用Filter规范，详见
  百度小程序Filter只能导出function函数
  暂不支持在 wxs、sjs、filter.js 中调用其他同类型文件
  wxs、filter.js既能内联使用又可以外部引入，sjs只能外部引入
  QQ小程序目前对内联的 wxs 支持不好，部分写法可能会导致编译出错，尽量使用外部引入的方式
  在微信自定义组件中wxcomponents也可以使用wxs
  nvue页面暂不支持wxs、sjs、filter.js
  各个script标签会分别被打包至对应支持平台，不需要额外写条件编译
  自HBuilderX 2.2.5开始，不推荐使用各个小程序自有的引入方式，推荐使用script标签引入
 */

// 开始触摸
function touchstart(event, ownerInstance) {
  var instance = event.instance; // 触发事件的组件的ComponentDescriptor实例
  var state = instance.getState(); // wxs内的局部变量快照，此快照是属于整个组件的，在touchstart和touchmove事件中都能获取到相同的结果
  // 此处的state,也就是我们在.vue中的这些变量，在事件中是可以获取到的 ↓
  /*
  props:{
    // ......
  },
  data(){
    return {
      // ......
    }
  }
  */

  // .....
  ownerInstance.callMethod("closeOther"); // 调用视图层方法
}

function setStatus(status, instance, ownerInstance) {
  var state = instance.getState();
  state.status = status;
  ownerInstance.callMethod("setState", status); // 调用视图层方法
}

function sizeChange(newValue, oldValue, ownerInstance, instance) {}
function statusChange(newValue, oldValue, ownerInstance, instance) {}
```

renderjs

```html
<template>
  <view class="content">
    <!-- #ifdef APP-PLUS || H5 -->
    <view
      @click="echarts.onClick"
      :prop="option"
      :change:prop="echarts.updateEcharts"
      id="echarts"
      class="echarts"
    ></view>
    <button @click="changeOption">更新数据</button>
    <!-- #endif -->
    <!-- #ifndef APP-PLUS || H5 -->
    <view>非 APP、H5 环境不支持</view>
    <!-- #endif -->
  </view>
</template>

<script module="text" lang="renderjs">
   /**
   目前仅支持内联使用。
   不要直接引用大型类库，推荐通过动态创建 script 方式引用。
   可以使用 vue 组件的生命周期(不支持 beforeDestroy、destroyed、beforeUnmount、unmounted)，不可以使用 App、Page 的生命周期
   视图层和逻辑层通讯方式与 WXS 一致，另外可以通过 this.$ownerInstance 获取当前组件的 ComponentDescriptor 实例。
   注意逻辑层给数据时最好一次性给到渲染层，而不是不停从逻辑层向渲染层发消息，那样还是会产生逻辑层和视图层的多次通信，还是会卡
   观测更新的数据在视图层可以直接访问到。
   APP 端视图层的页面引用资源的路径相对于根目录计算，例如：./static/test.js。
   APP 端可以使用 dom、bom API，不可直接访问逻辑层数据，不可以使用 uni 相关接口（如：uni.request）
   H5 端逻辑层和视图层实际运行在同一个环境中，相当于使用 mixin 方式，可以直接访问逻辑层数据。
   */
  import echarts from "echarts";
  export default {
    data(){
      return {
        // ......
        myChart: null
      }
    },
  	mounted() {
      this.initEcharts()
  		// ...
  	},
  	methods: {
      initEcharts() {
        this.myChart = echarts.init(document.getElementById('echarts'))
        // 观测更新的数据在 view 层可以直接访问到
        this.myChart.setOption(this.option)
      },
      onClick(event, ownerInstance) {
        // 调用 service 层的方法
        ownerInstance.callMethod('onViewClick', {
          test: 'test'
        })
      }
  		// ...
  	}
  }
</script>

<script>
  export default {
    data() {
      return {
        option: {
          title: {
            text: "ECharts 入门示例",
          },
          tooltip: {},
          legend: {
            data: ["销量"],
          },
          xAxis: {
            data: ["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"],
          },
          yAxis: {},
          series: [
            {
              name: "销量",
              type: "bar",
              data: [5, 20, 36, 10, 10, 20],
            },
          ],
        },
      };
    },
    methods: {
      onViewClick(options) {
        // 被视图层回调的方法
        console.log(options);
      },
    },
  };
</script>
```

- 其实 renderjs 和 wxs 一样，都是运行在视图层，只不过 wxs 是微信规范，renderjs 是 App 规范
- 当需要在 renderjs 中调用逻辑层方法时，需要使用 this.$ownerInstance.callMethod()方法

* 官方的一个方法，但我并未尝试该写法，此处仅贴出出处，有兴趣的可以自行尝试
  [关于在 renderjs 父子组件通信的的实现](https://ask.dcloud.net.cn/article/40187)

* 与 wxs 一样，逻辑层不可用调用视图层方法，但是和之前 wxs 中偷巧方法一样，↓

```html
<template>
  <view class="content">
    <!-- #ifdef APP-PLUS || H5 -->
    <view :prop="callbackfunction" :change:prop="echarts.updateEcharts"></view>
  </view>
</template>

<script module="text" lang="renderjs">
  export default {
    watch: {
      callbackfunction(newValue, oldValue) {
        if (newValue === "func1") {
          this.func1();
        }
      }
    }
    methods: {
      func1() {}, //
    }
  }
</script>
<script>
  export default {
    data() {
      return {
        callbackfunction: "",
      };
    },
    methods: {
      onViewClick() {
        // 主动触发视图层方法
        this.callbackfunction = "func1";
      },
    },
  };
</script>
```

详细 demo，这里推荐 uni-ui 库的这个组件，写的很详细
[【uni-ui 组件库的 uni-swipe-action-item 组件】](https://github.com/dcloudio/uni-ui/blob/master/uni_modules/uni-swipe-action/components/uni-swipe-action-item/uni-swipe-action-item.vue)
