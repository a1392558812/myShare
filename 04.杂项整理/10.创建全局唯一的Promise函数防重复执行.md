# 创建全局唯一的 Promise 函数防重复执行

适用场景

1. 比如拦截到 401 请求，toast 弹窗展示 2000ms 后回退到首页，但多个请求同时发起，会触发多个 toast 弹窗，触发多次回退到首页
2. 比如在一个页面中，点击按钮发起请求，点击按钮后，再次点击按钮，会触发第二次请求，但第一次请求还没结束，第二次请求不应该发起，应该等待第一次请求结束后，再发起第二次请求
3. 比如在登录页面，点击登录按钮，登录成功后，跳转到首页，但登录请求还未结束，点击登录按钮，会触发两次登录请求，登录成功后，会跳转到两次首页

当然，我们也可以通过防抖函数来解决这个问题

```typescript
/**
 * 创建全局唯一的 Promise 函数（防重复执行）
 * 核心特性：
 * 1. 当存在 pending 状态的 Promise 时，重复调用直接返回该实例
 * 2. Promise  resolved/rejected 后，再次调用自动生成新实例
 * 3. 确保返回的是原始 Promise 实例，无二次包装
 *
 * @template T 异步操作的返回值类型
 * @template Args 异步函数的参数类型（支持任意参数列表）
 * @param {(...args: Args) => Promise<T>} asyncTask 实际要执行的异步任务
 * @returns {(...args: Args) => Promise<T>} 包装后的单例Promise函数
 */
const createUniquePromise = <T, Args extends any[] = any[]>(
  asyncTask: (...args: Args) => Promise<T>
): ((...args: Args) => Promise<T>) => {
  // 存储当前处于 pending 状态的 Promise 实例
  let pendingPromise: Promise<T> | null = null;

  // 返回包装后的函数，直接返回原始Promise实例
  return (...args: Args): Promise<T> => {
    // 1. 若已有pending状态的Promise，直接返回该实例
    if (pendingPromise) {
      console.log("[提示] 存在pending状态的Promise，直接返回已有实例");
      return pendingPromise;
    }

    // 2. 无pending状态时，创建新的Promise
    const newPromise = asyncTask(...args)
      .then((result) => {
        // 成功后重置pending状态，允许下次创建新实例
        pendingPromise = null;
        console.log("[状态] Promise已resolved，重置pending标记");
        return result; // 透传成功结果
      })
      .catch((error) => {
        // 失败后同样重置pending状态（避免后续调用被阻塞）
        pendingPromise = null;
        console.log("[状态] Promise已rejected，重置pending标记");
        throw error; // 透传错误，让调用方捕获
      });

    // 3. 将新Promise标记为pending状态，供后续调用复用
    pendingPromise = newPromise;
    console.log("[状态] 创建新的Promise实例，标记为pending");
    return newPromise;
  };
};

async function runTest() {
  const mockApiRequest = (requestId: string): Promise<string> => {
    return new Promise((resolve) => {
      console.log(`\n[异步任务] 开始执行请求（ID: ${requestId}）`);
      setTimeout(() => {
        resolve(`请求成功（ID: ${requestId}）`);
      }, 2000);
    });
  };

  // 2. 创建单例Promise函数
  const uniqueApiRequest = createUniquePromise(mockApiRequest);

  // 3. 第一次调用：创建新Promise
  console.log("\n=== 第一次调用 ===");
  const promise1 = uniqueApiRequest("req-001");

  // 4. 1秒后第二次调用：此时promise1仍pending，应返回同一实例
  setTimeout(async () => {
    console.log("\n=== 1秒后第二次调用（promise1仍pending）===");
    const promise2 = uniqueApiRequest("req-002");

    // 关键验证：两个Promise是否为同一实例（必须为true）
    console.log("promise1 === promise2 ?", promise1 === promise2); //  输出true

    // 监听结果：两个调用会同时拿到promise1的结果（忽略第二次的参数）
    const result1 = await promise1;
    const result2 = await promise2;
    console.log("promise1结果:", result1); // 输出"请求成功（ID: req-001）"
    console.log("promise2结果:", result2); // 输出"请求成功（ID: req-001）"
  }, 1000);

  // 5. 3秒后第三次调用：此时promise1已完成，应创建新Promise
  setTimeout(async () => {
    console.log("\n=== 3秒后第三次调用（promise1已完成）===");
    const promise3 = uniqueApiRequest("req-003");

    // 验证：promise3是新实例（与promise1不同）
    console.log("promise3 === promise1 ?", promise3 === promise1); // 输出false

    const result3 = await promise3;
    console.log("promise3结果:", result3); // 输出"请求成功（ID: req-003）"
  }, 3000);
}

runTest();
```
