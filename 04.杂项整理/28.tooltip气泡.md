# tooltip 组件

> 水文章，此处抽取的是[【wot-ui】](https://wot-ui.cn/component/tooltip.html)的 tooltip 组件。做了一些简化和把一些工具方法都提到一个文件里，方便复制

```html
<template>
  <view
    :id="nodeId.tooltip"
    class="custom-tooltip"
    :style="customStyle"
    @click.stop="noop"
  >
    <!-- 用于为渲染获取宽高的元素 -->
    <view
      :id="nodeId.pos"
      :style="computedTooltipPosStyle"
      class="custom-tooltip-pos custom-tooltip-hidden"
    >
      <view class="custom-tooltip-pos-container custom-pop">
        <view v-if="!useContentSlot" class="custom-tooltip-pos-container-inner">
          {{ content }}
        </view>
      </view>
    </view>
    <customTransition
      custom-class="custom-tooltip-transition"
      :custom-style="{
        ...computedTooltipPosStyle,
        ...popStyle,
      }"
      :show="showTooltip"
      name="fade"
      :duration="200"
    >
      <view class="custom-tooltip-pos-container custom-pop">
        <slot name="arrow">
          <view
            v-if="visibleArrow"
            class="custom-tooltip-arrow"
            :style="[arrowDirectionStyle, arrowStyle]"
          />
        </slot>
        <view v-if="!useContentSlot" class="custom-tooltip-pos-container-inner">
          {{ content }}
        </view>
        <slot v-else name="content" />
      </view>
    </customTransition>
    <view :id="nodeId.target" @click="toggle">
      <slot />
    </view>
  </view>
</template>

<script lang="ts" setup>
  import customTransition from "04.杂项整理 > 07.uniapp的自定义Transition过渡组件.md";
  import { isArray, isObject } from "03.杂项整理 > 14.类型保护工具函数.md";
  import {
    computed,
    getCurrentInstance,
    onBeforeMount,
    onBeforeUnmount,
    onMounted,
    reactive,
    ref,
    watch,
  } from "vue";

  export type RectResultType<T extends boolean> = T extends true
    ? UniApp.NodeInfo[]
    : UniApp.NodeInfo;

  export type PlacementType =
    | "top"
    | "top-start"
    | "top-end"
    | "bottom"
    | "bottom-start"
    | "bottom-end"
    | "left"
    | "left-start"
    | "left-end"
    | "right"
    | "right-start"
    | "right-end";

  export type OffsetType = number | number[] | Record<"x" | "y", number>;

  export interface TransitionPropsType {
    customPop?: string;
    visibleArrow?: boolean;
    content?: string | AnyObject[];
    placement?: PlacementType;
    offset?: OffsetType;
    useContentSlot?: boolean;
    disabled?: boolean;
    modelValue?: boolean;
    customStyle?: AnyObject;
    customTooltipPosStyle?: AnyObject;
  }

  defineOptions({
    addGlobalClass: true,
    virtualHost: true,
    styleIsolation: "shared",
  });

  const props = withDefaults(defineProps<TransitionPropsType>(), {
    customPop: "",
    visibleArrow: true,
    content: "",
    placement: "bottom",
    offset: 0,
    useContentSlot: false,
    disabled: false,
    modelValue: false,
    customStyle: () => ({}),
    customTooltipPosStyle: () => ({}),
  });

  const emit = defineEmits([
    "update:modelValue",
    "menuclick",
    "change",
    "open",
    "close",
  ]);

  /**
   * 获取节点信息
   * @param selector 节点选择器 #id,.class
   * @param all 是否返回所有 selector 对应的节点
   * @param scope 作用域（支付宝小程序无效）
   * @param useFields 是否使用 fields 方法获取节点信息
   * @returns 节点信息或节点信息数组
   */
  const getRect = <T extends boolean>(
    selector: string,
    all: T,
    scope?: any,
    useFields?: boolean
  ): Promise<RectResultType<T>> => {
    return new Promise<RectResultType<T>>((resolve, reject) => {
      let query: UniNamespace.SelectorQuery | null = null;
      if (scope) {
        query = uni.createSelectorQuery().in(scope);
      } else {
        query = uni.createSelectorQuery();
      }

      const method = all ? "selectAll" : "select";

      const callback = (rect: UniApp.NodeInfo | UniApp.NodeInfo[]) => {
        if (all && isArray(rect) && rect.length > 0) {
          resolve(rect as RectResultType<T>);
        } else if (!all && rect) {
          resolve(rect as RectResultType<T>);
        } else {
          reject(new Error("No nodes found"));
        }
      };

      if (useFields) {
        query[method](selector)
          .fields({ size: true, node: true }, callback)
          .exec();
      } else {
        query[method](selector).boundingClientRect(callback).exec();
      }
    });
  };

  const getRandomInt = (min: number = 0, max: number = 10): number => {
    const realMin = Math.min(min, max);
    const realMax = Math.max(min, max);
    return Math.floor(Math.random() * (realMax - realMin + 1)) + realMin;
  };

  const uuid = `${getRandomInt()}${getRandomInt()}${getRandomInt()}${getRandomInt()}${getRandomInt()}${new Date().getTime()}`;

  const nodeId = reactive({
    tooltip: `tooltip${uuid}`,
    pos: `pos${uuid}`,
    target: `target${uuid}`,
  });

  const { proxy } = getCurrentInstance() as any;
  const popStyle = ref<AnyObject>({});
  const arrowStyle = ref<AnyObject>({});
  const showStyle = ref<string>("");
  const popWidth = ref<number>(0);
  const popHeight = ref<number>(0);
  const left = ref<number>(0);
  const bottom = ref<number>(0);
  const width = ref<number>(0);
  const height = ref<number>(0);
  const top = ref<number>(0);

  const selector: string = "tooltip";
  const showTooltip = ref<boolean>(false); // 控制tooltip显隐

  const computedTooltipPosStyle = computed<AnyStyleType>(() => {
    return {
      position: "absolute",
      minWidth: "138px",
      minHeight: "36px",
      fontSize: "14px",
      backdropFilter: "10px",
      backgroundClip: "padding-box",
      borderRadius: "6px",
      background: "rgba(38, 39, 40, .8)",
      color: "rgb(255, 255, 255)",
      textAlign: "center",
      boxSizing: "border-box",
      zIndex: "500",
      ...props.customTooltipPosStyle,
    };
  });

  const arrowDirectionStyle = computed(() => {
    if (props.visibleArrow) {
      if (
        props.placement === "bottom" ||
        props.placement === "bottom-start" ||
        props.placement === "bottom-end"
      ) {
        return {
          borderLeft: `5px solid transparent`,
          borderRight: `5px solid transparent`,
          borderBottom: `5px solid rgba(38, 39, 40, .8)`,
          "-webkit-transform": `translateX(-50%)`,
          transform: `translate(-50%)`,
          top: `calc(-1 * 5px)`,
        };
      }
      if (
        props.placement === "left" ||
        props.placement === "left-start" ||
        props.placement === "left-end"
      ) {
        return {
          borderTop: `5px solid transparent`,
          borderBottom: `5px solid transparent`,
          borderLeft: `5px solid rgba(38, 39, 40, .8)`,
          "-webkit-transform": `translateY(-50%)`,
          transform: `translateY(-50%)`,
          right: `calc(-1 * 5px)`,
        };
      }
      if (
        props.placement === "right" ||
        props.placement === "right-start" ||
        props.placement === "right-end"
      ) {
        return {
          borderTop: `5px solid transparent`,
          borderBottom: `5px solid transparent`,
          borderRight: `5px solid rgba(38, 39, 40, .8)`,
          "-webkit-transform": `translateY(-50%)`,
          transform: `translateY(-50%)`,
          left: `calc(-1 * 5px)`,
        };
      }
      if (
        props.placement === "top" ||
        props.placement === "top-start" ||
        props.placement === "top-end"
      ) {
        return {
          borderLeft: `5px solid transparent`,
          borderRight: `5px solid transparent`,
          borderTop: `5px solid rgba(38, 39, 40, .8)`,
          "-webkit-transform": `translateX(-50%)`,
          transform: `translate(-50%)`,
          bottom: `calc(-1 * 5px)`,
        };
      }
      return {};
    }

    return {};
  });

  const noop = () => {};

  const init = () => {
    // 初始化数据获取
    getRect(`#${nodeId.target}`, false, proxy).then((rect) => {
      if (!rect) return;
      left.value = rect.left as number;
      bottom.value = rect.bottom as number;
      width.value = rect.width as number;
      height.value = rect.height as number;
      top.value = rect.top as number;
    });
    // 用透明度可在初始化时获取到pop尺寸
    getRect(`#${nodeId.pos}`, false, proxy).then((rect) => {
      if (!rect) return;
      popWidth.value = rect.width as number;
      popHeight.value = rect.height as number;
    });
  };

  const control = (
    placement:
      | "top"
      | "top-start"
      | "top-end"
      | "bottom"
      | "bottom-start"
      | "bottom-end"
      | "left"
      | "left-start"
      | "left-end"
      | "right"
      | "right-start"
      | "right-end",
    offset: OffsetType
  ) => {
    // arrow size
    const arrowSize = props.visibleArrow ? 9 : 0;
    // 上下位（纵轴）对应的距离左边的距离
    const verticalX = width.value / 2;
    // 上下位（纵轴）对应的距离底部的距离
    const verticalY = arrowSize + height.value + 5;
    // 左右位（横轴）对应的距离左边的距离
    const horizontalX = width.value + arrowSize + 5;
    // 左右位（横轴）对应的距离底部的距离
    const horizontalY = height.value / 2;

    let offsetX = 0;
    let offsetY = 0;
    if (Array.isArray(offset)) {
      offsetX = (verticalX - 17 > 0 ? 0 : verticalX - 25) + offset[0];
      offsetY =
        (horizontalY - 17 > 0 ? 0 : horizontalY - 25) +
        (offset[1] ? offset[1] : offset[0]);
    } else if (isObject(offset)) {
      offsetX = (verticalX - 17 > 0 ? 0 : verticalX - 25) + offset.x;
      offsetY = (horizontalY - 17 > 0 ? 0 : horizontalY - 25) + offset.y;
    } else {
      offsetX = (verticalX - 17 > 0 ? 0 : verticalX - 25) + offset;
      offsetY = (horizontalY - 17 > 0 ? 0 : horizontalY - 25) + offset;
    }
    // const offsetX = (verticalX - 17 > 0 ? 0 : verticalX - 25) + offset
    // const offsetY = (horizontalY - 17 > 0 ? 0 : horizontalY - 25) + offset

    const placements = new Map([
      [
        "top",
        [
          {
            left: `${verticalX}px`,
            bottom: `${verticalY}px`,
            transform: "translateX(-50%)",
          },
          {
            left: "50%",
          },
        ],
      ],
      [
        "top-start",
        [
          {
            left: `${offsetX}px`,
            bottom: `${verticalY}px`,
          },
          {
            left: `${
              (popWidth.value >= width.value
                ? width.value / 2
                : popWidth.value - 25) - offsetX
            }px`,
          },
        ],
      ],
      [
        "top-end",
        [
          {
            right: `${offsetX}px`,
            bottom: `${verticalY}px`,
          },
          {
            right: `${
              (popWidth.value >= width.value
                ? width.value / 2
                : popWidth.value - 25) - offsetX
            }px`,
            transform: "translateX(50%)",
          },
        ],
      ],
      [
        "bottom",
        [
          {
            left: `${verticalX}px`,
            top: `${verticalY}px`,
            transform: `translateX(-50 %)`,
          },
          {
            left: "50%",
          },
        ],
      ],
      [
        "bottom-start",
        [
          {
            left: `${offsetX}px`,
            top: `${verticalY}px`,
          },
          {
            left: `${
              (popWidth.value >= width.value
                ? width.value / 2
                : popWidth.value - 25) - offsetX
            }px`,
          },
        ],
      ],
      [
        "bottom-end",
        [
          {
            right: `${offsetX}px`,
            top: `${verticalY}px`,
          },
          {
            right: `${
              (popWidth.value >= width.value
                ? width.value / 2
                : popWidth.value - 25) - offsetX
            }px`,
            transform: "translateX(50%)",
          },
        ],
      ],
      [
        "left",
        [
          {
            right: `${horizontalX}px`,
            top: `${horizontalY}px`,
            transform: `translateY(-50%)`,
          },
          {
            top: "50%",
          },
        ],
      ],
      [
        "left-start",
        [
          {
            right: `${horizontalX}px`,
            top: `${offsetY}px`,
          },
          {
            top: `${
              (popHeight.value >= height.value
                ? height.value / 2
                : popHeight.value - 20) - offsetY
            }px`,
          },
        ],
      ],
      [
        "left-end",
        [
          {
            right: `${horizontalX}px`,
            bottom: `${offsetY}px`,
          },
          {
            bottom: `${
              (popHeight.value >= height.value
                ? height.value / 2
                : popHeight.value - 20) - offsetY
            }px`,
            transform: `translateY(50%)`,
          },
        ],
      ],
      [
        "right",
        [
          {
            left: `${horizontalX}px`,
            top: `${horizontalY}px`,
            transform: `translateY(-50%)`,
          },
          {
            top: "50%",
          },
        ],
      ],
      [
        "right-start",
        [
          {
            left: `${horizontalX}px`,
            top: `${offsetY}px`,
          },
          {
            top: `${
              (popHeight.value >= height.value
                ? height.value / 2
                : popHeight.value - 20) - offsetY
            }px`,
          },
        ],
      ],
      [
        "right-end",
        [
          {
            left: `${horizontalX}px`,
            bottom: `${offsetY}px`,
          },
          {
            bottom: `${
              (popHeight.value >= height.value
                ? height.value / 2
                : popHeight.value - 20) - offsetY
            }px`,
            transform: "translateY(50%)",
          },
        ],
      ],
    ]);
    popStyle.value = placements.get(placement)![0];
    arrowStyle.value = placements.get(placement)![1];
  };

  const updateModelValue = (value: boolean) => {
    showTooltip.value = value;
    emit("update:modelValue", value);
  };

  const toggle = () => {
    if (props.disabled) return;
    updateModelValue(!showTooltip.value);
  };

  const open = () => {
    updateModelValue(true);
  };

  const close = () => {
    updateModelValue(false);
  };

  watch(
    () => props.content,
    (newVal) => {
      if (newVal === null || newVal === undefined) {
        console.error("props.content不能为空");
      }
    }
  );

  watch(
    () => props.placement,
    () => {
      init();
    }
  );

  watch(
    () => props.modelValue,
    (newValue) => {
      showTooltip.value = newValue;
    }
  );

  watch(
    () => showTooltip.value,
    (newValue) => {
      if (newValue) {
        control(props.placement, props.offset);
      }
      showStyle.value = newValue ? "display: inline-block;" : "display: none;";
      emit("change", { show: newValue });
      emit(`${newValue ? "open" : "close"}`);
    }
  );

  onMounted(() => {
    init();
  });

  onBeforeMount(() => {
    showStyle.value = props.modelValue ? "opacity: 1;" : "opacity: 0;";
  });

  defineExpose({
    open,
    close,
  });
</script>

<style lang="scss" scoped>
  .custom-tooltip {
    position: relative;
    display: inline-block;
    .custom-tooltip-hidden {
      left: -100vw;
      bottom: -100vh;
      visibility: hidden;
    }
    .custom-tooltip-pos-container {
      line-height: 18px;
      font-size: 14px;

      .custom-tooltip-pos-container-inner {
        padding: 9px 20px;
        white-space: nowrap;
        line-height: 18px;
        z-index: 0;
      }
    }
    .custom-tooltip-arrow {
      position: absolute;
      width: 0;
      height: 0;
    }
  }
</style>
```
