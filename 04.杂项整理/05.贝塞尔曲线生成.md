# 贝塞尔曲线生成

<vue3-sfc>
<vue3-file name="App.vue">
<template>
  <div class="min-h-screen bg-gradient-to-br from-gray-900 to-gray-800 text-white flex flex-col">
    <header class="py-6 px-4 md:px-8 text-center">
      <h1
        class="text-[clamp(1.8rem,4vw,2.8rem)] font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-500 mb-2">
        贝塞尔曲线运动演示
      </h1>
      <p class="text-gray-400 max-w-2xl mx-auto">
        调整控制点参数来修改贝塞尔曲线，观察小球的运动轨迹变化。贝塞尔曲线是计算机图形学中常用的曲线，广泛应用于动画过渡效果。
      </p>
    </header>

    <main
      class="flex-1 flex flex-col md:flex-row items-center justify-center gap-8 p-4 md:p-8 w-full max-w-7xl mx-auto">
      <div
        class="relative w-full md:w-2/3 h-[400px] bg-gray-800/50 rounded-xl border border-gray-700 shadow-xl overflow-hidden">
        <canvas ref="bezierCanvas" class="absolute inset-0 w-full h-full"></canvas>

        <!-- 运动的小球 -->
        <div ref="ball"
          class="absolute w-6 h-6 bg-gradient-to-r from-blue-400 to-purple-500 rounded-full shadow-lg transform -translate-x-1/2 -translate-y-1/2 transition-none"
          :style="{ left: `${ballPosition.x}px`, top: `${ballPosition.y}px` }"></div>

        <!-- 轨迹点标记 -->
        <template v-for="(point, index) in trajectoryPoints" :key="index">
          <div class="absolute w-1.5 h-1.5 bg-blue-300/30 rounded-full"
            :style="{ left: `${point.x}px`, top: `${point.y}px` }"></div>
        </template>

        <!-- 控制点 -->
        <div ref="startPoint"
          class="absolute w-4 h-4 bg-green-400 rounded-full cursor-move shadow-md transform -translate-x-1/2 -translate-y-1/2"
          :style="{ left: `${startPointCoords.x}px`, top: `${startPointCoords.y}px` }"
          @mousedown="startDragging('startPoint', $event)">
        </div>

        <div ref="controlPoint1"
          class="absolute w-4 h-4 bg-yellow-400 rounded-full cursor-move shadow-md transform -translate-x-1/2 -translate-y-1/2"
          :style="{ left: `${controlPoint1Coords.x}px`, top: `${controlPoint1Coords.y}px` }"
          @mousedown="startDragging('controlPoint1', $event)"></div>

        <div ref="controlPoint2"
          class="absolute w-4 h-4 bg-yellow-400 rounded-full cursor-move shadow-md transform -translate-x-1/2 -translate-y-1/2"
          :style="{ left: `${controlPoint2Coords.x}px`, top: `${controlPoint2Coords.y}px` }"
          @mousedown="startDragging('controlPoint2', $event)"></div>

        <div ref="endPoint"
          class="absolute w-4 h-4 bg-red-400 rounded-full cursor-move shadow-md transform -translate-x-1/2 -translate-y-1/2"
          :style="{ left: `${endPointCoords.x}px`, top: `${endPointCoords.y}px` }"
          @mousedown="startDragging('endPoint', $event)">
        </div>

        <!-- 控制线段 -->
        <svg class="absolute inset-0 w-full h-full pointer-events-none">
          <line :x1="startPointCoords.x" :y1="startPointCoords.y" :x2="controlPoint1Coords.x"
            :y2="controlPoint1Coords.y" stroke="rgba(234, 179, 8, 0.3)" stroke-width="1.5" stroke-dasharray="4" />
          <line :x1="controlPoint2Coords.x" :y1="controlPoint2Coords.y" :x2="endPointCoords.x" :y2="endPointCoords.y"
            stroke="rgba(234, 179, 8, 0.3)" stroke-width="1.5" stroke-dasharray="4" />
        </svg>

        <div
          class="absolute bottom-4 left-1/2 transform -translate-x-1/2 flex gap-3 bg-gray-900/80 px-4 py-2 rounded-full backdrop-blur-sm border border-gray-700">
          <button @click="toggleAnimation"
            class="flex items-center justify-center text-[#fff] bg-gray-700 hover:bg-gray-600 transition-colors"
            :title="isAnimating ? '暂停动画' : '开始动画'">
            {{ isAnimating ? '暂停动画' : '开始动画' }}
          </button>
          <button @click="resetAnimation"
            class="flex items-center justify-center text-[#fff] bg-gray-700 hover:bg-gray-600 transition-colors"
            title="重置动画">
            重置动画
          </button>
          <button @click="clearTrajectory"
            class="flex items-center justify-center text-[#fff] bg-gray-700 hover:bg-gray-600 transition-colors"
            title="清除轨迹">
            清除轨迹
          </button>
        </div>
      </div>

      <div class="w-full md:w-1/3 space-y-6 bg-gray-800/50 rounded-xl border border-gray-700 shadow-xl p-6">
        <h2 class="text-xl font-semibold mb-4 pb-2 border-b border-gray-700">曲线参数控制</h2>

        <div class="space-y-4">
          <h3 class="text-sm font-medium text-gray-300">控制点 1 (黄色)</h3>
          <div class="space-y-3">
            <div>
              <div class="flex justify-between mb-1">
                <label class="text-xs text-gray-400">X: {{ controlPoint1Coords.x }}</label>
                <span class="text-xs text-gray-500">{{ Math.round((controlPoint1Coords.x / canvasWidth) * 100)
                }}%</span>
              </div>
              <input type="range" min="0" :max="canvasWidth" v-model.number="controlPoint1Coords.x"
                class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-yellow-500"
                @input="redrawCurve">
            </div>
            <div>
              <div class="flex justify-between mb-1">
                <label class="text-xs text-gray-400">Y: {{ controlPoint1Coords.y }}</label>
                <span class="text-xs text-gray-500">{{ Math.round((controlPoint1Coords.y / canvasHeight) * 100)
                }}%</span>
              </div>
              <input type="range" min="0" :max="canvasHeight" v-model.number="controlPoint1Coords.y"
                class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-yellow-500"
                @input="redrawCurve">
            </div>
          </div>
        </div>

        <div class="space-y-4">
          <h3 class="text-sm font-medium text-gray-300">控制点 2 (黄色)</h3>
          <div class="space-y-3">
            <div>
              <div class="flex justify-between mb-1">
                <label class="text-xs text-gray-400">X: {{ controlPoint2Coords.x }}</label>
                <span class="text-xs text-gray-500">{{ Math.round((controlPoint2Coords.x / canvasWidth) * 100)
                }}%</span>
              </div>
              <input type="range" min="0" :max="canvasWidth" v-model.number="controlPoint2Coords.x"
                class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-yellow-500"
                @input="redrawCurve">
            </div>
            <div>
              <div class="flex justify-between mb-1">
                <label class="text-xs text-gray-400">Y: {{ controlPoint2Coords.y }}</label>
                <span class="text-xs text-gray-500">{{ Math.round((controlPoint2Coords.y / canvasHeight) * 100)
                }}%</span>
              </div>
              <input type="range" min="0" :max="canvasHeight" v-model.number="controlPoint2Coords.y"
                class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-yellow-500"
                @input="redrawCurve">
            </div>
          </div>
        </div>

        <div class="space-y-4 pt-2">
          <h3 class="text-sm font-medium text-gray-300">动画参数</h3>
          <div class="space-y-3">
            <div>
              <div class="flex justify-between mb-1">
                <label class="text-xs text-gray-400">持续时间: {{ duration }}ms</label>
              </div>
              <input type="range" min="500" max="5000" step="100" v-model.number="duration"
                class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-blue-500">
            </div>
            <div>
              <div class="flex justify-between mb-1">
                <label class="text-xs text-gray-400">轨迹点数量: {{ trajectoryDensity }}</label>
              </div>
              <input type="range" min="10" max="100" step="5" v-model.number="trajectoryDensity"
                class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-blue-500"
                @input="redrawCurve">
            </div>
          </div>
        </div>

        <div class="p-3 bg-gray-900/60 rounded-lg border border-gray-700 text-sm font-mono overflow-x-auto">
          <p class="text-gray-400 mb-1">三次贝塞尔曲线公式:</p>
          <p class="text-blue-400">B(t) = P₀(1-t)³ + 3P₁t(1-t)² + 3P₂t²(1-t) + P₃t³</p>
          <p class="text-gray-500 text-xs mt-2">t ∈ [0, 1]</p>
        </div>
      </div>
    </main>

    <footer class="py-4 px-4 text-center text-gray-500 text-sm">
      <p>拖动控制点或使用滑块调整贝塞尔曲线参数 | 绿色: 起点 | 红色: 终点 | 黄色: 控制点</p>
    </footer>

  </div>
</template>

<script setup>
import { ref, onMounted, onUnmounted, watch } from 'vue';

// 画布和动画相关的引用
const bezierCanvas = ref();
const ball = ref();
const startPoint = ref();
const controlPoint1 = ref();
const controlPoint2 = ref();
const endPoint = ref();

// 画布尺寸
const canvasWidth = ref(0);
const canvasHeight = ref(0);

// 贝塞尔曲线控制点坐标
const startPointCoords = ref({ x: 50, y: 200 });
const controlPoint1Coords = ref({ x: 150, y: 50 });
const controlPoint2Coords = ref({ x: 300, y: 350 });
const endPointCoords = ref({ x: 450, y: 200 });

// 小球位置
const ballPosition = ref({ x: startPointCoords.value.x, y: startPointCoords.value.y });

// 动画状态
const isAnimating = ref(false);
const animationProgress = ref(0);
const animationFrameId = ref(null);
const duration = ref(2000); // 动画持续时间(ms)
const startTime = ref(0);

// 轨迹相关
const trajectoryPoints = ref([]);
const trajectoryDensity = ref(30); // 轨迹点数量

// 拖动状态
const isDragging = ref(false);
const draggedPoint = ref('');

// 在动画状态中添加一个变量保存暂停时的进度
const pausedProgress = ref(0);

// 计算三次贝塞尔曲线上的点
const calculateBezierPoint = (t) => {
  const { x: x0, y: y0 } = startPointCoords.value;
  const { x: x1, y: y1 } = controlPoint1Coords.value;
  const { x: x2, y: y2 } = controlPoint2Coords.value;
  const { x: x3, y: y3 } = endPointCoords.value;

  const cx = 3 * (x1 - x0);
  const bx = 3 * (x2 - x1) - cx;
  const ax = x3 - x0 - cx - bx;

  const cy = 3 * (y1 - y0);
  const by = 3 * (y2 - y1) - cy;
  const ay = y3 - y0 - cy - by;

  const x = ax * t * t * t + bx * t * t + cx * t + x0;
  const y = ay * t * t * t + by * t * t + cy * t + y0;

  return { x, y };
};

const drawBezierCurve = () => {
  if (!bezierCanvas.value) return;

  const ctx = bezierCanvas.value.getContext('2d');
  if (!ctx) return;

  ctx.clearRect(0, 0, canvasWidth.value, canvasHeight.value);

  ctx.beginPath();
  ctx.moveTo(startPointCoords.value.x, startPointCoords.value.y);
  ctx.bezierCurveTo(
    controlPoint1Coords.value.x, controlPoint1Coords.value.y,
    controlPoint2Coords.value.x, controlPoint2Coords.value.y,
    endPointCoords.value.x, endPointCoords.value.y
  );

  ctx.strokeStyle = 'rgba(96, 165, 250, 0.7)';
  ctx.lineWidth = 2;
  ctx.stroke();

  drawTrajectoryPoints(ctx);
};

const drawTrajectoryPoints = (ctx) => {
  trajectoryPoints.value = [];

  for (let i = 0; i <= trajectoryDensity.value; i++) {
    const t = i / trajectoryDensity.value;
    const point = calculateBezierPoint(t);
    trajectoryPoints.value.push(point);

    ctx.beginPath();
    ctx.arc(point.x, point.y, 1.5, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(96, 165, 250, 0.3)';
    ctx.fill();
  }
};

const redrawCurve = () => {
  drawBezierCurve();
};

const animate = (timestamp) => {
  if (!isAnimating.value) return;

  if (!startTime.value) startTime.value = timestamp;
  const elapsed = timestamp - startTime.value;
  animationProgress.value = Math.min(elapsed / duration.value, 1);

  // 计算当前小球位置
  const point = calculateBezierPoint(animationProgress.value);
  ballPosition.value = point;

  // 继续动画或结束
  if (animationProgress.value < 1) {
    animationFrameId.value = requestAnimationFrame(animate);
  } else {
    isAnimating.value = false;
    startTime.value = 0;
    pausedProgress.value = 0;
  }
};

// 切换动画状态
const toggleAnimation = () => {
  if (isAnimating.value) {
    // 暂停动画
    isAnimating.value = false;
    pausedProgress.value = animationProgress.value; // 保存当前进度
    if (animationFrameId.value) {
      cancelAnimationFrame(animationFrameId.value);
    }
  } else {
    // 开始或恢复动画
    isAnimating.value = true;
    // 如果是从头开始（进度为0），则设置新的开始时间
    if (pausedProgress.value === 0 || animationProgress.value >= 1) {
      startTime.value = performance.now();
      animationProgress.value = 0;
    } else {
      // 从暂停处恢复
      startTime.value = performance.now() - (pausedProgress.value * duration.value);
    }
    animationFrameId.value = requestAnimationFrame(animate);
  }
};

const resetAnimation = () => {
  if (animationFrameId.value) {
    cancelAnimationFrame(animationFrameId.value);
  }
  isAnimating.value = false;
  animationProgress.value = 0;
  pausedProgress.value = 0; // 重置暂停进度
  startTime.value = 0;
  ballPosition.value = { ...startPointCoords.value };
};

const clearTrajectory = () => {
  trajectoryPoints.value = [];
  drawBezierCurve();
};

const startDragging = (point, event) => {
  event.preventDefault();
  isDragging.value = true;
  draggedPoint.value = point;

  const handleMouseMove = (e) => {
    if (!isDragging.value || !bezierCanvas.value) return;

    const rect = bezierCanvas.value.getBoundingClientRect();

    let x = e.clientX - rect.left;
    let y = e.clientY - rect.top;

    // 限制在画布范围内
    x = Math.max(0, Math.min(x, canvasWidth.value));
    y = Math.max(0, Math.min(y, canvasHeight.value));

    if (point === 'startPoint') {
      startPointCoords.value = { x, y };
    } else if (point === 'controlPoint1') {
      controlPoint1Coords.value = { x, y };
    } else if (point === 'controlPoint2') {
      controlPoint2Coords.value = { x, y };
    } else if (point === 'endPoint') {
      endPointCoords.value = { x, y };
    }

    drawBezierCurve();
  };

  const handleMouseUp = () => {
    isDragging.value = false;
    document.removeEventListener('mousemove', handleMouseMove);
    document.removeEventListener('mouseup', handleMouseUp);
  };

  document.addEventListener('mousemove', handleMouseMove);
  document.addEventListener('mouseup', handleMouseUp);
};

onMounted(() => {
  if (bezierCanvas.value) {
    const updateCanvasSize = () => {
      if (bezierCanvas.value) {
        const parent = bezierCanvas.value.parentElement;
        if (parent) {
          canvasWidth.value = parent.clientWidth;
          canvasHeight.value = parent.clientHeight;

          bezierCanvas.value.width = canvasWidth.value;
          bezierCanvas.value.height = canvasHeight.value;

          // 如果是第一次加载，调整点的位置以适应画布
          if (startPointCoords.value.x === 50) {
            startPointCoords.value = { x: canvasWidth.value * 0.1, y: canvasHeight.value * 0.5 };
            controlPoint1Coords.value = { x: canvasWidth.value * 0.3, y: canvasHeight.value * 0.2 };
            controlPoint2Coords.value = { x: canvasWidth.value * 0.7, y: canvasHeight.value * 0.8 };
            endPointCoords.value = { x: canvasWidth.value * 0.9, y: canvasHeight.value * 0.5 };
            ballPosition.value = { ...startPointCoords.value };
          }

          drawBezierCurve();
        }
      }
    };

    updateCanvasSize();

    window.addEventListener('resize', updateCanvasSize);

    onUnmounted(() => {
      window.removeEventListener('resize', updateCanvasSize);
      if (animationFrameId.value) {
        cancelAnimationFrame(animationFrameId.value);
      }
    });
  }
});

// 监听控制点变化，重绘曲线
watch([controlPoint1Coords, controlPoint2Coords, startPointCoords, endPointCoords], () => {
  drawBezierCurve();
});

onUnmounted(() => {
  if (animationFrameId.value) {
    cancelAnimationFrame(animationFrameId.value);
  }
});
</script>

<style>
html,
body {
  min-width: 1200px;
}

#app,
#page {
  height: 100%;
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  cursor: pointer;
}

input[type="range"].accent-yellow-500::-webkit-slider-thumb {
  background: #facc15;
}

input[type="range"].accent-blue-500::-webkit-slider-thumb {
  background: #60a5fa;
}

/* 动画效果 */
.ball-animation {
  transition: transform 0.1s linear;
}
</style>

</vue3-file>
</vue3-sfc>
