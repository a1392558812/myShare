# components-tools

> @/utils/components-tools.ts ---> 04.杂项整理/35.components-tools.md
> @/utils/type-check.ts ---> 03.杂项整理/14.类型保护工具函数.md

```typescript
import type { ComponentInternalInstance } from "vue";
import { isArray } from "@/utils/type-check";

/**
 * 获取节点信息
 * @param selector 节点选择器 #id,.class
 * @param all 是否返回所有 selector 对应的节点
 * @param scope 作用域（支付宝小程序无效）
 * @param useFields 是否使用 fields 方法获取节点信息
 * @returns 节点信息或节点信息数组
 */

export type RectResultType<T extends boolean> = T extends true
  ? UniApp.NodeInfo[]
  : UniApp.NodeInfo;
export const getRect = <T extends boolean>(
  selector: string,
  all: T,
  scope?: any,
  useFields?: boolean,
): Promise<RectResultType<T>> => {
  return new Promise<RectResultType<T>>((resolve, reject) => {
    let query: UniNamespace.SelectorQuery | null = null;
    if (scope) {
      query = uni.createSelectorQuery().in(scope);
    } else {
      query = uni.createSelectorQuery();
    }

    const method = all ? "selectAll" : "select";

    const callback = (rect: UniApp.NodeInfo | UniApp.NodeInfo[]) => {
      if (all && isArray(rect) && rect.length > 0) {
        resolve(rect as RectResultType<T>);
      } else if (!all && rect) {
        resolve(rect as RectResultType<T>);
      } else {
        reject(new Error("No nodes found"));
      }
    };

    if (useFields) {
      query[method](selector)
        .fields({ size: true, node: true }, callback)
        .exec();
    } else {
      query[method](selector).boundingClientRect(callback).exec();
    }
  });
};

export const getUuid = (componentName: string = ""): string => {
  const s4 = () =>
    Math.floor((1 + Math.random()) * 0x10000)
      .toString(16)
      .substring(1);
  return `${componentName}${s4()}${s4()}${s4()}${s4()}${s4()}${s4()}${s4()}${s4()}`;
};

export const sleep = (ms: number) => {
  return new Promise((resolve) => setTimeout(resolve, ms));
};

export const getParent = (
  name: string,
  parent: ComponentInternalInstance["proxy"] | undefined,
) => {
  let target = parent!.$parent;
  // 通过while历遍，这里主要是为了H5需要多层解析的问题
  while (target) {
    // 父组件
    if (target.$options && target.$options.name !== name) {
      // 如果组件的name不相等，继续上一级寻找
      target = target!.$parent;
    } else {
      return target;
    }
  }
  return false;
};

// #ifdef APP-NVUE
const dom = uni.requireNativePlugin("dom");
// #endif

// queryRect是getRect的进阶版本，用于nvue下查询元素高度
export const queryRect = (
  selector: string,
  instance: ComponentInternalInstance | null,
  targetRef: any,
): Promise<UniApp.NodeInfo> => {
  // #ifndef APP-NVUE
  return new Promise((resolve, reject) => {
    getRect(selector, false, instance?.proxy)
      .then((size) => {
        resolve(size);
      })
      .catch((error) => {
        reject(error);
      });
  });
  // #endif

  // #ifdef APP-NVUE
  // nvue下，使用dom模块查询元素高度
  // 返回一个promise，让调用此方法的主体能使用then回调
  return new Promise((resolve) => {
    dom.getComponentRect(targetRef, (res: { size: UniApp.NodeInfo }) => {
      resolve(res.size);
    });
  });
  // #endif
};
```
