## will-change

> [CSS](https://developer.mozilla.org/zh-CN/docs/Web/CSS) 属性 `will-change` 为web开发者提供了一种告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作。 这种优化可以将一部分复杂的计算工作提前准备好，使页面的反应更为快速灵敏。
>
> 1. **不要将 will-change 应用到太多元素上**(只给即将开启动画的元素添加)
> 2. **有节制地使用**(will-change告诉浏览器，目标元素可能会经常变化，浏览器会将优化工作保存得比之前更久，最佳实践是当元素变化之前和之后通过脚本来切换 `will-change` 的值，即我们需要使用js来动态的控制will-change的添加)
> 3. **不要过早应用 will-change 优化**（will-change是我们最后的优化手段，而不是首选）
> 4. **给它足够的工作时间**

```js
var el = document.getElementById('element');
// 当鼠标移动到该元素上时给该元素设置 will-change 属性
el.addEventListener('mouseenter', hintBrowser);
// 当 CSS 动画结束后清除 will-change 属性
el.addEventListener('animationEnd', removeHint);
function hintBrowser() {
  // 填写上那些你知道的，会在 CSS 动画中发生改变的 CSS 属性名们
  this.style.willChange = 'transform, opacity';
}
function removeHint() {
  this.style.willChange = 'auto';
}
```

## Vue.observable( object )

> 让一个对象可响应。Vue 内部会用它来处理 `data` 函数返回的对象。返回的对象可以直接用于[渲染函数](https://cn.vuejs.org/v2/guide/render-function.html)和[计算属性](https://cn.vuejs.org/v2/guide/computed.html)内，并且会在发生变更时触发相应的更新。也可以作为最小化的跨组件状态存储器，用于简单的场景：

```vue
const state = Vue.observable({ count: 0 })
const Demo = {
  render(h) {
    return h('button', {
      on: { click: () => { state.count++ }}
    }, `count is: ${state.count}`)
  }
}
```

> 如果该state可以通过.操作符来进行读写，那数据流向就不好掌握，需要进行读写分离

## vue恢复初始数据

> 在vue开发场景，有些场景比如“打开模态框”等在关闭这个模态框时候，我们需要重置这个模态框组件内的值
>
> 之前我的办法是定义一个函数，叫init()，然后将data中的数据一一重置为原来数据
>
>  1. 但是一旦data中数据多了，再去维护这个init就麻烦了
>
>  2. emmmm每次添加一个data,就需要在这个init里重置这个字段
>
> 现在有个好办法，那就是this.$options.data() 与this.$data 
>
> 	1. this.$options.data() ：vue原始的数据
>  	2. this.$data ：现在阶段的vue数据

如果我们重写init函数为

```js
methods:{
    init() {
        Object.assign(this.$data, this.$options.data())
    }
}
```

啊这......是不是方便多了
