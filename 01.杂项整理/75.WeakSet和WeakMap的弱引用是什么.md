## WeakSet 和 WeakMap 的弱引用是什么

前置知识：[Set、Map、WeakSet、WeakMap 的基本应用](https://es6.ruanyifeng.com/#docs/set-map)

### Set 与 WeakSet

#### 相同点

- 用途相似：二者都用于存储值的集合，且集合中的值都是唯一的，不会出现重复的值。
- 基本操作类似：都提供了添加元素的操作，Set 使用 add() 方法，WeakSet 同样使用 add() 方法。

#### 不同点

- 存储值的类型
  - Set：可以存储任意类型的值，包括基本数据类型（如 number、string、boolean 等）和引用类型（如对象、数组等）。
  - WeakSet：只能存储对象引用，不能存储基本数据类型。如果尝试向 WeakSet 中添加基本数据类型的值，会抛出错误。
- 垃圾回收机制的影响
  - Set：Set 会对存储的对象保持强引用。这意味着只要 Set 存在，并且对象在 Set 中被引用，该对象就不会被垃圾回收，即使在其他地方没有对该对象的引用。
    \*WeakSet：WeakSet 对存储的对象是弱引用。如果对象在其他地方没有强引用，即使它被存储在 WeakSet 中，也可能会被垃圾回收。一旦对象被垃圾回收，它会自动从 WeakSet 中移除。
- 可迭代性和方法
  - Set：是可迭代的，可以使用 for...of 循环遍历，也有 size 属性来获取元素的数量，还提供了 has()、delete() 等方法。
  - WeakSet：不可迭代，没有 size 属性，也不能使用 for...of 循环遍历。它仅提供了 add()、has() 和 delete() 方法。

### Map 与 WeakMap

#### 相同点

- 用途相似：都用于存储键值对，通过键来获取对应的值。
- 基本操作类似：都提供了设置键值对（set()）、获取值（get()）、检查键是否存在（has()）和删除键值对（delete()）等操作。

#### 不同点

- 键的类型
  - Map：键可以是任意类型，包括基本数据类型和引用类型。
  - WeakMap：键只能是对象引用，不能是基本数据类型。如果尝试使用基本数据类型作为 WeakMap 的键，会抛出错误。
- 垃圾回收机制的影响
  - Map：Map 对键保持强引用。只要 Map 存在，并且键在 Map 中被引用，该键对应的对象就不会被垃圾回收，即使在其他地方没有对该对象的引用。
  - WeakMap：WeakMap 对键是弱引用。如果键对象在其他地方没有强引用，即使它被用作 WeakMap 的键，也可能会被垃圾回收。一旦键对象被垃圾回收，对应的键值对会自动从 WeakMap 中移除。
- 可迭代性和方法

  - Map：是可迭代的，可以使用 for...of 循环遍历，有 size 属性来获取键值对的数量，还提供了 keys()、values() 和 entries() 等方法。
  - WeakMap：不可迭代，没有 size 属性，也不能使用 for...of 循环遍历。它仅提供了 set()、get()、has() 和 delete() 方法。

- 自己总结

  1. 其实弱引用没有想象的玄乎其玄。其实说白了就是一个装高手的概念，没必要觉得很高深。

  2. 如果我们平时有养成好习惯，随手给数组或者对象数据在**其不再参与显示或者计算、应用时（专业词汇为：不再引用时）**给赋值为 null。也可以达到这个效果

  3. 我们可以将弱引用简单的理解为：es6 新语法利用垃圾回收机制，帮我们把一些**不再参与显示或者计算应用的数据**给赋值为 null

  4. 不要过多依赖 WeakSet 和 WeakMap，它虽然在很多项目的源码当中被使用到，了解 WeakSet 的特性在阅读源码的时候会有一定的帮助。但我们不要滥用，请还是养成手动给**不再用到的数组和对象**赋值为 null 的好习惯，浏览器的垃圾回收确实能干很多事，但正如 TS 的类型断言，有时候，我们比电脑更清楚我们需要进行什么操作

- 最后补充一句：

  因为 WeakSet 和 WeakMap 随时都可能被垃圾回收掉，所以他们都不支持被遍历！

  因为 WeakSet 和 WeakMap 随时都可能被垃圾回收掉，所以他们都不支持被遍历！

  因为 WeakSet 和 WeakMap 随时都可能被垃圾回收掉，所以他们都不支持被遍历！

> 以下内容摘自阮一峰 Es6 博客
>
> 指路： https://es6.ruanyifeng.com/

### 回顾 WeakSet

- WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。

  首先，WeakSet 的成员只能是对象，而不能是其他类型的值。

- 其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。

> 这是因为垃圾回收机制根据对象的可达性（reachability）来判断回收，如果对象还能被访问到，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。

> 由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。

> 由于 WeakSet 不能遍历（**因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了**）。WeakSet 的一个用处，**是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。**（🐮🍺 啊，还有这种操作！！！！）

### 回顾 WeakMap

- 首先，`WeakMap`只接受对象作为键名（`null`除外），不接受其他类型的值作为键名。
- 其次，`WeakMap`的键名所指向的对象，不计入垃圾回收机制。

> WeakMap 的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。

> **基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。**
>
> 一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用`WeakMap`结构。当该 DOM 元素被清除，其所对应的`WeakMap`记录就会自动被移除。

> 总之，`WeakMap`的专用场合就是，它的键所对应的对象，可能会在将来消失。`WeakMap`结构有助于防止内存泄漏。

举例一个内存泄露的问题：

```javascript
const e1 = document.getElementById("foo");
const e2 = document.getElementById("bar");
const arr = [
  [e1, "foo 元素"],
  [e2, "bar 元素"],
];
```

上面代码中，`e1`和`e2`是两个对象，我们通过`arr`数组对这两个对象添加一些文字说明。这就形成了`arr`对`e1`和`e2`的引用。

```javascript
// 不需要 e1 和 e2 的时候
// 必须手动删除引用
arr[0] = null;
arr[1] = null;
```

一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放`e1`和`e2`占用的内存。
